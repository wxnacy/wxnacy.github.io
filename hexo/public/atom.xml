<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-06-03T00:54:18.014Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MkDocs 使用 Markdown 管理项目文档</title>
    <link href="http://wxnacy.com/2019/06/03/mkdocs/"/>
    <id>http://wxnacy.com/2019/06/03/mkdocs/</id>
    <published>2019-06-03T00:54:17.000Z</published>
    <updated>2019-06-03T00:54:18.014Z</updated>
    
    <content type="html"><![CDATA[<p>坚持写博客也两年多了，使用 hexo 的一个很大的问题就是不太方便写系列性的文章，属于比较随性的想起什么写什么，最近发现了 <a href="https://github.com/mkdocs/mkdocs" target="_blank" rel="noopener">mkdocs</a>，同样的使用 Markdown 格式编写文档，写系列文章很合适。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#an-zhuang-shi-yong">安装使用</a></li><li><a href="#pei-zhi">配置</a></li></ul><!-- tocstop --></div><p>它的官网就是用 mkdocs 搭建的。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mkdocs2_1058.png" alt="2"></p><p>如果这个界面不熟悉的话，看下面的截图</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mkdocs1_1102.png" alt="1"></p><p>这是它为著名的 <a href="https://readthedocs.org/" target="_blank" rel="noopener">readthedocs</a> 提供的主题，是不是很亲切。</p><p>mkdocs 使用配置起来都很简单，它是由 Python 编写的，这是让我亲切的另一个原因。</p><h2><span id="an-zhuang-shi-yong">安装使用</span><a href="#an-zhuang-shi-yong" class="header-anchor"></a></h2><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install mkdocs</span><br></pre></td></tr></table></figure><p><strong>生成项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdocs new my-project</span><br><span class="line">$ <span class="built_in">cd</span> my-project</span><br></pre></td></tr></table></figure><p>项目的结构如下</p><p><img src="https://www.mkdocs.org/img/initial-layout.png" alt="3"></p><p><strong>启动服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdocs serve</span><br><span class="line">INFO    -  Building documentation...</span><br><span class="line">INFO    -  Cleaning site directory</span><br><span class="line">[I 160402 15:50:43 server:271] Serving on http://127.0.0.1:8000</span><br><span class="line">[I 160402 15:50:43 handlers:58] Start watching changes</span><br><span class="line">[I 160402 15:50:43 handlers:60] Start detecting changes</span><br></pre></td></tr></table></figure><p>mkdocs 会启动一个端口为 8000 的服务，效果如下</p><p><img src="https://www.mkdocs.org/img/screenshot.png" alt="4"></p><p>网页首页默认打开的是文档 <code>docs/index.md</code>，修改文档内容，网页会自动刷新到最新状态。</p><p><strong>生成静态文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdocs build</span><br></pre></td></tr></table></figure><p>随后根目录下会生成一个 <code>site</code> 文件夹，内容是文档的静态网页，使用 Nginx 代理即可访问。</p><h2><span id="pei-zhi">配置</span><a href="#pei-zhi" class="header-anchor"></a></h2><p>mkdocs 的全部配置都在 <code>mkdocs.yml</code> 中，一个最简单的配置如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site_name:</span> <span class="string">MkLorum</span>      <span class="comment"># 站点名称</span></span><br><span class="line"><span class="attr">nav:</span>                    <span class="comment"># 文档目录</span></span><br><span class="line"><span class="attr">    - Home:</span> <span class="string">index.md</span></span><br><span class="line"><span class="attr">    - About:</span> <span class="string">about.md</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">readthedocs</span>      <span class="comment"># 主题</span></span><br></pre></td></tr></table></figure><p><img src="https://www.mkdocs.org/img/readthedocs.png" alt="5"></p><p>另外还有一些常用配置</p><ul><li><code>repo_url</code> 页面会生成一个链接，指向仓库地址，可以是 <code>GitHub, Bitbucket, GitLab</code> 等</li><li><code>site_description</code> 网站的描述</li><li><code>copyright</code> 版权信息</li><li><code>google_analytics</code> 配置 <code>Google analytics</code> 信息，接收一个数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google_analytics: [&apos;UA-36723568-3&apos;, &apos;mkdocs.org&apos;]</span><br></pre></td></tr></table></figure><ul><li><code>docs_dir</code> 文档的存放目录，默认为 <code>docs</code></li><li><code>site_dir</code> 生成静态网页的存放目录，默认为 <code>site</code></li><li><code>dev_addr</code> 使用 <code>mkdocs serve</code> 时启动的地址和端口号，默认 <code>127.0.0.1:8000</code></li></ul><p>更多的配置详见<a href="https://www.mkdocs.org/user-guide/configuration/" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;坚持写博客也两年多了，使用 hexo 的一个很大的问题就是不太方便写系列性的文章，属于比较随性的想起什么写什么，最近发现了 &lt;a href=&quot;https://github.com/mkdocs/mkdocs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mkdocs&lt;/a&gt;，同样的使用 Markdown 格式编写文档，写系列文章很合适。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://wxnacy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>重新学 Java 系列：数组</title>
    <link href="http://wxnacy.com/2019/05/29/java-array/"/>
    <id>http://wxnacy.com/2019/05/29/java-array/</id>
    <published>2019-05-29T01:47:05.000Z</published>
    <updated>2019-05-29T02:36:38.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个是一个系列阅读，关于为什么重新学习，我在文章 <a href="/2018/12/29/java-renew-why/">重新学 Java 系列：新系列、新开始</a>(<a href="https://wxnacy.com/2018/12/29/java-renew-why/">https://wxnacy.com/2018/12/29/java-renew-why/</a>) 中有提到，这个系列是在有 Java 基础的情况下，重新学习讨论一下以前可能忽略掉，或者没理解的知识细节，我想要永远在学习的路上。</p></blockquote><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ding-yi">定义</a></li><li><a href="#bian-li">遍历</a></li><li><a href="#fang-fa">方法</a></li><li><a href="#can-kao">参考</a></li></ul><!-- tocstop --></div><p>已经习惯了 Python 的列表对象，再回来看 Java 的数组和列表很是不适，这种不适已经上升到了生理反应，我为什么要重新学 Java？我是谁？我在哪？</p><p>Java 中数组是用来存储<strong><em>固定大小</em></strong>的<strong><em>同类型</em></strong>元素。</p><h2><span id="sheng-ming">声明</span><a href="#sheng-ming" class="header-anchor"></a></h2><p><code>int</code> 类型数组有两种声明方式 <code>int[] varName</code> 或者 <code>int varName[]</code>，一般建议使用第一种声明方式。后者来源于 <code>c/c++</code>，是为了让 <code>c/c++</code> 程序员快速理解 Java。</p><h2><span id="ding-yi">定义</span><a href="#ding-yi" class="header-anchor"></a></h2><p>有三种定义方式</p><p><strong>静态初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>静态初始化简化方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>静态初始化不能指定元素个数，或者说初始化后元素个数已经固定了，不需要指定。</p><p><strong>动态初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>动态初始化后，数组每个元素会赋值当前类型的默认值，分别如下所以：</p><table><thead><tr><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>整数类型（byte、short、int、long）</td><td>0</td></tr><tr><td>浮点类型（float、double）</td><td>0.0</td></tr><tr><td>字符类型（char）</td><td>‘\u0000’</td></tr><tr><td>布尔类型（boolean）</td><td>false</td></tr><tr><td>引用类型（类、接口、数组）</td><td>null</td></tr></tbody></table><h2><span id="bian-li">遍历</span><a href="#bian-li" class="header-anchor"></a></h2><p>两种方式 <code>for</code> 和 <code>forEach</code></p><p><strong>for</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>forEach</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> n: nums ) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="fang-fa">方法</span><a href="#fang-fa" class="header-anchor"></a></h2><p>数组本身不提供方法，只有一个变量 <code>length</code> 用来获取数组的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = nums.length</span><br></pre></td></tr></table></figure><p>记得当年刚开始学习 Java 时，总是跟列表的 <code>size()</code> 方法搞混，不知道什么时候用 <code>length</code>，什么时候用 <code>size()</code>。现在看来只需要记住，数组的大小是不可变的，所以使用变量 <code>length</code> 即可获取数组大小。而列表是可变的，所以需要使用方法 <code>size()</code> 动态获取大小。</p><p><code>java.util.Arrays</code> 类提供了操作数组的方法，都是静态方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public static void sort(Object[] a)</td><td>排序数组，升序</td></tr><tr><td>public static int binarySearch(Object[] a, Object key)</td><td>使用二分搜索来搜索给定元素，数组需要先排序，返回索引</td></tr><tr><td>public static boolean equals(Object[] a, Object[] a2)</td><td>比较数组是否相同，返回 boolean 类型</td></tr><tr><td>public static void fill(Object[] a, Object val)</td><td>给数组的所有元素指定某个值</td></tr></tbody></table><h2><span id="can-kao">参考</span><a href="#can-kao" class="header-anchor"></a></h2><ul><li><a href="https://www.runoob.com/java/java-array.html" target="_blank" rel="noopener">Java 数组</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个是一个系列阅读，关于为什么重新学习，我在文章 &lt;a href=&quot;/2018/12/29/java-renew-why/&quot;&gt;重新学 Java 系列：新系列、新开始&lt;/a&gt;(&lt;a href=&quot;https://wxnacy.com/2018/12/29/java-renew-why/&quot;&gt;https://wxnacy.com/2018/12/29/java-renew-why/&lt;/a&gt;) 中有提到，这个系列是在有 Java 基础的情况下，重新学习讨论一下以前可能忽略掉，或者没理解的知识细节，我想要永远在学习的路上。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://wxnacy.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>异或运算及应用</title>
    <link href="http://wxnacy.com/2019/05/28/what-is-xor/"/>
    <id>http://wxnacy.com/2019/05/28/what-is-xor/</id>
    <published>2019-05-28T06:04:30.000Z</published>
    <updated>2019-05-28T06:21:41.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>异或，英文为exclusive OR，缩写成xor，异或是一个数学运算符。它应用于逻辑运算</p></blockquote><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>异或也叫半加运算，其运算法则相当于不带进位的二进制加法，它的运算规则为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制的比较位相同则结果返回 0，不同则为 1</span><br></pre></td></tr></table></figure><p>运算符有几种表示方式</p><table><thead><tr><th>名称</th><th>符号</th></tr></thead><tbody><tr><td>数学符号</td><td>⊕</td></tr><tr><td>英文简称</td><td>xor</td></tr><tr><td>程序符号</td><td>^</td></tr></tbody></table><p><strong>运算推导</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 ^ 8 = 2</span><br></pre></td></tr></table></figure><p>单看这个表达式比较费解，我们转成二进制来看下</p><table><thead><tr><th>-</th><th>相同</th><th>不同</th><th>相同</th></tr></thead><tbody><tr><td>5</td><td>1</td><td>0</td><td>1</td></tr><tr><td>8</td><td>1</td><td>1</td><td>1</td></tr><tr><td>5 ^ 8</td><td>0</td><td>1</td><td>0</td></tr><tr><td>2</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>异或在开发中的应用可以参看一道算法题 <a href="/leetcode/problems/136-single-number/">只出现一次的数字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;异或，英文为exclusive OR，缩写成xor，异或是一个数学运算符。它应用于逻辑运算&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://wxnacy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python list 对象一些方法的时间复杂度</title>
    <link href="http://wxnacy.com/2019/05/27/python-list-time-complexity/"/>
    <id>http://wxnacy.com/2019/05/27/python-list-time-complexity/</id>
    <published>2019-05-27T09:07:51.000Z</published>
    <updated>2019-05-27T09:36:33.810Z</updated>
    
    <content type="html"><![CDATA[<p>列举下 Python list 对象常用方法的时间复杂度</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><table><thead><tr><th>方法</th><th>时间复杂度</th></tr></thead><tbody><tr><td>list[i]</td><td>O(1)</td></tr><tr><td>list[i] = 1</td><td>O(1)</td></tr><tr><td>list[i:j]</td><td>O(k)  k = j - i</td></tr><tr><td>list[i:k] = list()</td><td>O(n + k)</td></tr><tr><td>list.index(item)</td><td>O(n)</td></tr><tr><td>list.append(item)</td><td>O(1)</td></tr><tr><td>list.insert(i, item)</td><td>O(n)</td></tr><tr><td>list.pop()</td><td>O(1)</td></tr><tr><td>list.pop(i)</td><td>O(n) 假如推出的是第一个元素，那么数组所有的元素都要重新计算坐标</td></tr><tr><td>del list[i]</td><td>O(n)</td></tr><tr><td>item in list</td><td>O(n)</td></tr><tr><td>list.reverse()</td><td>O(n)</td></tr><tr><td>list.sort()</td><td>O(n logn)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列举下 Python list 对象常用方法的时间复杂度&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 跳转其他页面</title>
    <link href="http://wxnacy.com/2019/05/25/js-href/"/>
    <id>http://wxnacy.com/2019/05/25/js-href/</id>
    <published>2019-05-25T01:49:45.000Z</published>
    <updated>2019-05-25T01:51:51.228Z</updated>
    
    <content type="html"><![CDATA[<p>几种常见的页面跳转方式</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span> type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       window.location.href=<span class="string">"login.jsp?backurl="</span>+window.location.href;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</span><br><span class="line">    alert(<span class="string">"返回"</span>);</span><br><span class="line">    window.history.back(-<span class="number">1</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</span><br><span class="line">    window.navigate(<span class="string">"top.jsp"</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"JavaScript"</span>&gt;</span><br><span class="line">    self.location=’top.htm’;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</span><br><span class="line">    alert(<span class="string">"非法访问！"</span>);</span><br><span class="line">    top.location=’xx.jsp’;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种常见的页面跳转方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://wxnacy.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Git blame 查看代码是谁写的</title>
    <link href="http://wxnacy.com/2019/05/21/git-blame/"/>
    <id>http://wxnacy.com/2019/05/21/git-blame/</id>
    <published>2019-05-21T10:30:27.000Z</published>
    <updated>2019-05-21T10:30:27.125Z</updated>
    
    <content type="html"><![CDATA[<p><code>git blame</code> 命令可以查看每行代码的提交详情，包括提交人、时间等信息，成熟的编辑器如 Sublime、Jetbrains 等都集成了这个功能，使用起来非常简单，今天我们来关注下这个命令本身，毕竟在服务器上我们可不能安装这些编辑器。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame1_874.png" alt="1"></p><p>得到的结果，每列分别为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提交 sha1   用户名 提交时间                    行数    代码</span><br><span class="line">...</span><br><span class="line">39a22489    (wxnacy 2018-07-26 19:01:55 +0800  6)      def filter(<span class="built_in">source</span>: dict, *args, **kwargs):</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这是最简单的语法，我们查看文件的每一行代码的最后提交详情，不过这通常不是我们的目的，一般只需要看某一行或某个范围行，这时可以使用 <code>-L</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L &lt;start&gt;[,&lt;end&gt;]</span><br></pre></td></tr></table></figure><p><strong>查看第 10 行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,10</span><br></pre></td></tr></table></figure><p><strong>查看第 10 行及以后</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10</span><br></pre></td></tr></table></figure><p><strong>查看第 10 到 20 行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,20</span><br></pre></td></tr></table></figure><p><code>end</code> 也可以加上正负符号，比如</p><p><strong>查看 10 行以后 5 行的数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,+5</span><br></pre></td></tr></table></figure><p><strong>查看 10 行以前 5 行的数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,-5</span><br></pre></td></tr></table></figure><p><code>start</code> 和 <code>end</code> 又不止于数字，它还可以是个正则表达式，如果 <code>start</code> 为正则表达式，则会匹配到 <code>end</code> 行，如果 <code>end</code> 为正则表达式，则从 <code>start</code> 行开始匹配，到匹配行截止，如果 <code>start</code> 或者 <code>end</code> 其中之一有值，则从匹配行开始显示全部内容。</p><p><strong>查看正则匹配到 20 行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L /filter/,20</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame2_872.png" alt="2"></p><p><strong>查看 3 行到正则匹配行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 3,/filter/</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame3.png" alt="3"></p><p><code>-L</code> 参数的功能还不止这些，有个更智能的方式是直接通过函数名来查看一个区域块的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L:&lt;func_name&gt;</span><br></pre></td></tr></table></figure><p>这是很方便的能力，不过只能识别文件最外层的方法名和类名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L:filter</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame4.png" alt="4"></p><p>完整参数列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">usage: git blame [&lt;options&gt;] [&lt;rev-opts&gt;] [&lt;rev&gt;] [--] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">    &lt;rev-opts&gt; are documented <span class="keyword">in</span> git-rev-list(1)</span><br><span class="line"></span><br><span class="line">    --incremental         Show blame entries as we find them, incrementally</span><br><span class="line">    -b                    Show blank SHA-1 <span class="keyword">for</span> boundary commits (Default: off)</span><br><span class="line">    --root                Do not treat root commits as boundaries (Default: off)</span><br><span class="line">    --show-stats          Show work cost statistics</span><br><span class="line">    --progress            Force progress reporting</span><br><span class="line">    --score-debug         Show output score <span class="keyword">for</span> blame entries</span><br><span class="line">    -f, --show-name       Show original filename (Default: auto)</span><br><span class="line">    -n, --show-number     Show original linenumber (Default: off)</span><br><span class="line">    -p, --porcelain       Show <span class="keyword">in</span> a format designed <span class="keyword">for</span> machine consumption</span><br><span class="line">    --line-porcelain      Show porcelain format with per-line commit information</span><br><span class="line">    -c                    Use the same output mode as git-annotate (Default: off)</span><br><span class="line">    -t                    提交时间显示为时间戳，默认关闭</span><br><span class="line">    -l                    显示完整的 commit sha1，默认关闭</span><br><span class="line">    -s                    Suppress author name and timestamp (Default: off)</span><br><span class="line">    -e, --show-email      显示提交用户的邮箱，默认关闭</span><br><span class="line">    -w                    Ignore whitespace differences</span><br><span class="line">    --indent-heuristic    Use an experimental heuristic to improve diffs</span><br><span class="line">    --minimal             Spend extra cycles to find better match</span><br><span class="line">    -S &lt;file&gt;             Use revisions from &lt;file&gt; instead of calling git-rev-list</span><br><span class="line">    --contents &lt;file&gt;     Use &lt;file&gt;<span class="string">'s contents as the final image</span></span><br><span class="line"><span class="string">    -C[&lt;score&gt;]           Find line copies within and across files</span></span><br><span class="line"><span class="string">    -M[&lt;score&gt;]           Find line movements within and across files</span></span><br><span class="line"><span class="string">    -L &lt;n,m&gt;              Process only line range n,m, counting from 1</span></span><br><span class="line"><span class="string">    --abbrev[=&lt;n&gt;]        use &lt;n&gt; digits to display SHA-1s</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://git-scm.com/docs/git-blame" target="_blank" rel="noopener">git-blame</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;git blame&lt;/code&gt; 命令可以查看每行代码的提交详情，包括提交人、时间等信息，成熟的编辑器如 Sublime、Jetbrains 等都集成了这个功能，使用起来非常简单，今天我们来关注下这个命令本身，毕竟在服务器上我们可不能安装这些编辑器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://wxnacy.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>PySpider 安装的坑：不支持 3.7 版本</title>
    <link href="http://wxnacy.com/2019/05/20/pyspider-install-error-with-3-7/"/>
    <id>http://wxnacy.com/2019/05/20/pyspider-install-error-with-3-7/</id>
    <published>2019-05-20T10:13:05.000Z</published>
    <updated>2019-05-20T10:13:05.730Z</updated>
    
    <content type="html"><![CDATA[<p>PySpider 安装还真是各种坑啊，所以感觉不能单独记录，收成一个系列吧。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>这次的问题是不兼容 3.7 版本，安装虽然成功，但是运行及报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/bin/pyspider"</span>, line 11, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    load_entry_point(<span class="string">'pyspider==0.3.10'</span>, <span class="string">'console_scripts'</span>, <span class="string">'pyspider'</span>)()</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pkg_resources/__init__.py"</span>, line 487, <span class="keyword">in</span> load_entry_point</span><br><span class="line">    <span class="built_in">return</span> get_distribution(dist).load_entry_point(group, name)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pkg_resources/__init__.py"</span>, line 2728, <span class="keyword">in</span> load_entry_point</span><br><span class="line">    <span class="built_in">return</span> ep.load()</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pkg_resources/__init__.py"</span>, line 2346, <span class="keyword">in</span> load</span><br><span class="line">    <span class="built_in">return</span> self.resolve()</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pkg_resources/__init__.py"</span>, line 2352, <span class="keyword">in</span> resolve</span><br><span class="line">    module = __import__(self.module_name, fromlist=[<span class="string">'__name__'</span>], level=0)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pyspider/run.py"</span>, line 231</span><br><span class="line">    async=True, get_object=False, no_input=False):</span><br><span class="line">        ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>一看到这个错误心里就有一种不祥的预感，妥妥的代码出错了啊，咋它就这么多事呢？</p><p>这个错误的原因在于 <code>3.7</code> 版本以上已经把 <code>async</code> 和 <code>await</code> 列为关键字，所以在用 <code>async</code> 当参数名自然会报错，看了下源码，已经将 <code>async</code> 改为了 <code>async_mode</code>，但是最新发行版本 <code>0.3.10</code> 版本已经一年多了，还没有发新版是怎么个意思，作者也觉得 <code>3.7</code> 版本兼容还很大呗，好吧，人家也没说过支持 <code>3.7</code>，你想用就自己折腾呗。</p><p>这时候有两种方式，第一下载最近版本的代码，然后改个版本号自己编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/binux/pyspider</span><br><span class="line">$ <span class="built_in">cd</span> pyspider</span><br><span class="line">$ vim pyspider/__init__.py</span><br><span class="line">__version__ = <span class="string">'0.3.11'</span></span><br><span class="line">$ pip install .</span><br></pre></td></tr></table></figure><p>或者将当前版本的代码修改一下，替换掉 <code>async</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim /Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pyspider/run.py</span><br><span class="line">$ vim /Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pyspider/fetcher/tornado_fetcher.py</span><br><span class="line">$ vim /Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pyspider/webui/app.py</span><br></pre></td></tr></table></figure><p>前面那一大坨是本地仓库的位置，打开文件后复制下面的文字然后回车即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/async/async_mode/g</span><br></pre></td></tr></table></figure><p>然后再次运行即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PySpider 安装还真是各种坑啊，所以感觉不能单独记录，收成一个系列吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>PySpider 安装的坑：PyCurl 出错</title>
    <link href="http://wxnacy.com/2019/05/19/install-pycurl-error/"/>
    <id>http://wxnacy.com/2019/05/19/install-pycurl-error/</id>
    <published>2019-05-19T00:01:36.000Z</published>
    <updated>2019-05-19T00:01:36.181Z</updated>
    
    <content type="html"><![CDATA[<p>问题起源在于安装 PySpider 时需要依赖 PyCurl，过程中报错</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collecting pycurl (from pyspider)</span><br><span class="line">  Using cached https://pypi.tuna.tsinghua.edu.cn/packages/e8/e4/0dbb8735407189f00b33d84122b9be52c790c7c3b25286826f4e1bdb7bde/pycurl-7.43.0.2.tar.gz</span><br><span class="line">    ERROR: Complete output from <span class="built_in">command</span> python setup.py egg_info:</span><br><span class="line">    ERROR: Using curl-config (libcurl 7.54.0)</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">      File <span class="string">"&lt;string&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">      File <span class="string">"/private/var/folders/kz/8syfctw919zdt3shr9w5j8v00000gn/T/pip-install-h_pgkvxp/pycurl/setup.py"</span>, line 913, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">        ext = get_extension(sys.argv, split_extension_source=split_extension_source)</span><br><span class="line">      File <span class="string">"/private/var/folders/kz/8syfctw919zdt3shr9w5j8v00000gn/T/pip-install-h_pgkvxp/pycurl/setup.py"</span>, line 582, <span class="keyword">in</span> get_extension</span><br><span class="line">        ext_config = ExtensionConfiguration(argv)</span><br><span class="line">      File <span class="string">"/private/var/folders/kz/8syfctw919zdt3shr9w5j8v00000gn/T/pip-install-h_pgkvxp/pycurl/setup.py"</span>, line 99, <span class="keyword">in</span> __init__</span><br><span class="line">        self.configure()</span><br><span class="line">      File <span class="string">"/private/var/folders/kz/8syfctw919zdt3shr9w5j8v00000gn/T/pip-install-h_pgkvxp/pycurl/setup.py"</span>, line 316, <span class="keyword">in</span> configure_unix</span><br><span class="line">        specify the SSL backend manually.<span class="string">''</span><span class="string">')</span></span><br><span class="line"><span class="string">    __main__.ConfigurationError: Curl is configured to use SSL, but we have not been able to determine which SSL backend it is using. Please see PycURL documentation for how to specify the SSL backend manually.</span></span><br><span class="line"><span class="string">    ----------------------------------------</span></span><br><span class="line"><span class="string">ERROR: Command "python setup.py egg_info" failed with error code 1 in /private/var/folders/kz/8syfctw919zdt3shr9w5j8v00000gn/T/pip-install-h_pgkvxp/pycurl/</span></span><br></pre></td></tr></table></figure><p>出错内容 <code>Curl is configured to use SSL, but we have not been able to determine which SSL backend it is using. Please see PycURL documentation for how to specify the SSL backend manually.</code></p><p>原因在于正确配置配置 SSL，<a href="http://pycurl.io/docs/latest/install.html#easy-install-pip" target="_blank" rel="noopener">官方文档</a>中给出了方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PYCURL_SSL_LIBRARY=[openssl|gnutls|nss]</span><br></pre></td></tr></table></figure><p>openssl 是比较常用的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PYCURL_SSL_LIBRARY=openssl</span><br></pre></td></tr></table></figure><p>如果你的 <code>.bash_profile</code> 文件中没有配置 <code>LDFLAGS</code> 和 <code>CPPFLAGS</code>，那需要在当前环境中进行激活。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> CFLAGS=<span class="string">"-I<span class="variable">$(brew --prefix openssl)</span>/include"</span></span><br><span class="line">$ <span class="built_in">export</span> LDFLAGS=<span class="string">"-L<span class="variable">$(brew --prefix openssl)</span>/lib"</span></span><br></pre></td></tr></table></figure><p><code>$(brew --prefix openssl)</code> 是为了获取 openssl 的安装目录，这是在使用 HomeBrew 安装的前提下，如果不是的话可以使用 <code>find</code> 命令进行查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo find /usr -iname ssl.h</span><br></pre></td></tr></table></figure><ul><li><a href="https://stackoverflow.com/questions/51019622/curl-is-configured-to-use-ssl-but-we-have-not-been-able-to-determine-which-ssl" target="_blank" rel="noopener">Curl is configured to use SSL, but we have not been able to determine which SSL backend it is using</a></li><li><a href="https://www.jianshu.com/p/61fd0c16aef4" target="_blank" rel="noopener">Mac下安装pycurl填坑记录</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题起源在于安装 PySpider 时需要依赖 PyCurl，过程中报错&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Vim 执行 Shell 命令（3）</title>
    <link href="http://wxnacy.com/2019/05/17/vim-open-terminal/"/>
    <id>http://wxnacy.com/2019/05/17/vim-open-terminal/</id>
    <published>2019-05-17T09:40:56.000Z</published>
    <updated>2019-05-18T02:35:54.696Z</updated>
    
    <content type="html"><![CDATA[<p>上个月写了两篇 Vim 中使用 Shell 的文章，<a href="/2019/04/15/vim-run-shell/">Vim 执行 Shell 命令（1）</a> 和 <a href="/2019/04/18/vim-in-shell/">Vim 执行 Shell 命令（2）</a>，在 <a href="https://github.com/wxnacy/wxnacy.github.io/issues/1" target="_blank" rel="noopener">typebrook</a> 的提醒下发现还有 <code>:terminal</code> 可以实现，并且用了下发现还很好用。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell8.gif" alt="1"></p><p>像预览中展示的这样，<code>:terminal</code> 可以切分出一个 terminal 来运行 shell 命令，这样的方式比前面的介绍的两种方式要更好，它类似 tmux 的多窗口操作，你也可以一边编写代码，一边执行命令。</p><p>打开命令如下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 打开 terminal，水平分屏"</span></span><br><span class="line">:terminal</span><br><span class="line">:term</span><br><span class="line">:ter</span><br><span class="line"></span><br><span class="line"><span class="string">" 打开 terminal，垂直分屏"</span></span><br><span class="line">:<span class="keyword">vertical</span> terminal</span><br><span class="line">:<span class="keyword">vert</span> ter</span><br></pre></td></tr></table></figure><p>关闭 terminal 可以直接输入 <code>exit</code> 然后回车，也可以直接使用 <code>&lt;CTRL-D&gt;</code>，我更喜欢使用后者。</p><p>打开 terminal 后，可以使用 <code>CTRL-W</code> 前缀键来进行窗口操作，正常使用 <code>&lt;CTRL-W&gt;n</code> 打开窗口后，怎么操作，terminal 就可以怎么操作，比如在垂直打开 terminal 后，使用 <code>&lt;CTRL-W&gt;h</code> 和 <code>&lt;CTRL-W&gt;l</code> 可以将光标在两个窗口中切换</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell9.gif" alt="2"></p><p>打开 terminal 后，左下角显示的 <code>TERMINAL</code> 字样，此时我们无法直接对该窗口下的内容进行保存操作，因为它处于 <code>buftype</code> 下，我们可以使用另存为的方式将执行结果保存起来，比如 <code>&lt;CTRL-W&gt;:w newfile</code>，不过这时候有个问题，它会将 shell 环境下所有的显示内容都保存到文件中，包括你的输入命令和一些无关的显示文字。</p><p>这时候我们可以在打开 terminal 时，在命令后面跟上想要使用的 shell 命令，这时会将执行结果保存在缓存文件中并在 terminal 中打开。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">vert</span> ter <span class="keyword">ls</span> -<span class="keyword">l</span></span><br></pre></td></tr></table></figure><p>该窗口仍然是缓存状态，所以不能直接保存，使用 <code>:w newfile</code> 另存为新文件即可，此时窗口左下角显示的是 <code>NORMAL</code>，我们不能再用 <code>&lt;CTRL-D&gt;</code> 关闭窗口了，只能使用 <code>:q</code> 来关闭。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell10.gif" alt="3"></p><p>我介绍的三种方式都各有应用场景，综合来说 <code>:terminal</code> 是我在没有 tmux 情况的首选。</p><p>以上只是很简单的使用，也是比较常用的，它在 Vim 中是个大栏目，很多复杂的编辑器操作都可以通过它来完成，你可以阅读文档 <code>:h terminal</code> 来了解这些</p><p>不管你用了 Vim 多久，你总是会发现更多你不了解的功能，又学到了新东西，开心😊</p><ul><li><a href="https://vimhelp.org/terminal.txt.html#terminal.txt" target="_blank" rel="noopener">terminal.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上个月写了两篇 Vim 中使用 Shell 的文章，&lt;a href=&quot;/2019/04/15/vim-run-shell/&quot;&gt;Vim 执行 Shell 命令（1）&lt;/a&gt; 和 &lt;a href=&quot;/2019/04/18/vim-in-shell/&quot;&gt;Vim 执行 Shell 命令（2）&lt;/a&gt;，在 &lt;a href=&quot;https://github.com/wxnacy/wxnacy.github.io/issues/1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;typebrook&lt;/a&gt; 的提醒下发现还有 &lt;code&gt;:terminal&lt;/code&gt; 可以实现，并且用了下发现还很好用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Python 在 Mac 系统中从剪切板中获取图片</title>
    <link href="http://wxnacy.com/2019/05/13/python-get-image-from-clipboard-on-mac/"/>
    <id>http://wxnacy.com/2019/05/13/python-get-image-from-clipboard-on-mac/</id>
    <published>2019-05-13T07:46:09.000Z</published>
    <updated>2019-05-14T08:48:32.515Z</updated>
    
    <content type="html"><![CDATA[<p>最近想给 <a href="https://github.com/wxnacy/goss" target="_blank" rel="noopener">goss</a> 加点料，就是省去截完图后，保存本地图片的步骤，而是直接从剪切板里获取图片并上传 Github，这样，如何从剪切板中获取图片就成了关键。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#huo-qu-bing-bao-cun-ben-di">获取并保存本地</a></li><li><a href="#huo-qu-bing-xie-ru-dao-liu">获取并写入到流</a></li></ul><!-- tocstop --></div><p>本来想着直接使用 <code>pbcopy</code> 和 <code>pbpaste</code> 命令组合，不过可惜的是它们只能适用于文本。</p><p>此时我们需要借助三方包 <a href="https://pillow.readthedocs.io/en/stable/" target="_blank" rel="noopener">Pillow</a></p><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pillow</span><br></pre></td></tr></table></figure><h2><span id="huo-qu-bing-bao-cun-ben-di">获取并保存本地</span><a href="#huo-qu-bing-bao-cun-ben-di" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = ImageGrab.grabclipboard()</span><br><span class="line"><span class="keyword">if</span> isinstance(img, Image.Image):</span><br><span class="line">    img.save(<span class="string">'test.png'</span>, <span class="string">'png'</span>)</span><br></pre></td></tr></table></figure><p>截图并保存剪切板后，<code>grabclipboard()</code> 方法可以获取剪切板中的图片，为了防止出错，我们还要判断取出的数据是否 <code>Image.Image</code> 图片类型，随后调用 <code>save()</code> 方法保存本地即可。</p><h2><span id="huo-qu-bing-xie-ru-dao-liu">获取并写入到流</span><a href="#huo-qu-bing-xie-ru-dao-liu" class="header-anchor"></a></h2><p>不过我希望的不是保存到本地，而是直接写入到流中，再进行二次操作，此时需要借助 io 包，将图片保存到 io 流中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">img = ImageGrab.grabclipboard()</span><br><span class="line">img_bytes = io.BytesIO()</span><br><span class="line"><span class="keyword">if</span> isinstance(img, Image.Image):</span><br><span class="line">    <span class="comment">#  img.save('test.png', 'png')</span></span><br><span class="line">    img.save(img_bytes, <span class="string">'png'</span>)</span><br><span class="line">    print(img_bytes.getvalue())</span><br></pre></td></tr></table></figure><p>能拿到字节流就可以对其操作，在转换为其它格式，比如 base64，具体方法可以参考 <a href="https://www.devdungeon.com/content/grab-image-clipboard-python-pillow#convert_bytes_to_html_base64_img_tag" target="_blank" rel="noopener">Convert bytes to base64 HTML img tag</a></p><ul><li><a href="https://stackoverflow.com/questions/35254655/how-to-copy-a-image-from-clipboard-in-python?rq=1" target="_blank" rel="noopener">How to copy a image from clipboard in Python?</a></li><li><a href="https://www.devdungeon.com/content/grab-image-clipboard-python-pillow" target="_blank" rel="noopener">Grab Image from Clipboard in Python with Pillow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想给 &lt;a href=&quot;https://github.com/wxnacy/goss&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;goss&lt;/a&gt; 加点料，就是省去截完图后，保存本地图片的步骤，而是直接从剪切板里获取图片并上传 Github，这样，如何从剪切板中获取图片就成了关键。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 memory_profiler 分析程序内存占用情况</title>
    <link href="http://wxnacy.com/2019/05/05/python-memory-profiler/"/>
    <id>http://wxnacy.com/2019/05/05/python-memory-profiler/</id>
    <published>2019-05-05T09:18:09.000Z</published>
    <updated>2019-05-05T11:48:47.296Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中可以使用 memory_profiler 包来分析程序的内存占用情况</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#shi-yong">使用</a></li><li><a href="#can-shu-shi-yong">参数使用</a></li><li><a href="#mprof-ming-ling">mprof 命令</a></li></ul><!-- tocstop --></div><p>memory_profiler 可以分析每行代码的内存使用情况，使用起来非常简单。</p><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install memory_profiler</span><br></pre></td></tr></table></figure><h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    c = []</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * (<span class="number">2</span> ** <span class="number">20</span>)</span><br><span class="line">    b = [<span class="number">1</span>] * (<span class="number">2</span> ** <span class="number">20</span>)</span><br><span class="line">    c.extend(a)</span><br><span class="line">    c.extend(b)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    <span class="keyword">del</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test1()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m memory_profiler memory_profiler</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf1.png" alt="1"></p><p>结果如图，每一步的内存变化情况都很清楚</p><ul><li><code>Mem usage</code> 为当前总内存</li><li><code>Increment</code> 为增加的内存</li></ul><p>总结起来使用非常时间</p><ul><li>方法前加上 <code>@profile</code> 主键</li><li>使用 <code>python -m memory_profiler</code> 来运行，不过直接用 <code>python</code> 运行也可以</li></ul><p>通过上面这段代码我们可以发现，<code>del</code> 语句只是将变量删除，并不能减少内存的消耗。</p><h2><span id="can-shu-shi-yong">参数使用</span><a href="#can-shu-shi-yong" class="header-anchor"></a></h2><ul><li><code>precision</code> 显示小数点后的位数</li></ul><p>默认显示的内存单位为 <code>MiB</code>，小数点后显示一位，如果某行代码占用内存比较小，就可能显示不出来，此时可以通过调整小数点后的位数实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@profile(precision=4)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>] * (<span class="number">2</span> ** <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test3()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf3.png" alt="3"></p><ul><li><code>stream</code> 将结果输出到流中</li></ul><p>每次运行都要打印内存情况，势必会影响程序输出效果，我们可以将结果通过流输出到文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile(precision=4, @profile(precision=4, stream=open('/tmp/memory_profiler.log','w+')))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>] * (<span class="number">2</span> ** <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test3()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf4.png" alt="4"></p><h2><span id="mprof-ming-ling">mprof 命令</span><a href="#mprof-ming-ling" class="header-anchor"></a></h2><p>memory_profiler 本身也提供了命令行 <code>mprof</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Usage: mprof &lt;<span class="built_in">command</span>&gt; &lt;options&gt; &lt;arguments&gt;</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line"></span><br><span class="line">    run      运行给定的命令或 python 文件</span><br><span class="line">    rm       删除 mprof 生成的给定文件</span><br><span class="line">    clean    清除当前目录中 mprof 创建的文件</span><br><span class="line">    list     显示带索引的现有配置文件</span><br><span class="line">    plot     可以将 mprof run 的结果生成图片</span><br><span class="line"></span><br><span class="line">Type mprof &lt;<span class="built_in">command</span>&gt; --<span class="built_in">help</span> <span class="keyword">for</span> usage <span class="built_in">help</span> on a specific <span class="built_in">command</span>.</span><br><span class="line">For example, mprof plot --<span class="built_in">help</span> will list all plotting options.</span><br></pre></td></tr></table></figure><p>重点说一下 <code>plot</code> 命令，<code>run</code> 命令可以生成 <code>.dat</code> 文件，<code>plot</code> 可以将该文件生成图片，不过需要 <code>matplotlib</code> 包的加持。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pip install matplotlib</span><br><span class="line">$ mprof run memory_profiler_demo.py</span><br><span class="line">$ mprof list</span><br><span class="line">0 mprofile_20190505182200.dat 18:22:00 05/05/2019</span><br><span class="line">$ mprof plot mprofile_20190505182200.dat</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf5_1260.png" alt="5"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中可以使用 memory_profiler 包来分析程序的内存占用情况&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux time 命令统计脚本耗时</title>
    <link href="http://wxnacy.com/2019/04/29/linux-time/"/>
    <id>http://wxnacy.com/2019/04/29/linux-time/</id>
    <published>2019-04-29T04:10:22.000Z</published>
    <updated>2019-04-29T04:10:22.400Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 中 time 命令可以统计执行脚本的耗时。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>我们以 <a href="https://wxnacy.com/2019/02/01/linux-wc/">wc</a> 命令为例子，统计下计算文件行数时的耗时情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc -l tmd-error.log</span><br><span class="line">655572 tmd-error.log</span><br></pre></td></tr></table></figure><p>只需要在命令前加上 <code>time</code> 即可</p><p><strong>bash环境下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ time wc -l tmd-error.log</span><br><span class="line">  655572 tmd-error.log</span><br><span class="line"></span><br><span class="line">real    0m0.047s</span><br><span class="line">user    0m0.036s</span><br><span class="line">sys     0m0.011s</span><br></pre></td></tr></table></figure><p>得到的结果有三个时间，<code>real</code> 为真实耗时，而 <code>user</code> 和 <code>sys</code> 为用户环境和系统的各自耗时。</p><p><strong>zsh环境下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ time wc -l tmd-error.log</span><br><span class="line">  655572 tmd-error.log</span><br><span class="line">wc -l tmd-error.log  0.04s user 0.01s system 97% cpu 0.047 total</span><br></pre></td></tr></table></figure><p><code>zsh</code> 环境的输出结果不太易读，只需要看最后的 <code>total</code> 值即可</p><p><strong>fish环境下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wxnacy@wxnacydeMacBook-Pro ~/P/t/<span class="built_in">log</span>&gt; time wc -l tmd-error.log</span><br><span class="line">  655572 tmd-error.log</span><br><span class="line">        0.04 real         0.03 user         0.01 sys</span><br></pre></td></tr></table></figure><p>说实话还是 <code>fish</code> 环境的看着最舒服，要不是它不兼容 <code>bash</code> 脚本，我感觉它早就制霸 shell 届了，哼。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Linux 中 time 命令可以统计执行脚本的耗时。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 判断字符串是否为大写及 is 方法延伸</title>
    <link href="http://wxnacy.com/2019/04/28/python-isupper/"/>
    <id>http://wxnacy.com/2019/04/28/python-isupper/</id>
    <published>2019-04-28T13:16:02.000Z</published>
    <updated>2019-04-28T13:16:02.299Z</updated>
    
    <content type="html"><![CDATA[<p>Python 判断字符串是否为大写及延伸</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>以下方法仅判断字符，数字和符号不影响结果</p><p><strong>isupper()</strong> 判断是否都为大写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a!'</span>.isupper()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1A!'</span>.isupper()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>islower()</strong> 判断是否都为小写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1As!'</span>.islower()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1s!'</span>.islower()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>istitle()</strong> 判断所有的单词首字符都是大写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'This Is Upper'</span>.istitle()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'This Is upper1'</span>.istitle()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p><strong>isspace()</strong> 判断所有的字符都是空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'This Is upper1'</span>.isspace()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">' '</span>.isspace()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>isalnum()</strong> 判断所有的字符都是数字或字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a!'</span>.isalnum()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'aa'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'11'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>isalpha()</strong> 判断所有的字符都是字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'11'</span>.isalpha()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a'</span>.isalpha()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'aa'</span>.isalpha()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>isdigit()</strong> 判断所有的字符都是数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'aa'</span>.isdigit()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'11'</span>.isdigit()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a'</span>.isdigit()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>还有两个类似的方法 <strong>isdecimal()</strong> 和 <strong>isnumeric()</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 判断字符串是否为大写及延伸&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>awk 正则表达式中使用参数</title>
    <link href="http://wxnacy.com/2019/04/26/awk-regex-use-var/"/>
    <id>http://wxnacy.com/2019/04/26/awk-regex-use-var/</id>
    <published>2019-04-26T00:08:55.000Z</published>
    <updated>2019-04-26T00:08:55.487Z</updated>
    
    <content type="html"><![CDATA[<p>awk 使用正则表达式过滤文本时可以使用可变参数，我本认为这应该是很普遍的需求，然而网上找了一圈也没看到一个比较全面的教程，不过东拼西凑也总算是满足了需求，今天来总结下。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#ming-ling-xing-chuan-can">命令行传参</a></li><li><a href="#jiao-ben-zhong-chuan-can">脚本中传参</a></li></ul><!-- tocstop --></div><p>首先将当前文件列表导入到一份文本文件 <a href="https://raw.githubusercontent.com/wxnacy/file/master/common/text" target="_blank" rel="noopener">text</a> 中，作为测试使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ll &gt; text</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/awk1_548.png" alt="1"></p><h2><span id="ming-ling-xing-chuan-can">命令行传参</span><a href="#ming-ling-xing-chuan-can" class="header-anchor"></a></h2><p>首先我们打算过滤文件列表的最后修改时间为 <code>10</code> 点的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'/10/ &#123;print $0&#125;'</span> text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff    1052 Mar 13 22:50 awktest</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     100 Mar 25 22:53 b.py</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     121 Mar 14 10:19 test.go</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     106 Mar 13 10:53 test.js</span><br></pre></td></tr></table></figure><p>这样得到的结果并准确，我们应该精确的对第 8 行进行正则匹配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'$8 ~ /10/ &#123;print $0&#125;'</span> text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     121 Mar 14 10:19 test.go</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     106 Mar 13 10:53 test.js</span><br></pre></td></tr></table></figure><p>现在问题来了，我希望对 <code>10</code> 进行参数化，该怎么做呢？</p><p>awk 命令行模式可以直接使用 shell 参数，不过比较麻烦一点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hour=10</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$hour</span></span><br><span class="line">10</span><br><span class="line">$ awk <span class="string">'$8 ~ /'</span><span class="string">"<span class="variable">$hour</span>"</span><span class="string">'/ &#123;print $0&#125;'</span> text</span><br></pre></td></tr></table></figure><p><code>$hour</code> 还需要使用 <code>&#39;&quot;&quot;&#39;</code> 包裹起来才行</p><p>好在 awk 也有办法传递参数，使用 <code>-v</code> 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v hour=10 <span class="string">'$8 ~ hour &#123;print $0&#125;'</span> text</span><br></pre></td></tr></table></figure><p>如果使用参数的话，正则内容就不用 <code>//</code> 包裹了，直接使用参数即可。</p><p>只是这种情况下，如果我们想增加额外的符号，需要使用字符串包裹起来，比如想要查找时间以 <code>18</code> 为结尾的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v hour=18 <span class="string">'$8 ~ hour"$" &#123;print $0&#125;'</span> text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     861 Apr 17 18:18 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>也可以使用 <code>if</code> 条件语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v hour=18 <span class="string">'&#123; if ($8 ~ hour"$") &#123;print $0&#125; &#125;'</span> text</span><br></pre></td></tr></table></figure><p>很明显，命令行中使用 <code>if</code> 条件语句显得很乱，这主要还是要引出脚本化来。</p><h2><span id="jiao-ben-zhong-chuan-can">脚本中传参</span><a href="#jiao-ben-zhong-chuan-can" class="header-anchor"></a></h2><p>我们先将单引号中的条件脚本化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch split.awk</span><br><span class="line">$ chmod +x split.awk</span><br><span class="line">$ vim split.awk</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env awk -f</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$8</span> ~ hour<span class="string">"$"</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./split.awk -v hour=18 text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     861 Apr 17 18:18 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这只是一个很简单的例子，真实的开发中，判断条件往往更加复杂的多，所以使用脚本是很明智的办法。</p><p>最后提一句，使用 <code>match()</code> 可以使脚本的可读性更好一些。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env awk -f</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (match(<span class="variable">$8</span> , hour<span class="string">"$"</span>))&#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://stackoverflow.com/questions/11534173/how-to-use-awk-variables-in-regular-expressions" target="_blank" rel="noopener">How to use awk variables in regular expressions?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;awk 使用正则表达式过滤文本时可以使用可变参数，我本认为这应该是很普遍的需求，然而网上找了一圈也没看到一个比较全面的教程，不过东拼西凑也总算是满足了需求，今天来总结下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
      <category term="awk" scheme="http://wxnacy.com/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy 解决其他连接修改数据后，查询不到的问题</title>
    <link href="http://wxnacy.com/2019/04/25/sqlalchemy-isolation-level/"/>
    <id>http://wxnacy.com/2019/04/25/sqlalchemy-isolation-level/</id>
    <published>2019-04-25T01:35:51.000Z</published>
    <updated>2019-04-25T01:35:51.950Z</updated>
    
    <content type="html"><![CDATA[<p>使用 SQLAlchemy 做数据库的读写分离，创建了主从两个 DB，结果发现使用主 DB 写入的数据，从 DB 无法实时查询，必须要重启服务才可以查到。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>做了各种尝试发现都得不到解决，突然想起以前碰见过类似的问题，但是当时通过其他方式绕了过去，果然不是不报，时候未到。这次必须得正面解决了。</p><p>经过 Google 后发现，这是事务的问题，在多个实例进行链接数据库时，如果不执行 <code>commit</code>，就得不到最新的数据。</p><p>我们可以使用 <code>session.commit()</code> 来单个解决，或者可以在创建引擎时通过调整隔离级别参数来永久解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine = create_engine(<span class="string">'db_url'</span>, isolation_level = <span class="string">'READ COMMITTED'</span>)</span><br></pre></td></tr></table></figure><p><code>isolation_level</code> 的值包含了：</p><ul><li>READ COMMITTED</li><li>READ UNCOMMITTED</li><li>REPEATABLE READ</li><li>SERIALIZABLE</li><li>AUTOCOMMIT</li></ul><p>因为我使用只读，所以 <code>READ COMMITTED</code> 就可以满足要求，如果你是读写公用的 DB，直接使用 <code>AUTOCOMMIT</code> 就无脑解决了。</p><p>如果你使用 <code>flask_sqlalchemy</code>，在 <code>app.config</code> 中加入如下参数即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLALCHEMY_COMMIT_ON_TEARDOWN = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>通过源码可以发现，当该参数设置为 <code>True</code> 时，它会自动进行 <code>commit</code> 操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.teardown_appcontext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shutdown_session</span><span class="params">(response_or_exc)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> app.config[<span class="string">'SQLALCHEMY_COMMIT_ON_TEARDOWN'</span>]:</span><br><span class="line">        <span class="keyword">if</span> response_or_exc <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.session.commit()</span><br><span class="line"></span><br><span class="line">    self.session.remove()</span><br><span class="line">    <span class="keyword">return</span> response_or_exc</span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.sqlalchemy.org/en/13/core/engines.html#engine-creation-api" target="_blank" rel="noopener">Engine Creation API</a></li><li><a href="https://docs.sqlalchemy.org/en/13/dialects/mysql.html#transaction-isolation-level" target="_blank" rel="noopener">Mysql Transaction Isolation Level</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 SQLAlchemy 做数据库的读写分离，创建了主从两个 DB，结果发现使用主 DB 写入的数据，从 DB 无法实时查询，必须要重启服务才可以查到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="sqlalchemy" scheme="http://wxnacy.com/tags/sqlalchemy/"/>
    
  </entry>
  
  <entry>
    <title>Python 如何给屏幕打印信息加上颜色</title>
    <link href="http://wxnacy.com/2019/04/24/python-print-color/"/>
    <id>http://wxnacy.com/2019/04/24/python-print-color/</id>
    <published>2019-04-24T05:31:54.000Z</published>
    <updated>2019-04-24T05:31:54.732Z</updated>
    
    <content type="html"><![CDATA[<p>以前写过 <a href="/2018/09/07/go-fmt-color/">Go 如何给屏幕打印信息加上颜色</a>，想当然的以为 Python 也一样，结果被打脸，他们的配置还是有一些区别的。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#yu-fa">语法</a></li><li><a href="#gong-ju-hua">工具化</a></li></ul><!-- tocstop --></div><h2><span id="yu-fa">语法</span><a href="#yu-fa" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'\033[显示方式;字体色;背景色m文本\033[0m'</span>)</span><br><span class="line"><span class="comment"># 三种设置都可以忽略不写，都不写则为默认输出</span></span><br></pre></td></tr></table></figure><p>配置如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字体 背景 颜色</span></span><br><span class="line"><span class="comment"># ---------------------------------------</span></span><br><span class="line"><span class="comment"># 30  40  黑色</span></span><br><span class="line"><span class="comment"># 31  41  红色</span></span><br><span class="line"><span class="comment"># 32  42  绿色</span></span><br><span class="line"><span class="comment"># 33  43  黄色</span></span><br><span class="line"><span class="comment"># 34  44  蓝色</span></span><br><span class="line"><span class="comment"># 35  45  紫红色</span></span><br><span class="line"><span class="comment"># 36  46  青蓝色</span></span><br><span class="line"><span class="comment"># 37  47  白色</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 显示方式</span></span><br><span class="line"><span class="comment"># -------------------------</span></span><br><span class="line"><span class="comment">#  0  终端默认设置</span></span><br><span class="line"><span class="comment">#  1  高亮显示</span></span><br><span class="line"><span class="comment">#  4  使用下划线</span></span><br><span class="line"><span class="comment">#  5  闪烁</span></span><br><span class="line"><span class="comment">#  7  反白显示</span></span><br><span class="line"><span class="comment">#  8  不可见</span></span><br></pre></td></tr></table></figure><p>举几个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高亮显示，字体紫红色，背景白色</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[1;35;47m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor1.png" alt="1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认显示，字体紫红色，背景白色</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[35;47m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor2.png" alt="2"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认显示，字体紫红色，背景默认</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[35m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor3.png" alt="3"></p><p>往往我们更关注字体颜色，几个字体颜色效果如下，我用的 iTerm2 的深色背景，效果会有点偏差</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/output-color.png" alt="4"></p><p>如果你想看所有组合的颜色，可以查看这篇文章 <a href="https://www.cnblogs.com/journeyonmyway/p/4317108.html" target="_blank" rel="noopener">Go语言在Linux环境下输出彩色字符</a></p><h2><span id="gong-ju-hua">工具化</span><a href="#gong-ju-hua" class="header-anchor"></a></h2><p>这个语法看起来还是很别扭的，平常使用我们可以封装起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    BLACK = <span class="number">30</span></span><br><span class="line">    RED = <span class="number">31</span></span><br><span class="line">    GREEN = <span class="number">32</span></span><br><span class="line">    YELLOW = <span class="number">33</span></span><br><span class="line">    BLUE = <span class="number">34</span></span><br><span class="line">    MAGENTA = <span class="number">35</span></span><br><span class="line">    CYAN = <span class="number">36</span></span><br><span class="line">    WHITE = <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_color</span><span class="params">(text: str, fg: Color = Color.BLACK.value)</span>:</span></span><br><span class="line">    print(<span class="string">f'\033[<span class="subst">&#123;fg&#125;</span>m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印红色文字</span></span><br><span class="line">print_color(<span class="string">'Hello World'</span>, fg = Color.RED.value)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前写过 &lt;a href=&quot;/2018/09/07/go-fmt-color/&quot;&gt;Go 如何给屏幕打印信息加上颜色&lt;/a&gt;，想当然的以为 Python 也一样，结果被打脸，他们的配置还是有一些区别的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Redis get 报错 a key holding the wrong kind of value</title>
    <link href="http://wxnacy.com/2019/04/23/redis-error-wrong-kind/"/>
    <id>http://wxnacy.com/2019/04/23/redis-error-wrong-kind/</id>
    <published>2019-04-23T07:45:17.000Z</published>
    <updated>2019-04-23T07:56:25.497Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现使用 <code>redis-cli</code> 命令来获取数据报错，如下</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p>比较费解，因为线上程序并没有报错，时间紧迫也没有多关注，今天有时间感觉搜索了下。</p><p>这个错误是因为对 <code>key</code> 的 <code>value</code> 使用了错误的操作，比如 <code>lpush</code> 的数据只能使用 <code>lrange</code> 获取数据，使用 <code>get</code> 就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush test_key 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get test_key</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; lrange test_key 0 1</span><br><span class="line">1) <span class="string">"1"</span></span><br></pre></td></tr></table></figure><p>同样的使用 <code>set</code> 报错的数据，在使用 <code>lpush</code> 就会报错。</p><p>因为是很久之前写的代码，已经忘记了是用 <code>lpush</code> 保存的数据，所以在命令行中使用 <code>get</code> 自然报错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现使用 &lt;code&gt;redis-cli&lt;/code&gt; 命令来获取数据报错，如下&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://wxnacy.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Vim 执行 Shell 命令（2）</title>
    <link href="http://wxnacy.com/2019/04/18/vim-in-shell/"/>
    <id>http://wxnacy.com/2019/04/18/vim-in-shell/</id>
    <published>2019-04-18T14:08:20.000Z</published>
    <updated>2019-04-18T14:34:35.327Z</updated>
    
    <content type="html"><![CDATA[<p>前两天我写了在 Vim 中执行 Shell 命令，传送门 <a href="/2019/04/15/vim-run-shell/">Vim 执行 Shell 命令（1）</a></p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#ctrl-z"><code>&lt;ctrl-z&gt;</code></a></li><li><a href="#shell">:shell</a></li></ul><!-- tocstop --></div><p>今天我们来说如何在 Vim 和 Shell 间切换。</p><h2><span id="lt-ctrl-z-gt"><code>&lt;ctrl-z&gt;</code></span><a href="#lt-ctrl-z-gt" class="header-anchor"></a></h2><p>使用 <code>&lt;ctrl-z&gt;</code> 可以将当前 Vim 挂起，然后回到 Shell 模式，可以执行任何命令后，再使用 <code>fg</code> 或者 <code>fg %vim</code> 返回 Vim。</p><p>如果连续挂起多个，可以使用 <code>fg %1</code> 或者 <code>fg %vim filename</code> 回到 Vim。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell5.gif" alt="1"></p><p>这种方式来回切换多少有点不方便，直接使用 command 模式要更方便一点。</p><h2><span id="shell">:shell</span><a href="#shell" class="header-anchor"></a></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">sh</span>[ell]</span><br></pre></td></tr></table></figure><p>输入该命令即可进入 Shell 环境，然后使用 <code>&lt;ctrl-d&gt;</code> 即可返回 Vim。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell6.gif" alt="2"></p><p>这个流程显得顺畅很多，另外我们可以使用映射来做到只用 <code>&lt;ctrl-d&gt;</code> 来回切换。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">noremap</span> <span class="symbol">&lt;c-d&gt;</span> :<span class="keyword">sh</span><span class="symbol">&lt;cr&gt;</span>  <span class="string">" 修改映射"</span></span><br></pre></td></tr></table></figure><p>这样虽然方便，但 <code>&lt;ctrl-d&gt;</code> 本来是向下翻半页，很挺常用的，是否要更换这个映射还有待斟酌。</p><p>因为 <code>:sh</code> 是主动进入 Shell 环境，所以它可以指定命令，比如你想使用 <code>fish</code> 则可以这样</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">shell</span>=/usr/local/bin/fish</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell7.gif" alt="3"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天我写了在 Vim 中执行 Shell 命令，传送门 &lt;a href=&quot;/2019/04/15/vim-run-shell/&quot;&gt;Vim 执行 Shell 命令（1）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Python 获取当前作用域全部参数的内置方法 locals()</title>
    <link href="http://wxnacy.com/2019/04/17/python-locals/"/>
    <id>http://wxnacy.com/2019/04/17/python-locals/</id>
    <published>2019-04-17T10:23:31.000Z</published>
    <updated>2019-04-17T13:38:29.682Z</updated>
    
    <content type="html"><![CDATA[<p>在写程序时，经常会碰见传递过多参数的情况。先看一个例子</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(id, name, age, **kw)</span>:</span></span><br><span class="line">    amount = <span class="number">1</span></span><br><span class="line">    duration = <span class="number">10</span></span><br><span class="line">    func2(id = id, name = name, age = age, amount = amount, **kw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(**kw)</span>:</span></span><br><span class="line">    print(kw)</span><br></pre></td></tr></table></figure><p>在 <code>func1()</code> 给 <code>func2()</code> 传递参数，一个一个的写真的很痛苦，写一次还好，关键是到处都有这种情况。</p><p>可不可以将想要的参数打包直接传递过去呢？</p><p>内置方法 <code>locals()</code> 就可以达到这个效果，它可以实时收集当前作用域的参数，并返回一个字典。</p><p>先在全局范围内看看有哪些参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(locals())</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python locals_demo.py</span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader object at 0x102c75860&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;, <span class="string">'__file__'</span>: <span class="string">'locals_demo.py'</span>, <span class="string">'__cached__'</span>: None&#125;</span><br></pre></td></tr></table></figure><p>可能你到没注意到一个空文件里都有这么多的内置参数。</p><p><code>locals()</code> 收集参数是实时进行的，比如我们定义一个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(locals())</span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    print(locals())</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python locals_demo.py</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader object at 0x1083d5860&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;, <span class="string">'__file__'</span>: <span class="string">'locals_demo.py'</span>, <span class="string">'__cached__'</span>: None&#125;</span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader object at 0x1083d5860&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;, <span class="string">'__file__'</span>: <span class="string">'locals_demo.py'</span>, <span class="string">'__cached__'</span>: None, <span class="string">'name'</span>: <span class="string">'wxnacy'</span>&#125;</span><br></pre></td></tr></table></figure><p>第二次打印的结果中，就多出了刚刚定义的参数 <code>name</code></p><p>在方法中使用也是如此</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(**kw)</span>:</span></span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    print(locals())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    func(url = <span class="string">'https://wxnacy.com'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python locals_demo.py</span><br><span class="line">&#123;<span class="string">'kw'</span>: &#123;<span class="string">'url'</span>: <span class="string">'https://wxnacy.com'</span>&#125;, <span class="string">'name'</span>: <span class="string">'wxnacy'</span>&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>locals()</code> 方法的值是动态变的，所以我们可以先用变量储存起来，并且记得去掉不需要的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(id, age, **kw)</span>:</span></span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    args = locals()</span><br><span class="line">    args.pop(<span class="string">'name'</span>)</span><br><span class="line">    print(args)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(id, age, **kw)</span>:</span></span><br><span class="line">    args = locals()</span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    print(args)</span><br></pre></td></tr></table></figure><p>现在再来回顾下开始的问题，这下解决方式简单了很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(id, name, age, **kw)</span>:</span></span><br><span class="line">    amount = <span class="number">1</span></span><br><span class="line">    args = locals()</span><br><span class="line">    duration = <span class="number">10</span></span><br><span class="line">    func2(**args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(**kw)</span>:</span></span><br><span class="line">    print(kw)</span><br></pre></td></tr></table></figure><p>喔噢，我爱 Python。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写程序时，经常会碰见传递过多参数的情况。先看一个例子&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用 ffmpeg 分离视频流和音频流</title>
    <link href="http://wxnacy.com/2019/04/16/ffmpeg-split-video-audio/"/>
    <id>http://wxnacy.com/2019/04/16/ffmpeg-split-video-audio/</id>
    <published>2019-04-16T14:41:36.000Z</published>
    <updated>2019-04-16T15:19:45.363Z</updated>
    
    <content type="html"><![CDATA[<p>通常情况下，我们提到“视频”会有两个要素，声音和画面。但其实严格意义上说视频中含有<strong>视频流</strong>和<strong>音频流</strong>，如果一个视频只有视频流，那么就只有画面没有声音，反之亦然。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>我有听英语电影原声的习惯，但是总是放视频很不方便，网上的资源又不是太称心如意，就想着自己动手来分离，我首先想到的是 ffmpeg。</p><p>我们先来看看视频中的这两个流</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/ffsplit1_713.png" alt="1"></p><p>执行该命令可以直接查看视频的信息，其中就有刚才的提到的<strong>视频流（Video: h264）</strong>和<strong>音频流（Audio: aac）</strong></p><p>使用参数 <code>-vcodec copy -an</code> 和 <code>-acodec copy -vn</code> 可以分离出视频流和音频流。</p><p><strong>分离视频</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 -vcodec copy -an mav.mp4</span><br></pre></td></tr></table></figure><p>等待转码成功后，观看 <code>mav.mp4</code> 发现已经没有声音了，查看发现只有一个流</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/ffsplit2_667.png" alt="2"></p><p><strong>分离音频</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 -acodec copy -vn m.m4a</span><br></pre></td></tr></table></figure><p>再次查看音频流信息</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/ffsplit3_702.png" alt="3"></p><p>网上很多博客都是直接甩一个类似这样的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 -acodec copy -vn m.mp3</span><br></pre></td></tr></table></figure><p>如果你执行的话，多半会报错，因为查看视频信息，很可能像例子中的音频流一样是 aac 格式的，什么是 aac 格式呢</p><blockquote><p>高级音频编码（英语：Advanced Audio Coding，AAC），出现于1997年，为一种基于MPEG-2的有损数字音频压缩的专利音频编码标准，由Fraunhofer IIS、杜比实验室、AT&amp;T、Sony、Nokia等公司共同开发。2000年，MPEG-4标准在原本的基础上加上了PNS（Perceptual Noise Substitution）等技术，并提供了多种扩展工具。为了区别于传统的MPEG-2 AAC又称为MPEG-4 AAC。其作为MP3的后继者而被设计出来，在相同的比特率之下，AAC相较于MP3通常可以达到更好的声音质量[2]。</p></blockquote><p>关键是下面这句</p><blockquote><p>AAC 被YouTube、iPhone、iPod、 iPad、 任天堂DSi、任天堂3DS、iTunes、DivX、PlayStation 3和多款Nokia 40系列、Sony Ericsson手机采用为默认的音频编码格式，并且被PlayStation Vita、Wii、Sony Walkman MP3系列及随后的Android、BlackBerry等移动操作系统支持。</p></blockquote><p>也就是说，现在很多视频的音频流都将是这个格式，那直接分离 <code>mp3</code> 格式的音频自然会报错。</p><p>那我就是想要 <code>mp3</code> 的音频该怎么办呢？</p><p>再来一次转码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i m.m4a m.mp3</span><br></pre></td></tr></table></figure><p>或者直接将视频转码为 <code>mp3</code> 格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 m.mp3</span><br></pre></td></tr></table></figure><ul><li><a href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E9%9F%B3%E8%A8%8A%E7%B7%A8%E7%A2%BC#%E7%9B%B8%E8%BC%83%E6%96%BCMP3%E7%9A%84%E6%94%B9%E9%80%B2" target="_blank" rel="noopener">高级音频编码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常情况下，我们提到“视频”会有两个要素，声音和画面。但其实严格意义上说视频中含有&lt;strong&gt;视频流&lt;/strong&gt;和&lt;strong&gt;音频流&lt;/strong&gt;，如果一个视频只有视频流，那么就只有画面没有声音，反之亦然。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ffmpeg" scheme="http://wxnacy.com/tags/ffmpeg/"/>
    
  </entry>
  
</feed>
