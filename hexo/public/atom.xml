<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-09-08T08:46:41.832Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信公众号被动自动回复两条消息</title>
    <link href="http://wxnacy.com/2019/09/08/weixin-two-reply/"/>
    <id>http://wxnacy.com/2019/09/08/weixin-two-reply/</id>
    <published>2019-09-08T08:46:41.000Z</published>
    <updated>2019-09-08T08:46:41.832Z</updated>
    
    <content type="html"><![CDATA[<p>这么长时间来开发微信公众号一直都是只用到了被动回复一条消息，最近有需要要自动回复两条消息，第一反应是怎么可能，查了下<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140543" target="_blank" rel="noopener">文档</a>也确实不行，但是其他公众号又有这么实现的。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>搜索了下发现以前的用法还是太死板了，被动消息是只能回复一条，但是还可以调用<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140547" target="_blank" rel="noopener">客服消息</a>来主动发送一条消息。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/wx-kf_885.png" alt="1"></p><p>了解这个思路就已经可以了，具体的实现过程就不在赘述，有点经验可以说下。</p><p>如果让客服消息当做第一条，被动回复当做第二条，这样的通过进行可能会让单次请求时间加长。</p><p>我的做法是先异步调用客服消息，然后被动回复消息，打个时间差，客服消息刚好当做第二条消息，在被动回复的消息不就后到达。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这么长时间来开发微信公众号一直都是只用到了被动回复一条消息，最近有需要要自动回复两条消息，第一反应是怎么可能，查了下&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140543&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文档&lt;/a&gt;也确实不行，但是其他公众号又有这么实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信" scheme="http://wxnacy.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用多属性来进行排序</title>
    <link href="http://wxnacy.com/2019/08/31/python-sort-multi-field/"/>
    <id>http://wxnacy.com/2019/08/31/python-sort-multi-field/</id>
    <published>2019-08-31T06:11:29.000Z</published>
    <updated>2019-08-31T06:11:29.643Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中 <code>list.sort()</code> 是列表中非常常用的排序函数，<code>key</code> 参数可以对单个属性进行排序。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>但是想要实现类似 sql 中 <code>order by id, age</code> 一样，对多个字段进行排序就不支持了。</p><p>py2 中 <code>sort()</code> 函数还有个 <code>cmp</code> 参数可以传入一个方法，可以自定义对多个属性进行排序，py3 中移除了这个字段。</p><p>py3 想要实现这个功能，需要使用 <code>functools</code> 模块中的方法，实例如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp_func</span><span class="params">(a, b)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a[<span class="string">'id'</span>] &lt; b[<span class="string">'id'</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">elif</span> a[<span class="string">'id'</span>] &gt; b[<span class="string">'id'</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a[<span class="string">'name'</span>] &lt; b[<span class="string">'name'</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">elif</span> a[<span class="string">'name'</span>] &gt; b[<span class="string">'name'</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">arr.sort(key=cmp_to_key(cmp_func))</span><br></pre></td></tr></table></figure><p>上面的例子我们实现了 <code>id</code> 正序排序，如果 <code>id</code> 相同，则按照 <code>age</code> 正序排序</p><p>为了方便可以封装成一个方法，以供列表调用，封装的方法 demo 可以参见地址</p><p><a href="https://github.com/wxnacy/study/blob/master/python/office_module/list_demo/sort_by_multi_fields.py" target="_blank" rel="noopener">https://github.com/wxnacy/study/blob/master/python/office_module/list_demo/sort_by_multi_fields.py</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中 &lt;code&gt;list.sort()&lt;/code&gt; 是列表中非常常用的排序函数，&lt;code&gt;key&lt;/code&gt; 参数可以对单个属性进行排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 Pillow 模块给图片添加文字水印</title>
    <link href="http://wxnacy.com/2019/08/29/python-pillow-text-watermark/"/>
    <id>http://wxnacy.com/2019/08/29/python-pillow-text-watermark/</id>
    <published>2019-08-29T13:32:37.000Z</published>
    <updated>2019-08-29T13:32:37.143Z</updated>
    
    <content type="html"><![CDATA[<p>像微博一类的平台上传图片时，平台都会添加一个水印，宣誓着对图片的所有权，我们自己的博客平台也可以给自己的图片添加上水印。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>还是用 <a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">Pillow</a> 模块来实现</p><p>先来看一个简单的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = Image.open(<span class="string">'/Users/wxnacy/Downloads/vm-error1.png'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>draw = ImageDraw.Draw(image)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>draw.text((<span class="number">10</span>, <span class="number">10</span>), <span class="string">'wxnacy'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.show()</span><br></pre></td></tr></table></figure><p>随后图片的左上角就可以看到水印的添加效果</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pillow-watermark1.png" alt="1"></p><p>水印的颜色默认为白色，当然可以通过传参改变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>draw.text((<span class="number">10</span>, <span class="number">10</span>), <span class="string">'wxnacy'</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br></pre></td></tr></table></figure><p>添加一个参数，这和上面得到的结果是一样的，这里用的是三原色，<code>(255, 255, 255)</code> 分别为红色、绿色、蓝色</p><p>最后是字体</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>font=ImageFont.truetype(<span class="string">'PingFang.ttc'</span>,<span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>draw.text((<span class="number">70</span>,<span class="number">300</span>),<span class="string">'This is wxnacy\'s website'</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>), font=font)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.show()</span><br></pre></td></tr></table></figure><p><code>PingFang.ttc</code> 必须是本地有的字体文件，<code>40</code> 是字体大小，这样最后的水印结果为</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pillow-watermark2.png" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;像微博一类的平台上传图片时，平台都会添加一个水印，宣誓着对图片的所有权，我们自己的博客平台也可以给自己的图片添加上水印。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker logs 命令</title>
    <link href="http://wxnacy.com/2019/08/22/docker-logs/"/>
    <id>http://wxnacy.com/2019/08/22/docker-logs/</id>
    <published>2019-08-22T09:40:01.000Z</published>
    <updated>2019-08-22T09:40:01.268Z</updated>
    
    <content type="html"><![CDATA[<p>之前没有留意过 <code>docker logs</code> 的正确用法，总是直接使用 <code>docker logs -f</code> 来实时跟踪日志，但是每次都要全部显示日志后再跟踪，时间一长日志变多就是灾难，看一下帮助文档，学习下正确用法。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Fetch the logs of a container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow <span class="built_in">log</span> output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br><span class="line">      --tail string    Number of lines to show from the end of the logs (default <span class="string">"all"</span>)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br></pre></td></tr></table></figure><p>想要跟 <code>tail -f</code> 命令一样从末尾10条以后开始跟踪，需要使用 <code>--tail</code> 参数，默认就是全部</p><p><strong>从末尾 10 条后开始跟踪</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f --tail 10 &lt;container-id&gt;</span><br></pre></td></tr></table></figure><p>除了行数限制，还可以根据时间戳来获取指定时间前后的是日志</p><p><strong>获取指定时间以后的日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -t --since=<span class="string">"2019-08-20T13:23:37"</span> &lt;container-id&gt;</span><br></pre></td></tr></table></figure><p><strong>获取最后 10 分钟的日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -t --since=10m &lt;container-id&gt;</span><br></pre></td></tr></table></figure><p><strong>获取指定时间范围的日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -t --since=<span class="string">"2019-08-20T13:23:37"</span> --until=<span class="string">"2019-08-21T13:23:37"</span> &lt;container-id&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前没有留意过 &lt;code&gt;docker logs&lt;/code&gt; 的正确用法，总是直接使用 &lt;code&gt;docker logs -f&lt;/code&gt; 来实时跟踪日志，但是每次都要全部显示日志后再跟踪，时间一长日志变多就是灾难，看一下帮助文档，学习下正确用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>pm2 容器使用环境变量</title>
    <link href="http://wxnacy.com/2019/08/21/pm2-env/"/>
    <id>http://wxnacy.com/2019/08/21/pm2-env/</id>
    <published>2019-08-21T01:53:12.000Z</published>
    <updated>2019-08-21T01:53:12.603Z</updated>
    
    <content type="html"><![CDATA[<p>pm2 容器管理进程时，设置环境变量非常简单</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps : [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">"myapp"</span>,</span><br><span class="line">        script: <span class="string">"./app.js"</span>,</span><br><span class="line">        watch: <span class="literal">true</span>,</span><br><span class="line">        env: &#123;</span><br><span class="line">            <span class="string">"PORT"</span>: <span class="number">3000</span>,</span><br><span class="line">            <span class="string">"NODE_ENV"</span>: <span class="string">"development"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        env_production: &#123;</span><br><span class="line">            <span class="string">"PORT"</span>: <span class="number">80</span>,</span><br><span class="line">            <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>env</code> 是 pm2 默认使用的环境变量，使用 <code>env_production</code>  需要运行时指定环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 start ecosystem.config.js --env production</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pm2 容器管理进程时，设置环境变量非常简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://wxnacy.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Python 获取当前文件的模块对象</title>
    <link href="http://wxnacy.com/2019/08/20/python-current-module/"/>
    <id>http://wxnacy.com/2019/08/20/python-current-module/</id>
    <published>2019-08-20T06:26:10.000Z</published>
    <updated>2019-08-20T06:34:54.439Z</updated>
    
    <content type="html"><![CDATA[<p>根据<a href="https://www.python.org/dev/peps/pep-3130/" target="_blank" rel="noopener">官方</a>文档可以得到这样的用法</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">mod = sys.modules[__name__]</span><br></pre></td></tr></table></figure><p>这个特性可以应用在什么场景呢？当模块中的方法有什么共同特性时，我们可以配合 <code>getattr</code> 方法来进行动态调用，而不必编写复杂的判断语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_size</span><span class="params">(size: int)</span>:</span></span><br><span class="line">    <span class="string">'''格式化大小'''</span></span><br><span class="line">    unit = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">'B'</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">'K'</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">'M'</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">'G'</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">'T'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1024</span> ** i &lt;= size &lt; <span class="number">1024</span> ** ( i + <span class="number">1</span> ):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                size = size / <span class="number">1024</span> ** i</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&#123;:0.1f&#125;&#123;&#125;'</span>.format( size, unit[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125;B'</span>.format(size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    module = sys.modules[__name__]</span><br><span class="line">    args = sys.argv[<span class="number">1</span>:]</span><br><span class="line">    func_name = args[<span class="number">0</span>]</span><br><span class="line">    func = getattr(module, func_name)</span><br><span class="line">    res = func(int(args[<span class="number">1</span>]))</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用方法</span></span><br><span class="line">    <span class="comment"># $ python utils.py format_size 1024</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据&lt;a href=&quot;https://www.python.org/dev/peps/pep-3130/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方&lt;/a&gt;文档可以得到这样的用法&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 Pillow 包实现图片叠加</title>
    <link href="http://wxnacy.com/2019/08/15/pillow-overlay/"/>
    <id>http://wxnacy.com/2019/08/15/pillow-overlay/</id>
    <published>2019-08-15T09:39:29.000Z</published>
    <updated>2019-08-15T09:55:25.261Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">Pillow</a> 包实现图片叠加非常简单</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#jian-dan-shi-yong">简单使用</a></li><li><a href="#xiang-mu-zhong-shi-yong">项目中使用</a></li></ul><!-- tocstop --></div><h2><span id="jian-dan-shi-yong">简单使用</span><a href="#jian-dan-shi-yong" class="header-anchor"></a></h2><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install Pillow</span><br></pre></td></tr></table></figure><p><strong>简单实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">big_image =Image.open(<span class="string">'big.jpg'</span>)</span><br><span class="line">small_image=Image.open(<span class="string">'small.jpg'</span>)</span><br><span class="line"><span class="comment"># small_image.thumbnail((400,400))  可以实现压缩</span></span><br><span class="line">big_image.paste(small_image,(<span class="number">157</span>, <span class="number">45</span>))</span><br><span class="line">big_image.show()</span><br></pre></td></tr></table></figure><p><strong>原图</strong></p><p><img src="https://wxnacy.com/images/rss.png" alt="1"><br><img src="https://wxnacy.com/images/mp.jpg" alt="2"></p><p><strong>叠加效果</strong></p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pillow_overlay.png" alt="3"></p><h2><span id="xiang-mu-zhong-shi-yong">项目中使用</span><a href="#xiang-mu-zhong-shi-yong" class="header-anchor"></a></h2><p>在 web 项目中往往我们不会使用本地图片，大多是对网络图片进行处理，再传到线上，所以首先需要能解析网络图片，其次处理后需要拿到图片二进制，再进行上传处理。</p><p>这套逻辑的代码在 <a href="https://github.com/wxnacy/study/blob/master/python/pillow_demo/overlay.py" target="_blank" rel="noopener">https://github.com/wxnacy/study/blob/master/python/pillow_demo/overlay.py</a></p><p>这里复制一份</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 图片叠加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_image</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">'''通过地址获取 image 对象'''</span></span><br><span class="line">    image = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> path.startswith(<span class="string">'http'</span>):</span><br><span class="line">        res = requests.get(path)</span><br><span class="line">        image = Image.open(io.BytesIO(res.content))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        image = Image.open(path)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image2bytes</span><span class="params">(image)</span>:</span></span><br><span class="line">    <span class="string">'''图片转二进制'''</span></span><br><span class="line">    img_bytes = io.BytesIO()</span><br><span class="line">    image.save(img_bytes, image.format)</span><br><span class="line">    <span class="keyword">return</span> img_bytes.getvalue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overlay</span><span class="params">(big_path, small_path, width, height, small_thumbnail=<span class="params">()</span>)</span>:</span></span><br><span class="line">    <span class="string">'''叠加'''</span></span><br><span class="line">    big_image = get_image(big_path)</span><br><span class="line">    small_image = get_image(small_path)</span><br><span class="line">    <span class="keyword">if</span> small_thumbnail:</span><br><span class="line">        small_image.thumbnail(small_thumbnail)</span><br><span class="line">    big_image.paste(small_image,(width, height))</span><br><span class="line">    big_image.show()    <span class="comment"># 显示图片</span></span><br><span class="line">    <span class="comment">#  big_image.save('/Users/wxnacy/Downloads/pillow_overlay.png')  # 保存</span></span><br><span class="line">    <span class="comment"># 或者返回图片的二进制</span></span><br><span class="line">    <span class="keyword">return</span> image2bytes(big_image)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    overlay(<span class="string">'https://wxnacy.com/images/rss.png'</span>,</span><br><span class="line">            <span class="string">'https://wxnacy.com/images/mp.jpg'</span>, <span class="number">157</span>, <span class="number">45</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/python-pillow/Pillow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pillow&lt;/a&gt; 包实现图片叠加非常简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 配置国内仓库</title>
    <link href="http://wxnacy.com/2019/08/12/docker-use-china-mirrors/"/>
    <id>http://wxnacy.com/2019/08/12/docker-use-china-mirrors/</id>
    <published>2019-08-12T13:38:08.000Z</published>
    <updated>2019-08-12T13:38:08.706Z</updated>
    
    <content type="html"><![CDATA[<p>类似这种需要下载包的一般都要配置个国内的仓库源，同时使用默认的国外仓库，真的很慢。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>以阿里云仓库为例，配置方式很简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://4qqg0972.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类似这种需要下载包的一般都要配置个国内的仓库源，同时使用默认的国外仓库，真的很慢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 开始慢查询日志</title>
    <link href="http://wxnacy.com/2019/08/01/mysql-slow-query-log/"/>
    <id>http://wxnacy.com/2019/08/01/mysql-slow-query-log/</id>
    <published>2019-08-01T09:09:32.000Z</published>
    <updated>2019-08-01T09:09:32.556Z</updated>
    
    <content type="html"><![CDATA[<p>项目长期运行过程中，Mysql 慢查询的监控是必不可少的一步日常工作，今天来说下配置过程。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#pei-zhi">配置</a></li><li><a href="#fen-xi-gong-ju">分析工具</a></li></ul><!-- tocstop --></div><h2><span id="pei-zhi">配置</span><a href="#pei-zhi" class="header-anchor"></a></h2><p>先来查看默认慢查询日志开启状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%slow_query_log%&quot;;</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| Variable_name       | Value                                |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                  |</span><br><span class="line">| slow_query_log_file | /var/lib/mysql/1bcb14797cd4-slow.log |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><ul><li><code>slow_query_log</code> 是否开启慢查询日志，默认关闭</li><li><code>slow_query_log_file</code> 慢查询日志的默认位置，系统自动生成的文件名。自定义的日志名最好符合 <code>*-slow.log</code> 格式，后面会讲到原因。</li></ul><p>因为慢查询日志本身比较耗性能，所以默认是关闭的，在需要的时候我们需要手动打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log=1;</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br></pre></td></tr></table></figure><p>该命令可以全局开启该功能，但是如果 Mysql 服务重启则会还原默认值，想要持久化，需要修改配置文件，然后重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 开启慢查询日志</span></span><br><span class="line">slow_query_log=1</span><br><span class="line"><span class="comment"># 设置慢查询日志位置</span></span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow.log</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart mysql</span><br></pre></td></tr></table></figure><p>修改 <code>slow_query_log_file</code> 时需要注意，文件的目录位置必须已存在，否则会报错，慢查询日志功能自动关闭。</p><p>另外还一些其他的参数可以修改，方法跟上面的一样。</p><ul><li><code>long_query_time</code> 慢查询阈值，当查询时间多于设定的阈值时记录日志。默认 10 秒。</li><li><code>log_queries_not_using_indexes</code> 未使用索引的查询也被记录到慢查询日志中（可选项）。</li><li><code>log_output</code> 日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</li></ul><h2><span id="fen-xi-gong-ju">分析工具</span><a href="#fen-xi-gong-ju" class="header-anchor"></a></h2><p>Mysql 提供了慢查询日志的分析工具 mysqldumpslow，这要比自己查看日志文件要方便的多。</p><p>下面是几个常用的参数</p><ul><li><code>-s</code> 是表示按照何种方式排序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c: 访问计数</span><br><span class="line">l: 锁定时间</span><br><span class="line">r: 返回记录</span><br><span class="line">t: 查询时间</span><br><span class="line">al:平均锁定时间</span><br><span class="line">ar:平均返回记录数</span><br><span class="line">at:平均查询时间</span><br></pre></td></tr></table></figure><ul><li><code>-t</code> 是top n的意思，即为返回前面多少条的数据</li><li><code>-g</code> 后边可以写一个正则匹配模式，大小写不敏感的</li></ul><p>更多的参数可以查看帮助文档 <code>mysqldumpslow --help</code></p><p>举个例子，查看记录最多的 10 个 sql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldumpslow -s r -t 10</span><br><span class="line">Can<span class="string">'t find '</span>/var/lib/mysql/*-slow.log<span class="string">'</span></span><br></pre></td></tr></table></figure><p>如果我们自定义了日志文件，并且格式比较随意，那默认会报找不到文件的错误。</p><p>如果你的日志文件已经自定义为其它格式，那也可以通过传入文件名的方式分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldumpslow -s r -t 10 /var/lib/mysql/some-name.log</span><br></pre></td></tr></table></figure><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html" target="_blank" rel="noopener">The Slow Query Log</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldumpslow.html" target="_blank" rel="noopener">mysqldumpslow — Summarize Slow Query Log Files</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目长期运行过程中，Mysql 慢查询的监控是必不可少的一步日常工作，今天来说下配置过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://wxnacy.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Ansible 在 Vagrant 中使用</title>
    <link href="http://wxnacy.com/2019/07/31/ansible-vagrant-host/"/>
    <id>http://wxnacy.com/2019/07/31/ansible-vagrant-host/</id>
    <published>2019-07-31T09:38:41.000Z</published>
    <updated>2019-07-31T09:38:41.202Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible 在 Vagrant 中使用的难点在于获取 ssh 登录需要的配置信息。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>在默认 <code>Vagrantfile</code> 中我们找不到这些信息，此时需要通过 <code>vagrant ssh-config</code> 命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh-config</span><br><span class="line">Host default</span><br><span class="line">  HostName 127.0.0.1</span><br><span class="line">  User vagrant</span><br><span class="line">  Port 2222</span><br><span class="line">  UserKnownHostsFile /dev/null</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  PasswordAuthentication no</span><br><span class="line">  IdentityFile /Users/wxnacy/.vagrant.d/boxes/wxnacy-VAGRANTSLASH-ubuntu1804/0/virtualbox/vagrant_private_key</span><br><span class="line">  IdentitiesOnly yes</span><br><span class="line">  LogLevel FATAL</span><br></pre></td></tr></table></figure><p>啊，让我费解的 <code>IdentityFile</code> 文件终于露出来，关键就是这个文件。</p><p>接下来我们只需要配置 Ansible 的 hosts 文件，<code>/etc/ansible/hosts</code> 中添加，或者创建独立的 <code>hosts</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vagrant]</span><br><span class="line">127.0.0.1 ansible_ssh_user=vagrant ansible_ssh_port=2222 ansible_ssh_private_key_file=/Users/wxnacy/.vagrant.d/boxes/wxnacy-VAGRANTSLASH-ubuntu1804/0/virtualbox/vagrant_private_key</span><br></pre></td></tr></table></figure><p>最后查看是否能正常连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ansible all -m <span class="built_in">command</span> -a <span class="string">'who'</span> --inventory-file=hosts</span><br><span class="line">127.0.0.1 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">vagrant  pts/0        Jul 30 07:35 (10.0.2.2)</span><br><span class="line">vagrant  pts/1        Jul 30 06:19 (10.0.2.2)</span><br></pre></td></tr></table></figure><p>如果新建其他位置的 <code>hosts</code> 文件，需要 <code>--inventory-file, -i</code> 指定文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ansible 在 Vagrant 中使用的难点在于获取 ssh 登录需要的配置信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vagrant" scheme="http://wxnacy.com/tags/vagrant/"/>
    
      <category term="ansible" scheme="http://wxnacy.com/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Python 报错 f-string expression part cannot include a backslash</title>
    <link href="http://wxnacy.com/2019/07/30/python-f-string-error1/"/>
    <id>http://wxnacy.com/2019/07/30/python-f-string-error1/</id>
    <published>2019-07-30T07:02:15.000Z</published>
    <updated>2019-07-30T07:02:15.722Z</updated>
    
    <content type="html"><![CDATA[<p>Python 3.6 版本新增加的 <code>f-string</code> 语句非常简洁，其中可以直接在字符串中使用表达式，可以让代码写起来非常方便。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>不过也要了解它的一些特性，不然就可能会报一个错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f'say <span class="subst">&#123;<span class="string">"\t"</span> * n&#125;</span>'</span></span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span></span><br><span class="line">SyntaxError: f-string expression part cannot include a backslash</span><br></pre></td></tr></table></figure><p>好像也没有用错，确实应该这样写的，错误翻译过来是 <code>f-string</code> 的表达式中不能出现反斜杠。</p><p>那记住这一点，以后写起来注意下就好了，有两个方法解决。</p><p><strong>外部计算</strong></p><p>将表达式挪到外部计算好后在传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tables = <span class="string">"\t"</span> * n</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f'say <span class="subst">&#123;tables&#125;</span>'</span></span><br><span class="line"><span class="string">'say \t\t'</span></span><br></pre></td></tr></table></figure><p><strong>使用 format </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'say &#123;&#125;'</span>.format(<span class="string">'\t'</span> * n)</span><br><span class="line"><span class="string">'say \t\t'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 3.6 版本新增加的 &lt;code&gt;f-string&lt;/code&gt; 语句非常简洁，其中可以直接在字符串中使用表达式，可以让代码写起来非常方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 容器的一些操作</title>
    <link href="http://wxnacy.com/2019/07/27/docker-container-cmd/"/>
    <id>http://wxnacy.com/2019/07/27/docker-container-cmd/</id>
    <published>2019-07-27T13:22:38.000Z</published>
    <updated>2019-07-27T13:22:38.096Z</updated>
    
    <content type="html"><![CDATA[<p>整理自<a href="https://yeasy.gitbooks.io/docker_practice/container/" target="_blank" rel="noopener">操作 Docker 容器</a>，为了方便查看简化整理为一篇。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#qi-dong-rong-qi">启动容器</a></li><li><a href="#jin-ru-rong-qi">进入容器</a></li><li><a href="#dao-chu-he-dao-ru">导出和导入</a></li><li><a href="#ting-zhi-rong-qi">停止容器</a></li><li><a href="#shan-chu">删除</a></li></ul><!-- tocstop --></div><h2><span id="qi-dong-rong-qi">启动容器</span><a href="#qi-dong-rong-qi" class="header-anchor"></a></h2><p><strong>新建并启动</strong></p><p>启动容器并执行命令后，如果命令进程退出，该容器也会立马终止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:bionic <span class="built_in">echo</span> <span class="string">'hello world'</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>在全部容器列表中可以查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">7c4a4cea19aa        ubuntu:bionic       <span class="string">"echo 'hello world'"</span>   3 minutes ago       Exited (0) 7 seconds ago                       elegant_brahmagupta</span><br></pre></td></tr></table></figure><p>使用 <code>-it</code> 参数可以进入交互模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu:bionic /bin/bash</span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># ls</span></span><br><span class="line">bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  etc  lib   media  opt  root  sbin  sys  usr</span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。</p><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p><strong>启动已终止容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>以刚才的交互模式容器为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a                    <span class="comment"># 1</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED              STATUS                          PORTS               NAMES</span><br><span class="line">7c4a4cea19aa        ubuntu:bionic       <span class="string">"echo 'hello world'"</span>   About a minute ago   Exited (0) About a minute ago                       elegant_brahmagupta</span><br><span class="line">82a4d9031d1c        ubuntu:bionic       <span class="string">"/bin/bash"</span>            2 minutes ago        Exited (0) About a minute ago                       tender_jennings</span><br><span class="line"></span><br><span class="line">$ docker container start 82a4d9031d1c       <span class="comment"># 2</span></span><br><span class="line">82a4d9031d1c</span><br><span class="line"></span><br><span class="line">$ docker container ls                       <span class="comment"># 3</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">82a4d9031d1c        ubuntu:bionic       <span class="string">"/bin/bash"</span>            3 minutes ago       Up 7 seconds                                        tender_jennings</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 82a4d9031d1c /bin/bash    <span class="comment"># 4</span></span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># ps                     # 5</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">   25 pts/1    00:00:00 bash</span><br><span class="line">   34 pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure><ul><li><code>1</code> 查看所有转态的容器</li><li><code>2</code> 启动执行 <code>/bin/bash</code> 命令的容器</li><li><code>3</code> 查看当前运行的容器</li><li><code>4</code> 启动容器的交互模式</li><li><code>5</code> 查看容器中的进程</li></ul><p>通过最后一步可以得知，容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p><strong>后台守护运行</strong></p><p>使用 <code>-d</code> 参数即可将容器在后台运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs -f &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>即可实时查看最新日志</p><h2><span id="jin-ru-rong-qi">进入容器</span><a href="#jin-ru-rong-qi" class="header-anchor"></a></h2><p>前面我们试过使用 <code>run</code> 命令配合 <code>-it</code> 参数来进入交互模式，进入容器的交互模式也是类似，不过这里需要 <code>exec</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it ubuntu:bionic /bin/bash</span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>使用完毕，使用 <code>exit</code> 退出即可，容器的运行状态不会影响。</p><p>还有一个命令也可以进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>但是该模式下使用 <code>exit</code> 退出时，容器也会跟着停止，所以并不实用，了解即可。</p><h2><span id="dao-chu-he-dao-ru">导出和导入</span><a href="#dao-chu-he-dao-ru" class="header-anchor"></a></h2><p><strong>导出</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">82a4d9031d1c        ubuntu:bionic       <span class="string">"/bin/bash"</span>            3 minutes ago       Up 7 seconds                                        tender_jennings</span><br><span class="line">$ docker <span class="built_in">export</span> 82a4d9031d1c &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>将容器快照导出到本地</p><p><strong>导入容器镜像</strong></p><p>使用本地文件导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | docker import demo/ubuntu:v1.0</span><br></pre></td></tr></table></figure><p>使用网络地址导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz demo/ubuntu:v1.0</span><br></pre></td></tr></table></figure><p>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h2><span id="ting-zhi-rong-qi">停止容器</span><a href="#ting-zhi-rong-qi" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop &lt;id|name&gt;       <span class="comment"># 停止容器</span></span><br><span class="line">$ docker container start &lt;id|name&gt;      <span class="comment"># 启动容器</span></span><br><span class="line">$ docker container restart &lt;id|name&gt;    <span class="comment"># 重启容器</span></span><br></pre></td></tr></table></figure><h2><span id="shan-chu">删除</span><a href="#shan-chu" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭已经停止的容器</span></span><br><span class="line">$ docker container rm &lt;id:name&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</span></span><br><span class="line">$ docker container rm -f &lt;id:name&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭全部终止状态的容器</span></span><br><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理自&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/container/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;操作 Docker 容器&lt;/a&gt;，为了方便查看简化整理为一篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 改变镜像下载目录</title>
    <link href="http://wxnacy.com/2019/07/26/docker-change-store-dir/"/>
    <id>http://wxnacy.com/2019/07/26/docker-change-store-dir/</id>
    <published>2019-07-26T07:16:22.000Z</published>
    <updated>2019-07-26T07:16:22.830Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 占用储存空间很大的部分在于下载的镜像，因为 Docker 包括容器、镜像等存储数据都默认保存在 <code>/var/lib/docker</code> 目录下，如果系统磁盘空间比较小的话就会很麻烦，我想将目录改为挂载的扩充磁盘上。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>先停止 Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br></pre></td></tr></table></figure><p>确认没有 Docker 进程在跑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps faux | grep docker</span><br></pre></td></tr></table></figure><p>假设新的目录为 <code>/data/docker</code>，先将数据复制到新的目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp -r /var/lib/docker /data/docker</span><br></pre></td></tr></table></figure><p>然后将该目录软连接到 <code>/var/lib/docker</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -sf /data/docker /var/lib/docker</span><br></pre></td></tr></table></figure><p>启动 Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>最后查看镜像列表是否正常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker image ls</span><br></pre></td></tr></table></figure><p>这样软连接的方式是比较灵活的，不会改变我们熟知的存储目录。官方论坛中也有修改配置文件来全局修改存储位置的方法，感兴趣的同学可以点击下方链接进入。</p><ul><li><a href="https://forums.docker.com/t/how-do-i-change-the-docker-image-installation-directory/1169/1" target="_blank" rel="noopener">How do I change the Docker image installation directory?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 占用储存空间很大的部分在于下载的镜像，因为 Docker 包括容器、镜像等存储数据都默认保存在 &lt;code&gt;/var/lib/docker&lt;/code&gt; 目录下，如果系统磁盘空间比较小的话就会很麻烦，我想将目录改为挂载的扩充磁盘上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 报错 Please provide a source image with `from` prior to commit</title>
    <link href="http://wxnacy.com/2019/07/22/docker-before-from-use-args/"/>
    <id>http://wxnacy.com/2019/07/22/docker-before-from-use-args/</id>
    <published>2019-07-22T01:38:03.000Z</published>
    <updated>2019-07-22T01:38:03.405Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 openresty 的 <a href="https://hub.docker.com/r/openresty/openresty/" target="_blank" rel="noopener">docker</a> 版本时，需要重构镜像，本地测试通过，但服务器上报错。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please provide a <span class="built_in">source</span> image with `from` prior to commit</span><br></pre></td></tr></table></figure><p>Google 后发现问题出在这里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG RESTY_IMAGE_BASE=<span class="string">"ubuntu"</span></span><br><span class="line">ARG RESTY_IMAGE_TAG=<span class="string">"bionic"</span></span><br><span class="line"></span><br><span class="line">FROM <span class="variable">$&#123;RESTY_IMAGE_BASE&#125;</span>:<span class="variable">$&#123;RESTY_IMAGE_TAG&#125;</span></span><br></pre></td></tr></table></figure><p>在老版本中是不支持 <code>FROM</code> 前使用 <code>ARG</code> 的，这个问题在 <a href="https://github.com/moby/moby/pull/31352" target="_blank" rel="noopener">docker 17.05.0-ce</a> 版本中得到了修改，而服务器上的版本比较老，所以才报错，只要升级版本即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 openresty 的 &lt;a href=&quot;https://hub.docker.com/r/openresty/openresty/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;docker&lt;/a&gt; 版本时，需要重构镜像，本地测试通过，但服务器上报错。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant 使用 root 账号登录</title>
    <link href="http://wxnacy.com/2019/07/18/vagrant-root-login/"/>
    <id>http://wxnacy.com/2019/07/18/vagrant-root-login/</id>
    <published>2019-07-18T09:42:57.000Z</published>
    <updated>2019-07-18T09:42:57.127Z</updated>
    
    <content type="html"><![CDATA[<p>Vagrant 想要使用 root 身份登录要稍微麻烦一点。网上的文章大多是从一个地方抄过来的，并且还没抄对，所以我在这里总结一篇正确做法。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#xiu-gai-sshd-pei-zhi">修改 sshd 配置</a></li><li><a href="#xiu-gai-vagrantfile">修改 Vagrantfile</a></li><li><a href="#shi-yong-gong-si-yao-deng-lu">使用公私钥登录</a></li></ul><!-- tocstop --></div><h2><span id="xiu-gai-sshd-pei-zhi">修改 sshd 配置</span><a href="#xiu-gai-sshd-pei-zhi" class="header-anchor"></a></h2><p>首先以默认身份登录，并修改 <code>sshd</code> 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh</span><br><span class="line">$ sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>做如下变动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PermitRootLogin prohibit-password</span></span><br><span class="line">PermitRootLogin yes             <span class="comment"># 允许 root 身份登录</span></span><br><span class="line"><span class="comment"># PasswordAuthentication on</span></span><br><span class="line">PasswordAuthentication yes      <span class="comment"># 可以使用密码登录</span></span><br></pre></td></tr></table></figure><p>重启 <code>sshd</code> 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><h2><span id="xiu-gai-vagrantfile">修改 Vagrantfile</span><a href="#xiu-gai-vagrantfile" class="header-anchor"></a></h2><p>增加如下配置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.ssh.username = <span class="string">'root'</span></span><br><span class="line">config.ssh.password = <span class="string">'root'</span></span><br><span class="line">config.ssh.insert_key = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>然后再次登录即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh</span><br></pre></td></tr></table></figure><p>这里注意，网上大部分给出的例子是设置 <code>config.ssh.insert_key = true</code>，如果你这样设置了，会发现 <code>config.ssh.password</code> 将会失效，每次登录都需要手动输入密码。</p><p>为什么呢？根据<a href="https://www.vagrantup.com/docs/vagrantfile/ssh_settings.html#config-ssh-insert_key" target="_blank" rel="noopener">官网</a>的定义，<code>config.ssh.insert_key</code> 代表了是否使用公私钥来登录虚拟机，如果你想要使用不那么安全的登录方式，比如密码登录，则可以将它设置为 <code>false</code>，它的默认值为 <code>true</code></p><p>了解了这一点，就可以发现手动设置 <code>config.ssh.insert_key=true</code> 是有点蠢的做法。</p><h2><span id="shi-yong-gong-si-yao-deng-lu">使用公私钥登录</span><a href="#shi-yong-gong-si-yao-deng-lu" class="header-anchor"></a></h2><p>使用密码登录的缺点很明显，明文的密码就像只穿一个裤衩就出门一样让人不安，默认的 <code>vagrant</code> 就不需要密码，那它是怎么登录的呢？</p><p>关于怎么使用公私钥登录服务器可以查看这篇文章 <a href="/2017/08/23/linux-2017-08-23-ssh/">Linux SSH 登陆远程服务器和无密码操作</a></p><p>有了这篇文章作为基础，我们来查看下 <code>vagrant</code> 账号是否做了秘钥登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /home/vagrant/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>执行这条命令后会发现文件中包含一条记录，证明了确实使用了秘钥登录。</p><p>下面我们为 <code>root</code> 用户赋予秘钥登录的功能</p><p>首先将电脑的公钥内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>复制到虚拟机中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'公钥内容'</span> &gt;&gt; /home/vagrant/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后修改 <code>Vagrantfile</code> 配置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config.ssh.username = <span class="string">'root'</span>                                <span class="comment"># 使用 root 身份登录</span></span><br><span class="line">config.ssh.private_key_path = <span class="string">'/Users/wxnacy/.ssh/id_rsa'</span>   <span class="comment"># 私钥位置</span></span><br></pre></td></tr></table></figure><p>接下来在登录会发现如 <code>vagrant</code> 账号般顺滑</p><ul><li><a href="https://www.vagrantup.com/docs/vagrantfile/ssh_settings.html#config-ssh-private_key_path" target="_blank" rel="noopener">SSH Settings</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vagrant 想要使用 root 身份登录要稍微麻烦一点。网上的文章大多是从一个地方抄过来的，并且还没抄对，所以我在这里总结一篇正确做法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vagrant" scheme="http://wxnacy.com/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 Requests 模块进行身份验证</title>
    <link href="http://wxnacy.com/2019/07/17/requests-auth/"/>
    <id>http://wxnacy.com/2019/07/17/requests-auth/</id>
    <published>2019-07-17T02:46:27.000Z</published>
    <updated>2019-07-17T02:46:27.152Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">Requests</a> 可以说是 Python 最好用的 http 模块，没有之一。</p><a id="more"></a><p>它对于身份验证有非常方便的使用规则。</p><p><strong>基本身份验证</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'https://api.github.com/user'</span>, auth=HTTPBasicAuth(<span class="string">'user'</span>, <span class="string">'pass'</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p>因为这种验证非常常用，所以也提供了方便的写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'https://api.github.com/user'</span>, auth=(<span class="string">'user'</span>, <span class="string">'pass'</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p><strong>摘要式身份认证</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPDigestAuth</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/digest-auth/auth/user/pass'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(url, auth=HTTPDigestAuth(<span class="string">'user'</span>, <span class="string">'pass'</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p><strong>OAuth 1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> requests_oauthlib <span class="keyword">import</span> OAuth1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.twitter.com/1.1/account/verify_credentials.json'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>auth = OAuth1(<span class="string">'YOUR_APP_KEY'</span>, <span class="string">'YOUR_APP_SECRET'</span>,</span><br><span class="line"><span class="meta">... </span>              <span class="string">'USER_OAUTH_TOKEN'</span>, <span class="string">'USER_OAUTH_TOKEN_SECRET'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(url, auth=auth)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p>更多复杂验证如 OAuth 2，请参看<a href="http://docs.python-requests.org/zh_CN/latest/user/authentication.html?highlight=requests.auth#oauth-2-openid" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/kennethreitz/requests&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Requests&lt;/a&gt; 可以说是 Python 最好用的 http 模块，没有之一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 报错 no resolver defined to resolve</title>
    <link href="http://wxnacy.com/2019/07/16/nginx-no-resolver-defined-to-resolve/"/>
    <id>http://wxnacy.com/2019/07/16/nginx-no-resolver-defined-to-resolve/</id>
    <published>2019-07-16T06:49:25.000Z</published>
    <updated>2019-07-16T06:49:25.476Z</updated>
    
    <content type="html"><![CDATA[<p>起因是使用 <code>ngxin + lua</code> 链接外部机器 Redis 时产生的</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>原因是 Nginx 0.6.18以后的版本中启用了一个resolver指令，在使用变量来构造某个server地址的时候一定要用resolver指令来指定DNS服务器的地址，所以解决这个问题的方法很简单：在nginx的配置文件中的http{}部分添加一行DNS地址即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果机器支持 ipv6，可以去掉对它的支持，免得产生类似错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8 ipv6=off;</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-resty-redis/issues/159" target="_blank" rel="noopener">No resolver defined to resolve</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起因是使用 &lt;code&gt;ngxin + lua&lt;/code&gt; 链接外部机器 Redis 时产生的&lt;/p&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://wxnacy.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Python 对 JSON 中的特殊类型进行 Encoder</title>
    <link href="http://wxnacy.com/2019/07/13/python-json-encoder-decoder/"/>
    <id>http://wxnacy.com/2019/07/13/python-json-encoder-decoder/</id>
    <published>2019-07-13T01:56:59.000Z</published>
    <updated>2019-07-13T02:04:21.229Z</updated>
    
    <content type="html"><![CDATA[<p>Python 处理 JSON 数据时，<code>dumps</code> 函数是经常用到的，当 JSON 数据中有特殊类型时，往往是比较头疼的，因为经常会报这样一个错误。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#zi-ding-yi-bian-ma-lei">自定义编码类</a></li><li><a href="#dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang">单分派装饰器处理对象</a></li></ul><!-- tocstop --></div><h2><span id="zi-ding-yi-bian-ma-lei">自定义编码类</span><a href="#zi-ding-yi-bian-ma-lei" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">USER_DATA = dict(</span><br><span class="line">    id = <span class="number">1</span>, name = <span class="string">'wxnacy'</span>, ts = datetime.now()</span><br><span class="line">)</span><br><span class="line">print(json.dumps(USER_DATA))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/wxnacy/PycharmProjects/study/python/office_module/json_demo/dumps.py"</span>, line 74, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dumps_encoder()</span><br><span class="line">  File <span class="string">"/Users/wxnacy/PycharmProjects/study/python/office_module/json_demo/dumps.py"</span>, line 68, <span class="keyword">in</span> dumps_encoder</span><br><span class="line">    <span class="built_in">print</span>(json.dumps(USER_DATA))</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/__init__.py"</span>, line 231, <span class="keyword">in</span> dumps</span><br><span class="line">    <span class="built_in">return</span> _default_encoder.encode(obj)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 199, <span class="keyword">in</span> encode</span><br><span class="line">    chunks = self.iterencode(o, _one_shot=True)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 257, <span class="keyword">in</span> iterencode</span><br><span class="line">    <span class="built_in">return</span> _iterencode(o, 0)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 180, <span class="keyword">in</span> default</span><br><span class="line">    o.__class__.__name__)</span><br><span class="line">TypeError: Object of <span class="built_in">type</span> <span class="string">'datetime'</span> is not JSON serializable</span><br></pre></td></tr></table></figure><p>原因在于 <code>dumps</code> 函数不知道如何处理 <code>datetime</code> 对象，默认情况下 <code>json</code> 模块使用 <code>json.JSONEncoder</code> 类来进行编码，此时我们需要自定义一下编码类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(x, datetime):</span><br><span class="line">            <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line">        <span class="keyword">return</span> super().default(self, x)</span><br></pre></td></tr></table></figure><p>定义编码类 <code>CustomEncoder</code> 并重写实例的 <code>default</code> 函数，对特殊类型进行处理，其余类型继续使用父类的解析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(x, datetime):</span><br><span class="line">            <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line">        <span class="keyword">return</span> super().default(self, x)</span><br><span class="line"></span><br><span class="line">USER_DATA = dict(</span><br><span class="line">    id = <span class="number">1</span>, name = <span class="string">'wxnacy'</span>, ts = datetime.now()</span><br><span class="line">)</span><br><span class="line">print(json.dumps(USER_DATA, cls=CustomEncoder))</span><br><span class="line"><span class="comment"># &#123;"id": 1, "name": "wxnacy", "ts": 1562938926&#125;</span></span><br></pre></td></tr></table></figure><p>最后整合起来，将类使用 <code>cls</code> 参数传入 <code>dumps</code> 函数即可。</p><p>使用 <code>CustomEncoder</code> 实例的 <code>encode</code> 函数可以对对象进行转码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line">print(CustomEncoder().encode(datetime.now()))</span><br><span class="line"><span class="comment"># 1562939035</span></span><br></pre></td></tr></table></figure><p>在父类源码中，所有的编码逻辑都在 <code>encode</code> 函数中，<code>default</code> 只负责抛出 <code>TypeError</code> 异常，这就是文章开始报错的出处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, o)</span>:</span></span><br><span class="line">    <span class="string">"""Implement this method in a subclass such that it returns</span></span><br><span class="line"><span class="string">    a serializable object for ``o``, or calls the base implementation</span></span><br><span class="line"><span class="string">    (to raise a ``TypeError``).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For example, to support arbitrary iterators, you could</span></span><br><span class="line"><span class="string">    implement default like this::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        def default(self, o):</span></span><br><span class="line"><span class="string">            try:</span></span><br><span class="line"><span class="string">                iterable = iter(o)</span></span><br><span class="line"><span class="string">            except TypeError:</span></span><br><span class="line"><span class="string">                pass</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                return list(iterable)</span></span><br><span class="line"><span class="string">            # Let the base class default method raise the TypeError</span></span><br><span class="line"><span class="string">            return JSONEncoder.default(self, o)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">f'Object of type <span class="subst">&#123;o.__class__.__name__&#125;</span> '</span></span><br><span class="line">                    <span class="string">f'is not JSON serializable'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self, o)</span>:</span></span><br><span class="line">    <span class="string">"""Return a JSON string representation of a Python data structure.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from json.encoder import JSONEncoder</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; JSONEncoder().encode(&#123;"foo": ["bar", "baz"]&#125;)</span></span><br><span class="line"><span class="string">    '&#123;"foo": ["bar", "baz"]&#125;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># This is for extremely simple cases and benchmarks.</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(o, str):</span><br><span class="line">        <span class="keyword">if</span> self.ensure_ascii:</span><br><span class="line">            <span class="keyword">return</span> encode_basestring_ascii(o)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> encode_basestring(o)</span><br><span class="line">    <span class="comment"># This doesn't pass the iterator directly to ''.join() because the</span></span><br><span class="line">    <span class="comment"># exceptions aren't as detailed.  The list call should be roughly</span></span><br><span class="line">    <span class="comment"># equivalent to the PySequence_Fast that ''.join() would do.</span></span><br><span class="line">    chunks = self.iterencode(o, _one_shot=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(chunks, (list, tuple)):</span><br><span class="line">        chunks = list(chunks)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(chunks)</span><br></pre></td></tr></table></figure><h2><span id="dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang">单分派装饰器处理对象</span><a href="#dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang" class="header-anchor"></a></h2><p><code>CustomEncoder</code> 如果处理的对象种类很多的话，需要写多个 <code>if elif else</code> 来区分，这样并不是不行，但是不够优雅，不够 pythonic</p><p>根据对象的类型不同，而做出不同的处理。刚好有个装饰器可以做到这点，它就是单分派函数 <code>functools.singledispatch</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> encode(x)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> super().default(self, x)</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch             # 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">'Unencode type'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@encode.register(datetime)  # 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line"></span><br><span class="line"><span class="meta">@encode.register(date)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x.isoformat()</span><br><span class="line"></span><br><span class="line">print(json.dumps(dict(dt = datetime.now(), d = date.today()), cls=CustomEncoder))</span><br><span class="line"><span class="comment"># &#123;"dt": 1562940781, "d": "2019-07-12"&#125;</span></span><br></pre></td></tr></table></figure><ul><li>1 使用 <code>@singledispatch</code> 装饰 <code>encode</code> 函数，是他处理默认类型。同时给他添加一个装饰器构造函数变量。</li><li>2 <a href="mailto:`@encode.register" target="_blank" rel="noopener">`@encode.register</a>()` 是一个装饰器构造函数，接收需要处理的对象类型作为参数。用它装饰的函数不需要名字，<em>_</em> 代替即可。</li></ul><p>最后提一点，<code>json</code> 也可以在命令行中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'&#123;"json": "obj"&#125;'</span> | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"json"</span>: <span class="string">"obj"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">json</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 处理 JSON 数据时，&lt;code&gt;dumps&lt;/code&gt; 函数是经常用到的，当 JSON 数据中有特殊类型时，往往是比较头疼的，因为经常会报这样一个错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 如何安装 Redis</title>
    <link href="http://wxnacy.com/2019/07/12/centos7-install-redis/"/>
    <id>http://wxnacy.com/2019/07/12/centos7-install-redis/</id>
    <published>2019-07-12T09:02:08.000Z</published>
    <updated>2019-07-12T09:06:01.078Z</updated>
    
    <content type="html"><![CDATA[<p>Centos 默认仓库不包含 Redis 安装包，我们可以从 Remi 仓库中来安装。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p><strong>安装 Remi 仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install epel-release yum-utils</span><br><span class="line">$ sudo yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm</span><br><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> remi</span><br></pre></td></tr></table></figure><p><strong>安装 Redis</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y redis</span><br></pre></td></tr></table></figure><p><strong>启动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start redis    <span class="comment"># 启动</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> redis   <span class="comment"># 开机自启</span></span><br></pre></td></tr></table></figure><p><strong>测试是否安装成功</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><ul><li><a href="https://linuxize.com/post/how-to-install-and-configure-redis-on-centos-7/" target="_blank" rel="noopener">How To Install and Configure Redis on CentOS 7</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Centos 默认仓库不包含 Redis 安装包，我们可以从 Remi 仓库中来安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>apt 下载报错 [Could not get lock /var/lib/dpkg/lock-frontend]</title>
    <link href="http://wxnacy.com/2019/07/11/apt-install-error/"/>
    <id>http://wxnacy.com/2019/07/11/apt-install-error/</id>
    <published>2019-07-11T13:15:29.000Z</published>
    <updated>2019-07-11T13:35:24.193Z</updated>
    
    <content type="html"><![CDATA[<p>有两种情况会导致软件安装工具报这种错</p><ul><li><code>Synaptic Package Manager</code> 或 <code>Software Updater</code> 是打开的。</li><li>一些apt命令在终端中运行或者在后台有进程正在运行。</li></ul><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y redis</span><br><span class="line">E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)</span><br><span class="line">E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?</span><br></pre></td></tr></table></figure><p><strong>查看进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep apt</span><br><span class="line">root 1747 0.0 0.0 4628 808 ? Ss 07:06 0:00 /bin/sh /usr/lib/apt/apt.systemd.daily update</span><br><span class="line">root 1769 0.0 0.0 4628 1820 ? S 07:06 0:00 /bin/sh /usr/lib/apt/apt.systemd.daily lock_is_held update</span><br><span class="line">_apt 16225 3.0 0.2 80192 8796 ? S 07:07 0:04 /usr/lib/apt/methods/http</span><br><span class="line">_apt 16226 0.7 0.2 80188 8800 ? S 07:07 0:01 /usr/lib/apt/methods/http</span><br></pre></td></tr></table></figure><p><strong>停掉进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo killall apt apt-get</span><br></pre></td></tr></table></figure><p>这是比较快捷的方式，但是还不够，前两条都无法关闭，只能将 pid 杀死</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">kill</span> -9 &lt;pid&gt;</span><br></pre></td></tr></table></figure><p><strong>删除加锁文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /var/lib/apt/lists/lock</span><br><span class="line">$ sudo rm /var/cache/apt/archives/lock</span><br><span class="line">$ sudo rm /var/lib/dpkg/lock*</span><br></pre></td></tr></table></figure><p><strong>重新配置 dpkg</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg --configure -a</span><br><span class="line">dpkg: error: parsing file <span class="string">'/var/lib/dpkg/updates/0004'</span> near line 0:</span><br><span class="line">newline <span class="keyword">in</span> field name <span class="string">'#padding'</span></span><br></pre></td></tr></table></figure><p>这时候有可能还会出现一个错误，这时要手动删除该文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/dpkg/updates/0004</span><br></pre></td></tr></table></figure><p>再次执行配置命令，然后继续安装软件即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update -y</span><br><span class="line">$ sudo apt install -y redis</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两种情况会导致软件安装工具报这种错&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Synaptic Package Manager&lt;/code&gt; 或 &lt;code&gt;Software Updater&lt;/code&gt; 是打开的。&lt;/li&gt;
&lt;li&gt;一些apt命令在终端中运行或者在后台有进程正在运行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
</feed>
