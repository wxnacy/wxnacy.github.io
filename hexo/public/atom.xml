<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-02-27T02:01:37.183Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux Tab 命令提示时忽略大小写</title>
    <link href="http://wxnacy.com/2019/02/27/linux-caseignore/"/>
    <id>http://wxnacy.com/2019/02/27/linux-caseignore/</id>
    <published>2019-02-27T01:56:39.000Z</published>
    <updated>2019-02-27T02:01:37.183Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 环境如何不装 <code>zsh</code> 等更加智能的 bash 工具，通常在 Tab 键提示命令时都会区分大小写，这样很不方便，我们可以做点简单修改让它忽略大小写。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>默认情况下 <code>~</code> 目录下是没有 <code>.inputrc</code> 文件的，手动创建并赋值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'set completion-ignore-case on'</span> &gt;&gt; .inputrc</span><br></pre></td></tr></table></figure><p>然后退出终端，重新进入，这时命令行已经忽略大小写了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 环境如何不装 &lt;code&gt;zsh&lt;/code&gt; 等更加智能的 bash 工具，通常在 Tab 键提示命令时都会区分大小写，这样很不方便，我们可以做点简单修改让它忽略大小写。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Vim8 内置插件管理方案</title>
    <link href="http://wxnacy.com/2019/02/26/vim8-pack/"/>
    <id>http://wxnacy.com/2019/02/26/vim8-pack/</id>
    <published>2019-02-26T09:42:43.000Z</published>
    <updated>2019-02-26T10:05:43.418Z</updated>
    
    <content type="html"><![CDATA[<p>Vim8，更新到这个版本，Vim 终于有自己的插件管理方案，引入了 <code>packages</code> 的概念。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>如果你对 <a href="/2017/09/20/vim-plugin-pathogen/">pathogen</a> 了解的话，应该会很喜欢这种方案，跟它一样，你只需要将插件扔到指定的目录下，Vim 会自动加载这个插件。</p><p>假如你有插件 <code>nerdtree</code>，现在只需要在放在 <code>~/.vim/pack/vendor/start/</code> 目录下即可。</p><p>Vim8 会自动加载 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/start/</span><br></pre></td></tr></table></figure><p>目录下的插件，换句话说我也可以把它放在 <code>~/.vim/pack/foo/start/</code> 下，<code>*</code> 所代表的目录是任意值。</p><p>而那些我们不想自动加载的插件可以放到 <code>opt</code> 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/opt</span><br></pre></td></tr></table></figure><p>随后在 <code>~/.vimrc</code> 中使用 <code>packadd</code> 来手动加载插件，有应用场景如下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> foo_compiler_version &gt; <span class="number">34</span></span><br><span class="line">    packadd foo_new</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    packadd foo_old</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>我们可以根据某个编译版本来选择使用插件的版本。</p><p>查看文档 <code>:h packages</code> 获取更多信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vim8，更新到这个版本，Vim 终于有自己的插件管理方案，引入了 &lt;code&gt;packages&lt;/code&gt; 的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Mysql insert ... on duplicate key update 的用法及在 SQLAlchemy 中的使用</title>
    <link href="http://wxnacy.com/2019/02/24/mysql-insert-on-duplicate-key-update/"/>
    <id>http://wxnacy.com/2019/02/24/mysql-insert-on-duplicate-key-update/</id>
    <published>2019-02-24T04:09:12.000Z</published>
    <updated>2019-02-24T04:53:03.357Z</updated>
    
    <content type="html"><![CDATA[<p>在项目高并发时，很容易出现数据库插入相同数据的情况，虽然可以使用唯一索引避免插入相同数据，但是不断的程序报错也是我们也避免的。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#yu-fa">语法</a></li><li><a href="#sqlalchemy-zhong-de-shi-yong">SQLAlchemy 中的使用</a></li></ul><!-- tocstop --></div><h2><span id="yu-fa">语法</span><a href="#yu-fa" class="header-anchor"></a></h2><p>使用 <code>insert ... on duplicate key update ..</code> 语法可以避免这种情况，举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists `test`;</span><br><span class="line">create table `test` (</span><br><span class="line">`id` int(11) not null AUTO_INCREMENT,</span><br><span class="line">`name` varchar(32) not null default &apos;&apos;,</span><br><span class="line">`update_ts` timestamp not null default current_timestamp(),</span><br><span class="line">primary key (`id`)</span><br><span class="line">) engine=InnoDB default charset=utf8mb4;</span><br></pre></td></tr></table></figure><p>主键 <code>id</code> 是天然的唯一索引，我们插入重复数据时会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT INTO test (id, name) VALUES (1, &apos;wxnacy&apos;);</span><br><span class="line">&gt; INSERT INTO test (id, name) VALUES (1, &apos;wxnacy&apos;);</span><br><span class="line">Error 1062: Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos;</span><br></pre></td></tr></table></figure><p>查看数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">|------------------------------------</span><br><span class="line">| 1  | wxnacy | 2019-02-24 12:26:58 |</span><br></pre></td></tr></table></figure><p>下面我们来换个语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; insert into test (id, name) values (1, &apos;wxnacy&apos;) on duplicate key update update_ts = current_timestamp();</span><br><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line"></span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">|  1 | wxnacy | 2019-02-24 12:31:49 |</span><br><span class="line">+----+--------+---------------------+</span><br></pre></td></tr></table></figure><p><code>on duplicate key update</code> 前面是正常的插入语句，其后跟着的是当唯一索引冲突时，想要更新的数据。</p><p>再换个使用场景，如果我想让数据库中用户名是唯一的，则可以先建立唯一索引，在使用该语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; alter table test add unique index_name (name);</span><br><span class="line">&gt; insert into test (name) values (&apos;wenn&apos;) on duplicate key update update_ts = current_timestamp();</span><br><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">|  1 | wxnacy | 2019-02-24 12:31:49 |</span><br><span class="line">|  2 | wenn   | 2019-02-24 12:39:25 |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line"></span><br><span class="line">&gt; insert into test (name) values (&apos;wenn&apos;) on duplicate key update update_ts = current_timestamp();</span><br><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line"></span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">|  1 | wxnacy | 2019-02-24 12:31:49 |</span><br><span class="line">|  2 | wenn   | 2019-02-24 12:40:15 |</span><br><span class="line">+----+--------+---------------------+</span><br></pre></td></tr></table></figure><p>这样及保证了避免插入重复数据，同时程序也没有报错，我还可以根据 <code>update</code> 的数据来分析问题的根源。</p><h2><span id="sqlalchemy-zhong-de-shi-yong">SQLAlchemy 中的使用</span><a href="#sqlalchemy-zhong-de-shi-yong" class="header-anchor"></a></h2><p>这个功能需要 SQLAlchemy 1.2 版本以上才支持，官方的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.dialects.mysql <span class="keyword">import</span> insert</span><br><span class="line"></span><br><span class="line">insert_stmt = insert(my_table). \</span><br><span class="line">    values(id=<span class="string">'some_id'</span>, data=<span class="string">'some data to insert'</span>)</span><br><span class="line"></span><br><span class="line">on_conflict_stmt = insert_stmt.on_duplicate_key_update(</span><br><span class="line">    data=insert_stmt.inserted.data,</span><br><span class="line">    status=<span class="string">'U'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">conn.execute(on_conflict_stmt)</span><br></pre></td></tr></table></figure><p>析出的 sql 语句为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO my_table (id, data)</span><br><span class="line">VALUES (:id, :data)</span><br><span class="line">ON DUPLICATE KEY UPDATE data=VALUES(data), status=:status_1</span><br></pre></td></tr></table></figure><p>参考资料</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html" target="_blank" rel="noopener">INSERT … ON DUPLICATE KEY UPDATE Syntax</a></li><li><a href="https://docs.sqlalchemy.org/en/latest/changelog/migration_12.html#support-for-insert-on-duplicate-key-update" target="_blank" rel="noopener">Support for INSERT..ON DUPLICATE KEY UPDATE</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目高并发时，很容易出现数据库插入相同数据的情况，虽然可以使用唯一索引避免插入相同数据，但是不断的程序报错也是我们也避免的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://wxnacy.com/tags/mysql/"/>
    
      <category term="sqlalchemy" scheme="http://wxnacy.com/tags/sqlalchemy/"/>
    
  </entry>
  
  <entry>
    <title>Vimscript 判断文件是否存在</title>
    <link href="http://wxnacy.com/2019/02/21/vimscript-file-exists/"/>
    <id>http://wxnacy.com/2019/02/21/vimscript-file-exists/</id>
    <published>2019-02-21T10:28:52.000Z</published>
    <updated>2019-02-26T13:25:50.185Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>~/.vimrc</code> 我希望可以通过判断当前环境是否含有某插件，再加载相应的参数配置，此时可以通过判断文件是否存在来完成。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">filereadable</span>(<span class="string">'test.txt'</span>)    <span class="string">" 判断文件是否存在"</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'file is exists'</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>文件路径可以加上环境变量，用 <code>.</code> 链接</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME . <span class="string">'/.vim/bundle/jedi-vim/Makefile'</span></span><br></pre></td></tr></table></figure><p>或者使用 <code>expand()</code> 函数</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">expand</span>(<span class="string">"$HOME/.vim/bundle/jedi-vim/Makefile"</span>)</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">filereadable</span>(<span class="built_in">expand</span>(<span class="string">"$HOME/.vim/bundle/jedi-vim/Makefile"</span>))    <span class="string">" 判断文件是否存在"</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'jedi-vim is exists'</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;~/.vimrc&lt;/code&gt; 我希望可以通过判断当前环境是否含有某插件，再加载相应的参数配置，此时可以通过判断文件是否存在来完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>简单理解时间复杂度</title>
    <link href="http://wxnacy.com/2019/02/20/time-complexity/"/>
    <id>http://wxnacy.com/2019/02/20/time-complexity/</id>
    <published>2019-02-20T07:01:12.000Z</published>
    <updated>2019-02-20T07:01:12.608Z</updated>
    
    <content type="html"><![CDATA[<p>时间复杂度是一个及基础又重要，但却不那么显性的概念。对于很多程序员来说仿佛只会出现在面试题里，因为不了解它好像也不影响我开发程序。</p><p>时间复杂度是算法的一个重要概念，但并不是一句重要就可以逼着别人去学习的，首先我们要提出三问。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#di-yi-wen-wei-shi-me-yao-shi-yong-shi-jian-fu-za-du">第一问，为什么要使用时间复杂度</a></li><li><a href="#di-er-wen-shi-me-shi-shi-jian-fu-za-du">第二问，什么是时间复杂度</a></li><li><a href="#di-san-wen-ru-he-ji-suan-shi-jian-fu-za-du">第三问，如何计算时间复杂度</a></li><li><a href="#geng-duo-de-shi-jian-fu-za-du">更多的时间复杂度</a></li></ul><!-- tocstop --></div><h2><span id="di-yi-wen-wei-shi-me-yao-shi-yong-shi-jian-fu-za-du">第一问，为什么要使用时间复杂度</span><a href="#di-yi-wen-wei-shi-me-yao-shi-yong-shi-jian-fu-za-du" class="header-anchor"></a></h2><p>一个算法在证明<strong>数学正确性</strong>后，我们要关心它的运行时间，这是一个程序性能的重要指标。</p><p>算法的时间可以通过实际运行得到，但有两个缺点</p><ul><li>复杂的算法通过开发到运行后在又优化，流程会很长，整体操作时间长，很不方便</li><li>运行时间受硬件、软件的影响，这对我们评估算法本身存在影响</li></ul><p>我们更希望可以在运行前，或者在编写前就预估出可能执行的“时间”。</p><p>所以引入了<strong>时间复杂度</strong>的概念，时间复杂度不是计算算法运行时间，而是估算出算法的复杂度，是个量级的概念。我们可以通过可能出现的时间复杂度，来选择可以接受的算法。</p><h2><span id="di-er-wen-shi-me-shi-shi-jian-fu-za-du">第二问，什么是时间复杂度</span><a href="#di-er-wen-shi-me-shi-shi-jian-fu-za-du" class="header-anchor"></a></h2><blockquote><p><strong>时间频度</strong> 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p></blockquote><blockquote><p><strong>时间复杂度</strong> 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p></blockquote><p>简单总结为</p><ul><li><code>n</code> 为算法使用者可以传入的变量，通常时间复杂度受该参数影响。</li><li><code>T(n)</code> 算法的运行次数，次数随着 n 的变化，而变化。</li><li><code>O(f(n))</code> 算法运行次数变化的规律，也就是时间复杂度，以大写的 O 为符号标记。</li><li><code>f(n)</code> 时间复杂度的值，是个近似值。</li></ul><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure><p>执行一次 <code>Hello World</code> 语句，我们称为一次运算，这个算法的时间复杂度就是 <code>O(1)</code>，也称为常数阶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个算法里，<code>console.log(i);</code> 的执行次数，随着参数 <code>n</code> 的变化而变化，那么这个算法的时间复杂度为 <code>O(n)</code>，也称为线性阶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        console.log(i + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个算法里，<code>console.log(i + j);</code> 的执行次数为 <code>n * n</code>，那么时间复杂度就是 <code>O(n^2)</code>，也成为平方阶。</p><p>在后续的描述中，<strong><em><code>^</code> 符号代表后面跟的是上角标，<code>_</code> 符号代表后面跟着下角标。</em></strong></p><p>通过这几个例子，我们可以得到计算时间复杂度的三个步骤</p><ul><li>找出算法的基本运行语句</li><li>计算运行次数的量级</li><li>使用 O 将其标记起来</li></ul><h2><span id="di-san-wen-ru-he-ji-suan-shi-jian-fu-za-du">第三问，如何计算时间复杂度</span><a href="#di-san-wen-ru-he-ji-suan-shi-jian-fu-za-du" class="header-anchor"></a></h2><p>计算时间复杂度也就是计算函数 <code>f(n)</code> 的值，是一个<strong>量级</strong>，在复杂算法中，时间复杂度关心的是最大的量级。</p><p>计算方式有如下规则</p><ul><li>不受参数 <code>n</code> 影响的运算次数，我们用常量 <code>C</code> 表示，当算法有参数 <code>n</code> 时，<code>C</code> 可以忽略不计，否则用 <code>1</code> 代替。(常数变1，然后去常数，去常参)</li><li>不受 <code>for</code> 循环影响的运算次数，使用加减法计算，否则使用乘法计算。</li><li>在最后的计算公式中，我们使用最大量级的值，来代表整个算法的时间复杂度。（去低阶）</li></ul><p>举几个例子</p><p><strong>常量变 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"Hello World"</span>);     <span class="comment">// 1</span></span><br><span class="line">console.log(<span class="string">"Hello World"</span>);     <span class="comment">// 1</span></span><br><span class="line">console.log(<span class="string">"Hello World"</span>);     <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>可以推导出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = Θ(1 + 1 + 1) = 1 <span class="comment"># Θ 表示常量变1、去常数、去常参、去低阶</span></span><br><span class="line">T(n) = O(f(n)) = O(1)</span><br></pre></td></tr></table></figure><p><strong>去常数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"Hello World"</span>);     <span class="comment">// 1</span></span><br><span class="line">console.log(<span class="string">"Hello World"</span>);     <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;     <span class="comment">// n</span></span><br><span class="line">    console.log(<span class="string">"Hello World"</span>); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推导公式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = Θ(1 + 1 + n * 1) = Θ(2 + n) = n</span><br><span class="line">T(n) = O(f(n)) = O(n)</span><br></pre></td></tr></table></figure><p><strong>为什么可以去掉常量？</strong>，当 <code>n</code> 趋近无穷大时，所以的常量都可以忽略不计，时间复杂度只关心最大的量级，所以可以去掉常量。</p><p><strong>去常参</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"Hello World"</span>);         <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;         <span class="comment">// n</span></span><br><span class="line">    console.log(<span class="string">"Hello World "</span>);    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;         <span class="comment">// n</span></span><br><span class="line">    console.log(<span class="string">"Hello World "</span>);    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推导公式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = Θ(1 + n * 1 + n * 1) = Θ(1 + 2n) = n</span><br><span class="line">T(n) = O(f(n)) = O(n)</span><br></pre></td></tr></table></figure><p><strong>去低阶</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;         <span class="comment">// n</span></span><br><span class="line">    console.log(<span class="string">"Hello World "</span>);    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;         <span class="comment">// n - 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;     <span class="comment">// n - 1</span></span><br><span class="line">        console.log(<span class="string">"Hello World "</span>);<span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推导公式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = Θ(n * 1 + (n - 1) * (n - 1) * 1) = Θ(n + n * n) = Θ(n + n^2) = n^2</span><br><span class="line">T(n) = O(f(n)) = O(n)</span><br></pre></td></tr></table></figure><p><strong>为什么可以去低阶?</strong>，同样的道理，当 <code>n</code> 趋近无穷时，<code>n</code> 在 <code>n^2</code> 的量级面前不止一提，所以我们可以去低阶。</p><h2><span id="geng-duo-de-shi-jian-fu-za-du">更多的时间复杂度</span><a href="#geng-duo-de-shi-jian-fu-za-du" class="header-anchor"></a></h2><p>前面我提到了三种时间复杂度，分别为常数阶 <code>O(1)</code>、线性阶 <code>O(n)</code>、平方阶 <code>O(n^2)</code></p><p>常用的时间复杂度还有：对数阶 <code>O(log_2n)</code>、线性对数阶 <code>O(nlog_2n)</code>、立方阶 <code>O(n^3)</code>、k 次方阶 <code>O(n^k)</code>、指数阶 <code>O(2^n)/O(n!)</code></p><p><strong>对数阶例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">    i = i * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推导公式需要使用到对数，假设 <code>while</code> 运行的次数为 <code>k</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 2^(k-1)</span><br><span class="line">k = log_2n + 1</span><br><span class="line">f(n) = Θ(1 + log_2n + 1) = log_2n</span><br><span class="line">T(n) = O(f(n)) = O(log_2n)</span><br></pre></td></tr></table></figure><p><strong>O(n!) 例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void nFacRuntimeFunc(int n) &#123;</span><br><span class="line">  <span class="keyword">for</span>(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">    nFacRuntimeFunc(n-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的算法时间复杂度由小到大依次为：<code>Ο(1)＜Ο(log_2n)＜Ο(n)＜Ο(nlog_2n)＜Ο(n^2)＜Ο(n^3)＜…＜Ο(2^n)＜Ο(n!)</code></p><ul><li>常数阶算法不包含任务循环语句和回调函数，我们不用担心此类算法的运算时间</li><li>对数阶、线性阶和次方阶，称为多项时间。通常包含循环语句，此类算法归为 <strong>P（Polynomial,多项式）类问题</strong></li><li>指数阶，称为指数时间。通常包含回调函数，此类算法归为 <strong>NP（Non-Deterministic Polynomial, 非确定多项式）问题</strong></li></ul><p>一般我们认为常数阶、对数阶、线性阶是可以接收的时间复杂度，因为次方阶和指数阶 <code>n</code> 的变量稍微变大，运行时间就成指数增加，让程序无法动弹。</p><p>通过这篇文章应该可以简单的了解时间复杂度，并可以计算常见的算法时间复杂度，但是仍需要不断的练习才可以熟练掌握。</p><p>参考资料</p><ul><li><a href="https://www.jianshu.com/p/f4cca5ce055a" target="_blank" rel="noopener">（数据结构）十分钟搞定时间复杂度（算法的时间复杂度）</a></li><li><a href="https://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="noopener">算法的时间复杂度和空间复杂度-总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间复杂度是一个及基础又重要，但却不那么显性的概念。对于很多程序员来说仿佛只会出现在面试题里，因为不了解它好像也不影响我开发程序。&lt;/p&gt;
&lt;p&gt;时间复杂度是算法的一个重要概念，但并不是一句重要就可以逼着别人去学习的，首先我们要提出三问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://wxnacy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Go 简单了解 interface</title>
    <link href="http://wxnacy.com/2019/02/19/go-interface/"/>
    <id>http://wxnacy.com/2019/02/19/go-interface/</id>
    <published>2019-02-19T07:08:51.000Z</published>
    <updated>2019-02-19T07:10:22.886Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中 interface 是很常用的，因为父类单继承的特性，interface 可以让类的实现更加灵活。</p><p>而同样在强类型的 GO 中，interface 也是必不可少的。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#interface-de-shi-xian">interface 的实现</a></li><li><a href="#pan-duan-interface-cun-chu-zhi-de-lei-xing">判断 interface 存储值的类型</a></li><li><a href="#shi-yong-interface-shi-xian-fan-xing">使用 interface 实现泛型</a></li></ul><!-- tocstop --></div><h2><span id="interface-de-shi-xian">interface 的实现</span><a href="#interface-de-shi-xian" class="header-anchor"></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface 是一种<strong>类型</strong>，可以包含 0 或更多的方法，如果一个类型实现了一个 interface 的所有方法，则它实现了该 interface，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// interface 的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">     <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IUser <span class="keyword">interface</span> &#123;</span><br><span class="line">    SetName(<span class="keyword">string</span>)</span><br><span class="line">    GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self User)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> self.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    self.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i IUser</span><br><span class="line">    i = &amp;User&#123;&#125;</span><br><span class="line">    i.SetName(<span class="string">"wxnacy"</span>)</span><br><span class="line">    fmt.Println(i.GetName())</span><br><span class="line">    <span class="comment">// wxnacy</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，因为 <code>SetName</code> 方法是在指针中实现的，所有 <code>i</code> 需要储存指针才可以实现 <code>struct</code> 中的所有方法</p><h2><span id="pan-duan-interface-cun-chu-zhi-de-lei-xing">判断 interface 存储值的类型</span><a href="#pan-duan-interface-cun-chu-zhi-de-lei-xing" class="header-anchor"></a></h2><p>使用 <code>i.(T)</code> 或 <code>i.(type)</code> 可以判断 interface 中储存的值，后者只能在 <code>switch</code> 中使用。</p><p>i 是 interface 类型的变量，T 代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> t, ok := i.(*User); ok &#123;</span><br><span class="line">    fmt.Println(t)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &amp;&#123;User&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> t := m.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> Man: &#123;</span><br><span class="line">        fmt.Println(<span class="string">"m is "</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        fmt.Println(<span class="string">"m is default"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m is  &#123;Man&#125;</span></span><br></pre></td></tr></table></figure><h2><span id="shi-yong-interface-shi-xian-fan-xing">使用 interface 实现泛型</span><a href="#shi-yong-interface-shi-xian-fan-xing" class="header-anchor"></a></h2><p>强类型语言可以实现类似 Java 的泛型是必不可少的，在 Go 中可以使用 interface 来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InArray</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;, array <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(index <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免通过编写重复代码实现方法的多态，我们可以使用 <code>interface{}</code> 来传入任意类型，<br>并使用 <code>reflect</code> 反射包来实现具体方法。</p><p>我们使用该特性，实现一个判断数组中是否包含某值的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 reflect 反射方法判断 val 是否包含在 array 中，如果包含返回索引位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InArray</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;, array <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">switch</span> reflect.TypeOf(array).Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.Slice: &#123;</span><br><span class="line">            arr := reflect.ValueOf(array)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; arr.Len(); i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> reflect.DeepEqual(val, arr.Index(i).Interface()) &#123;</span><br><span class="line">                    index = i</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(InArray(<span class="number">3</span>, arr))</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://golang.org/pkg/reflect" target="_blank" rel="noopener">reflact</a></li></ul><p>Demo 地址：<a href="https://github.com/wxnacy/study/tree/master/goland/src/interfaces" target="_blank" rel="noopener">https://github.com/wxnacy/study/tree/master/goland/src/interfaces</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 中 interface 是很常用的，因为父类单继承的特性，interface 可以让类的实现更加灵活。&lt;/p&gt;
&lt;p&gt;而同样在强类型的 GO 中，interface 也是必不可少的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="http://wxnacy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Python 单例的四种实现方式</title>
    <link href="http://wxnacy.com/2019/02/18/python-signletion/"/>
    <id>http://wxnacy.com/2019/02/18/python-signletion/</id>
    <published>2019-02-18T08:21:49.000Z</published>
    <updated>2019-02-18T08:35:37.121Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式中，单例模式是很常见的，今天总结下 Python 的几种实现方式。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#shi-yong-import">使用 import</a></li><li><a href="#shi-yong-new-fang-fa">使用 <strong>new</strong> 方法</a></li><li><a href="#shi-yong-zhuang-shi-qi">使用装饰器</a></li><li><a href="#shi-yong-yuan-lei">使用元类</a></li></ul><!-- tocstop --></div><h2><span id="shi-yong-import">使用 import</span><a href="#shi-yong-import" class="header-anchor"></a></h2><p><code>import</code> 是 Python 中的天然单例模式，我最先推荐这种方式。</p><p>创建两个文件 <code>signletion.py</code> <code>signletion_import.py</code>，文件内容如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: import 需要的部分</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">"new instance"</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, *args, **kw)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get class"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u = User()</span><br><span class="line">u.get()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: import 模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> singletion <span class="keyword">import</span> u</span><br><span class="line"></span><br><span class="line">u.get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># new instance</span></span><br><span class="line"><span class="comment"># get class</span></span><br><span class="line"><span class="comment"># get class</span></span><br></pre></td></tr></table></figure><p>运行结果只输出一次 <code>new instance</code>，代表只生成一个实例，创建单例成功，后续我们都用这种验证方式。</p><h2><span id="shi-yong-new-fang-fa">使用 <strong>new</strong> 方法</span><a href="#shi-yong-new-fang-fa" class="header-anchor"></a></h2><p>直接修改 <code>__new__</code> 方法，类似 Java 的实现方式，实际开发中，我们可以在父类中实现方法，并继承</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 使用 __new__ 方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singletion</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            print(<span class="string">"new instance"</span>)</span><br><span class="line">            cls._instance = super().__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingClass</span><span class="params">(Singletion)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get class"</span>)</span><br><span class="line"></span><br><span class="line">c = SingClass()</span><br><span class="line">c.get()</span><br><span class="line"></span><br><span class="line">c1 = SingClass()</span><br><span class="line">c1.get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># new instance</span></span><br><span class="line"><span class="comment"># get class</span></span><br><span class="line"><span class="comment"># get class</span></span><br></pre></td></tr></table></figure><h2><span id="shi-yong-zhuang-shi-qi">使用装饰器</span><a href="#shi-yong-zhuang-shi-qi" class="header-anchor"></a></h2><p>装饰器是比较 Python 的方式，内部实现跟 <code>__new__</code> 很像，判断已经有实例则不再生成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 装饰器模式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singletion</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instance = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instance:</span><br><span class="line">            print(<span class="string">"new instance"</span>)</span><br><span class="line">            instance[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instance[cls]</span><br><span class="line">    <span class="keyword">return</span> get_instance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singletion</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get class"</span>)</span><br><span class="line"></span><br><span class="line">u = User()</span><br><span class="line">u.get()</span><br><span class="line">u1 = User()</span><br><span class="line">u1.get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># new instance</span></span><br><span class="line"><span class="comment"># get class</span></span><br><span class="line"><span class="comment"># get class</span></span><br></pre></td></tr></table></figure><h2><span id="shi-yong-yuan-lei">使用元类</span><a href="#shi-yong-yuan-lei" class="header-anchor"></a></h2><p>元类同样是 Python 特有的，不过并不常用，我们可以利用它的特性来实现单例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 使用元类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            print(<span class="string">"new instance"</span>)</span><br><span class="line">            cls._instances[cls] = super().__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingClass</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get class"</span>)</span><br><span class="line"></span><br><span class="line">c = SingClass()</span><br><span class="line">c.get()</span><br><span class="line"></span><br><span class="line">c1 = SingClass()</span><br><span class="line">c1.get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># new instance</span></span><br><span class="line"><span class="comment"># get class</span></span><br><span class="line"><span class="comment"># get class</span></span><br></pre></td></tr></table></figure><p>完整 demo 地址：<a href="https://github.com/wxnacy/study/tree/master/python/singletion" target="_blank" rel="noopener">https://github.com/wxnacy/study/tree/master/python/singletion</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式中，单例模式是很常见的，今天总结下 Python 的几种实现方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Golang 获取当前机器用户信息</title>
    <link href="http://wxnacy.com/2019/02/17/go-os-user/"/>
    <id>http://wxnacy.com/2019/02/17/go-os-user/</id>
    <published>2019-02-17T08:58:09.000Z</published>
    <updated>2019-02-18T09:36:51.956Z</updated>
    
    <content type="html"><![CDATA[<p>在 Golang 语言中使用 <code>os/user</code> 包可以获取当前机器的用户信息。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">     <span class="string">"fmt"</span></span><br><span class="line">     <span class="string">"os/user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErr</span><span class="params">(err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u, err := user.Current()</span><br><span class="line">    handleErr(err)</span><br><span class="line">    fmt.Println(<span class="string">"当前用户"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"Gid %s\n"</span>, u.Gid)</span><br><span class="line">    fmt.Printf(<span class="string">"Uid %s\n"</span>, u.Uid)</span><br><span class="line">    fmt.Printf(<span class="string">"Username %s\n"</span>, u.Username)</span><br><span class="line">    fmt.Printf(<span class="string">"Name %s\n"</span>, u.Name)</span><br><span class="line">    fmt.Printf(<span class="string">"HomeDir %s\n"</span>, u.HomeDir)</span><br><span class="line">    fmt.Println(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前用户</span></span><br><span class="line">    <span class="comment">// Gid 20</span></span><br><span class="line">    <span class="comment">// Uid 501</span></span><br><span class="line">    <span class="comment">// Username wxnacy</span></span><br><span class="line">    <span class="comment">// Name wxnacy</span></span><br><span class="line">    <span class="comment">// HomeDir /Users/wxnacy</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User 结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Uid      <span class="keyword">string</span>  <span class="comment">// 用户的 ID</span></span><br><span class="line">    Gid      <span class="keyword">string</span>  <span class="comment">// 用户所属组的 ID，如果属于多个组，那么此 ID 为主组的 ID</span></span><br><span class="line">    Username <span class="keyword">string</span>  <span class="comment">// 用户名</span></span><br><span class="line">    Name     <span class="keyword">string</span>  <span class="comment">// 属组名称，如果属于多个组，那么此名称为主组的名称</span></span><br><span class="line">    HomeDir  <span class="keyword">string</span>  <span class="comment">// 用户的宿主目录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当前用户</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Current</span><span class="params">()</span> <span class="params">(*User, error)</span></span></span><br></pre></td></tr></table></figure><p><strong>通过 Uid 获取用户</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LookupId</span><span class="params">(uid <span class="keyword">string</span>)</span> <span class="params">(*User, error)</span></span></span><br></pre></td></tr></table></figure><p><strong>通过 Username 获取用户</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(username <span class="keyword">string</span>)</span> <span class="params">(*User, error)</span></span></span><br></pre></td></tr></table></figure><p>验证代码地址：<a href="https://github.com/wxnacy/study/blob/master/goland/src/simple/os_user.go" target="_blank" rel="noopener">https://github.com/wxnacy/study/blob/master/goland/src/simple/os_user.go</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Golang 语言中使用 &lt;code&gt;os/user&lt;/code&gt; 包可以获取当前机器的用户信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="http://wxnacy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6 搭建 SS 服务器（自动脚本）</title>
    <link href="http://wxnacy.com/2019/02/07/linux-install-ssr/"/>
    <id>http://wxnacy.com/2019/02/07/linux-install-ssr/</id>
    <published>2019-02-07T04:27:33.000Z</published>
    <updated>2019-02-07T04:29:23.982Z</updated>
    
    <content type="html"><![CDATA[<p>以 <a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">自建ss服务器教程</a> 为教程，使用 expect 编写了自动部署脚本。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#an-zhuang-ssr">安装 SSR</a></li><li><a href="#an-zhuang-rui-su">安装锐速</a></li></ul><!-- tocstop --></div><p>直接安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget -N --no-check-certificate https://raw.githubusercontent.com/wxnacy/wshell/master/bin/ssr/centos_install_ssr</span><br><span class="line">$ bash centos_install_ssr</span><br></pre></td></tr></table></figure><p>执行完后服务器自动重启，稍后登陆执行命令，完成锐速加速</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash serverspeeder-all.sh</span><br></pre></td></tr></table></figure><p>或者使用 <a href="https://github.com/wxnacy/wshell" target="_blank" rel="noopener">wshell</a> 进行安装</p><p>原理：</p><ul><li>选用 CentOS6 系统</li><li>安装 SSR 客户端</li><li>使用锐速加速器</li></ul><p>使用 vultr 购买 CentOS 6 服务器，教程有很详细的讲解，不再赘述。</p><h2><span id="an-zhuang-ssr">安装 SSR</span><a href="#an-zhuang-ssr" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y wget expect</span><br><span class="line">$ wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh</span><br></pre></td></tr></table></figure><p>创建自动部署脚本 <code>install_ssr</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env expect</span><br><span class="line"></span><br><span class="line">spawn sh -c &quot;bash ssr.sh&quot;</span><br><span class="line">expect &quot;*1-15*&quot;</span><br><span class="line"># 安装</span><br><span class="line">send &quot;1\r&quot;</span><br><span class="line">expect &quot;(默认: 2333):&quot;</span><br><span class="line">send &quot;\r&quot;</span><br><span class="line">expect &quot;(默认: doub.io)&quot;</span><br><span class="line">send &quot;\r&quot;</span><br><span class="line">expect &quot;(默认: 5. aes-128-ctr):&quot;</span><br><span class="line">send &quot;10\r&quot;</span><br><span class="line">expect &quot;(默认: 2. auth_sha1_v4):&quot;</span><br><span class="line">send &quot;\r&quot;</span><br><span class="line">expect &quot;*Y*n&quot;</span><br><span class="line">send &quot;y\r&quot;</span><br><span class="line">expect &quot;(默认: 1. plain):&quot;</span><br><span class="line">send &quot;\r&quot;</span><br><span class="line">expect &quot;(默认: 无限):&quot;</span><br><span class="line">send &quot;\r&quot;</span><br><span class="line">expect &quot;(默认: 无限):&quot;</span><br><span class="line">send &quot;\r&quot;</span><br><span class="line">expect &quot;(默认: 无限):&quot;</span><br><span class="line">send &quot;\r&quot;</span><br><span class="line">expect &quot;*y*N*&quot;</span><br><span class="line">send &quot;y\r&quot;</span><br><span class="line">expect &quot;*y*N*&quot;</span><br><span class="line">send &quot;y\r&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure><p>使用 expect 运行脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x install_ssr</span><br><span class="line">$ expect install_ssr</span><br></pre></td></tr></table></figure><p>随后会使用教程使用的默认参数进行自动安装</p><h2><span id="an-zhuang-rui-su">安装锐速</span><a href="#an-zhuang-rui-su" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget --no-check-certificate https://blog.asuhu.com/sh/ruisu.sh</span><br><span class="line">$ wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh</span><br><span class="line">$ bash ruisu.sh</span><br></pre></td></tr></table></figure><p>执行时间会有点长，完毕后机器会自动重启，稍后登陆在进行加速操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash serverspeeder-all.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以 &lt;a href=&quot;https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自建ss服务器教程&lt;/a&gt; 为教程，使用 expect 编写了自动部署脚本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
      <category term="ssr" scheme="http://wxnacy.com/tags/ssr/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant 常用命令</title>
    <link href="http://wxnacy.com/2019/02/05/vagrant-commands/"/>
    <id>http://wxnacy.com/2019/02/05/vagrant-commands/</id>
    <published>2019-02-05T14:33:10.000Z</published>
    <updated>2019-02-27T15:26:42.313Z</updated>
    
    <content type="html"><![CDATA[<p>记录些 Vagrant 经常用到的命令</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#gong-zuo-mu-lu-zhong">工作目录中</a></li><li><a href="#quan-ju-ming-ling">全局命令</a></li></ul><!-- tocstop --></div><h2><span id="gong-zuo-mu-lu-zhong">工作目录中</span><a href="#gong-zuo-mu-lu-zhong" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant init centos/7             <span class="comment"># 初始化系统"</span></span><br><span class="line">$ vagrant up                        <span class="comment"># 启动虚拟机"</span></span><br><span class="line">$ vagrant ssh                       <span class="comment"># 登陆虚拟机"</span></span><br><span class="line">$ vagrant halt                      <span class="comment"># 登陆虚拟机"</span></span><br><span class="line">$ vagrant destroy                   <span class="comment"># 销毁虚拟机"</span></span><br><span class="line">$ vagrant destroy -f                <span class="comment"># 销毁虚拟机，并对询问回答 yes"</span></span><br><span class="line">$ vagrant package                   <span class="comment"># 打包 box"</span></span><br><span class="line">$ vagrant package --ouput=box-name  <span class="comment"># 打包 box，并指定包名"</span></span><br><span class="line">$ vagrant box update                <span class="comment"># 更新 box 版本"</span></span><br><span class="line">$ vagrant status                    <span class="comment"># 当前虚拟机状态</span></span><br><span class="line">$ vagrant reload                    <span class="comment"># 重新加载虚拟机配置</span></span><br></pre></td></tr></table></figure><h2><span id="quan-ju-ming-ling">全局命令</span><a href="#quan-ju-ming-ling" class="header-anchor"></a></h2><p>查看所有虚拟机状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant global-status</span><br><span class="line"></span><br><span class="line">id       name    provider   state        directory</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">2ed1547  default virtualbox running      /Users/wxnacy/VagrantProjects/centos7-wshell</span><br><span class="line">1a7c506  default virtualbox inaccessible /Users/wxnacy/VagrantProjects/wxnacy-centos7</span><br><span class="line">a980255  default virtualbox inaccessible /Users/wxnacy/VagrantProjects/centos6</span><br><span class="line">d6edb01  default virtualbox running      /Users/wxnacy/VagrantProjects/wxnacy-ubuntu1604</span><br><span class="line">908baa1  default virtualbox running      /Users/wxnacy/VagrantProjects/xenial64</span><br><span class="line">da8e118  default virtualbox running      /Users/wxnacy/VagrantProjects/bionic64</span><br><span class="line">7a1fc36  default virtualbox poweroff     /Users/wxnacy/VagrantProjects/ubuntu1804</span><br><span class="line">40aa16f  default virtualbox running      /Users/wxnacy/VagrantProjects/centos7</span><br></pre></td></tr></table></figure><p>销毁指定虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant destroy name|id</span><br></pre></td></tr></table></figure><p>查看所有 box 列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box list</span><br><span class="line"></span><br><span class="line">centos/7          (virtualbox, 1811.02)</span><br><span class="line">debian/jessie64   (virtualbox, 8.11.0)</span><br><span class="line">ubuntu/bionic64   (virtualbox, 20190212.1.0)</span><br><span class="line">wxnacy/ubuntu1804 (virtualbox, 0)</span><br></pre></td></tr></table></figure><p>添加本地 box 到仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box add my-box-name box-path</span><br></pre></td></tr></table></figure><p>删除 box</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box remove my-box-name</span><br><span class="line">$ vagrant box remove my-box-name --box-version &lt;version&gt;    <span class="comment"># 指定版本</span></span><br></pre></td></tr></table></figure><p>更新 box</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box update --box &lt;box-name&gt;</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.vagrantup.com/docs/cli/" target="_blank" rel="noopener">Command-Line Interface</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录些 Vagrant 经常用到的命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="vagrant" scheme="http://wxnacy.com/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>Vim 查看环境信息</title>
    <link href="http://wxnacy.com/2019/02/04/vim-show-message/"/>
    <id>http://wxnacy.com/2019/02/04/vim-show-message/</id>
    <published>2019-02-04T02:37:59.000Z</published>
    <updated>2019-02-27T02:48:23.394Z</updated>
    
    <content type="html"><![CDATA[<p>Vim 可以直接在命令行模式查看很多环境信息。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#vim-xin-xi">Vim 信息</a></li><li><a href="#huan-jing-bian-liang">环境变量</a></li></ul><!-- tocstop --></div><h2><span id="vim-xin-xi">Vim 信息</span><a href="#vim-xin-xi" class="header-anchor"></a></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">version</span>            <span class="string">" 版本信息和加载 vimrc 顺序等信息"</span></span><br><span class="line">:<span class="keyword">scriptnames</span>        <span class="string">" 查看 script 脚本的加载顺序"</span></span><br><span class="line">:<span class="keyword">messages</span>           <span class="string">" 查看 echom 打印信息"</span></span><br><span class="line">:<span class="function"><span class="keyword">function</span>           " 查看加载的 <span class="title">function</span> 列表"</span></span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">all</span>            <span class="string">" 查看 Vim 所有变量"</span></span><br><span class="line">:<span class="keyword">set</span>                <span class="string">" 查看 Vim 所有与系统不同的变量"</span></span><br><span class="line">:<span class="keyword">set</span> variable?      <span class="comment">" 显示指定 Vim 变量的当前值</span></span><br><span class="line">:<span class="keyword">set</span> runtimepath?   <span class="comment">" 显示 script 搜索路径</span></span><br></pre></td></tr></table></figure><h2><span id="huan-jing-bian-liang">环境变量</span><a href="#huan-jing-bian-liang" class="header-anchor"></a></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">echo</span> $HOME         <span class="string">" 用户根目录"</span></span><br><span class="line">:<span class="keyword">echo</span> $VIM          <span class="string">" Vim 程序安装目录"</span></span><br><span class="line">:<span class="keyword">echo</span> $VIMRUNTIME   <span class="string">" Vim 程序位置"</span></span><br><span class="line">:<span class="keyword">echo</span> $MYVIMRC      <span class="string">" .vimrc 文件位置"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vim 可以直接在命令行模式查看很多环境信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Go GOPATH 的作用</title>
    <link href="http://wxnacy.com/2019/02/03/go-gopath/"/>
    <id>http://wxnacy.com/2019/02/03/go-gopath/</id>
    <published>2019-02-03T06:11:22.000Z</published>
    <updated>2019-02-25T06:26:12.988Z</updated>
    
    <content type="html"><![CDATA[<p><code>GOPATH</code> 是开发 Go 时必须设置的一个环境变量，通常在安装完 Go 以后就要在 <code>.bash_profile</code> 中进行配置。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$&#123;HOME&#125;</span>/project</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使配置生效后，可以使用命令 <code>go env</code> 查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line">$ go env</span><br><span class="line">...</span><br><span class="line">GOPATH=/Users/wxnacy/project</span><br></pre></td></tr></table></figure><p>这样你就可以开发 Go 项目了。</p><p><code>GOPATH</code> 的作用是什么呢？该目录下可能会包含三个文件夹</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>src</td><td>需要编译的代码和使用 <code>go get</code> 安装的外部依赖代码存放位置</td></tr><tr><td>bin</td><td>编译代码生成的二进制文件存放位置</td></tr><tr><td>pkg</td><td>编译生成的lib文件存储的地方</td></tr></tbody></table><p><code>src</code> 需要手动创建，<code>bin</code> 和 <code>pkg</code> 则是编译时自动生成的。</p><p><code>src</code> 很像 Python 的 site-packages 目录，用来存放依赖包，不过 Go 比较随性，你开发的代码也放在这个目录下，不然编译就会报错。</p><p>我们第一次设置了 <code>GOPATH</code> 后，也不用拘泥于每次将代码都 copy 到 <code>${GOPATH}/src</code> 中，我们只需要将当前代码放在 src 目录下，并将 src 的所在目录临时设置为 <code>GOPATH</code> 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;GOPATH&lt;/code&gt; 是开发 Go 时必须设置的一个环境变量，通常在安装完 Go 以后就要在 &lt;code&gt;.bash_profile&lt;/code&gt; 中进行配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="http://wxnacy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Python 实现 Mysql hash 分表的增删改查</title>
    <link href="http://wxnacy.com/2019/02/02/python-mysql-hash-split-table/"/>
    <id>http://wxnacy.com/2019/02/02/python-mysql-hash-split-table/</id>
    <published>2019-02-02T05:59:44.000Z</published>
    <updated>2019-02-02T06:16:22.405Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql 水平分表方式中，比较适合频繁操作全部数据的方式为 hash 取模，比如用户表，所有数据都会频繁使用，使用 hash 取模的方式可以平均的将数据分配到各个表中。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>理解起来并不难，但是在写代码时需要讲究一些方法，如果有 10 个表，我们总不能写 10 个 Model 进行查询操作吧。</p><p>好在 Python 中可以利用 <code>type()</code> 方法动态创建 <code>class</code>，我们可以根据 id 来生成相应的 Model。</p><p>先来创建两个表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test_1` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(32) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名字&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT=&apos;测试&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test_0` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(32) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;名字&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT=&apos;测试&apos;;</span><br></pre></td></tr></table></figure><p>我们使用 <code>flask-sqlalchemy</code> 模块来进行 ORM 操作，正常的写法应该是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'test_0'</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = db.Column(db.String, default=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.id = <span class="number">1</span></span><br><span class="line">t.name  = <span class="string">'test'</span></span><br><span class="line">db.session.add(t)</span><br><span class="line">db.session.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line"></span><br><span class="line">Test.query.filter_by(id=<span class="number">1</span>).first()</span><br></pre></td></tr></table></figure><p>我说过我不想在写一个 <code>Test1</code> 来对应 <code>test_1</code> 表了，所以我需要对 <code>Test</code> 做一些修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">()</span>:</span></span><br><span class="line">    _model = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(test_id)</span>:</span></span><br><span class="line">        <span class="comment"># 通过取余的方式将数据平均分配到两个表中</span></span><br><span class="line">        index = test_id % <span class="number">2</span></span><br><span class="line">        tablename = <span class="string">'test_&#123;&#125;'</span>.format(index)</span><br><span class="line">        classname = <span class="string">'Test_&#123;&#125;'</span>.format(index)</span><br><span class="line"></span><br><span class="line">        Model = Test._model.get(classname)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> Model:</span><br><span class="line">            Model = type(classname, (BaseModel, db.Model), &#123;</span><br><span class="line">                <span class="string">'__module__'</span>: __name__,</span><br><span class="line">                <span class="string">'__name__'</span>: classname,</span><br><span class="line">                <span class="string">'__tablename__'</span>: tablename,</span><br><span class="line"></span><br><span class="line">                <span class="string">'id'</span> : db.Column(db.BIGINT, primary_key=<span class="keyword">True</span>),</span><br><span class="line">                <span class="string">'name'</span> : db.Column(db.String, default=<span class="string">""</span>, doc=<span class="string">""</span>),</span><br><span class="line">            &#125;)</span><br><span class="line">            Test._model[classname] = Model</span><br><span class="line">        <span class="keyword">return</span> Model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line"></span><br><span class="line">T = Test.model(<span class="number">1</span>)</span><br><span class="line">t = T()</span><br><span class="line">t.id = <span class="number">1</span></span><br><span class="line">t.name = <span class="string">'test'</span></span><br><span class="line">db.session.add(t)</span><br><span class="line">db.session.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line"></span><br><span class="line">T.query.filter_by(id=<span class="number">1</span>).first()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mysql 水平分表方式中，比较适合频繁操作全部数据的方式为 hash 取模，比如用户表，所有数据都会频繁使用，使用 hash 取模的方式可以平均的将数据分配到各个表中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
      <category term="mysql" scheme="http://wxnacy.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux wc 命令：计算行数、字数、字节数</title>
    <link href="http://wxnacy.com/2019/02/01/linux-wc/"/>
    <id>http://wxnacy.com/2019/02/01/linux-wc/</id>
    <published>2019-02-01T03:56:30.000Z</published>
    <updated>2019-02-01T04:15:55.803Z</updated>
    
    <content type="html"><![CDATA[<p>wc 命令用于查看文件的行数、字数、字节数</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#kuai-su-shi-yong">快速使用</a></li><li><a href="#geng-duo-can-shu">更多参数</a></li><li><a href="#yan-shen-shi-yong">延伸使用</a></li></ul><!-- tocstop --></div><h2><span id="kuai-su-shi-yong">快速使用</span><a href="#kuai-su-shi-yong" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc wsh.log</span><br><span class="line">   901    3226   13803 wsh.log</span><br></pre></td></tr></table></figure><p>查询的三个数字分别为行数、单词数、字节数</p><h2><span id="geng-duo-can-shu">更多参数</span><a href="#geng-duo-can-shu" class="header-anchor"></a></h2><p>使用 <code>man</code> 命令可以查看 wc 的完整文档、还有如下参数</p><ul><li><code>-c</code>: 查看字节数</li><li><code>-m</code>: 查看字符数</li><li><code>-w</code>: 查看单词数</li><li><code>-l</code>: 查看行数<br>macOS 没有下面的命令</li><li><code>-L</code>: 查看最长行的长度</li><li><code>--help</code>: 查看在线帮助</li><li><code>--version</code>: 查看版本</li></ul><h2><span id="yan-shen-shi-yong">延伸使用</span><a href="#yan-shen-shi-yong" class="header-anchor"></a></h2><p>wc 也可以接受管道信息，我们可以查看当前目录文件数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls | wc -l</span><br></pre></td></tr></table></figure><p>这是包含文件夹的，如果只想要查看文件数，可以借助 <code>grep</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ll | grep ^- | wc -l</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;wc 命令用于查看文件的行数、字数、字节数&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 查询 JSON 结果的相关函数</title>
    <link href="http://wxnacy.com/2019/01/26/mysql-json-functions/"/>
    <id>http://wxnacy.com/2019/01/26/mysql-json-functions/</id>
    <published>2019-01-26T09:25:23.000Z</published>
    <updated>2019-01-26T11:43:14.929Z</updated>
    
    <content type="html"><![CDATA[<p>JSON 格式字段是 Mysql 5.7 新加的属性，不够它本质上以字符串性质保存在库中的，刚接触时我只了解 <code>$.xx</code> 查询字段的方法，因为大部分时间，有这个就够了，其他交给程序就行了，但是最近一些操作需要更复杂的查询操作，所以赶紧了解下更多的方法。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#json-extract-json-doc-path">JSON_EXTRACT(json_doc [,path])</a></li><li><a href="#json-depth-json-doc">JSON_DEPTH(json_doc)</a></li><li><a href="#json-length-json-doc-path">JSON_LENGTH(json_doc [, path])</a></li><li><a href="#json-type-json-doc">JSON_TYPE(json_doc)</a></li><li><a href="#json-valid">JSON_VALID</a></li></ul><!-- tocstop --></div><h2><span id="json-extract-json-doc-path">JSON_EXTRACT(json_doc [,path])</span><a href="#json-extract-json-doc-path" class="header-anchor"></a></h2><p>查询字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @j = &apos;&#123;&quot;name&quot;:&quot;wxnacy&quot;&#125;&apos;;</span><br><span class="line">mysql&gt; select JSON_EXTRACT(@j, &apos;$.name&apos;);</span><br><span class="line">+----------------------------+</span><br><span class="line">| JSON_EXTRACT(@j, &apos;$.name&apos;) |</span><br><span class="line">+----------------------------+</span><br><span class="line">| &quot;wxnacy&quot;                   |</span><br><span class="line">+----------------------------+</span><br></pre></td></tr></table></figure><p>还有一种更简洁的方式，但是只能在查询表时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select ext -&gt; &apos;$.name&apos; from test;</span><br><span class="line">+-----------------+</span><br><span class="line">| ext -&gt; &apos;$.name&apos; |</span><br><span class="line">+-----------------+</span><br><span class="line">| &quot;wxnacy&quot;        |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><p>在 <code>$.</code> 后可以正常的使用 JSON 格式获取数据方式，比如数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @j = &apos;&#123;&quot;a&quot;: [1, 2]&#125;&apos;;</span><br><span class="line">mysql&gt; select JSON_EXTRACT(@j, &apos;$.a[0]&apos;);</span><br><span class="line">+----------------------------+</span><br><span class="line">| JSON_EXTRACT(@j, &apos;$.a[0]&apos;) |</span><br><span class="line">+----------------------------+</span><br><span class="line">| 1                          |</span><br><span class="line">+----------------------------+</span><br></pre></td></tr></table></figure><h2><span id="json-depth-json-doc">JSON_DEPTH(json_doc)</span><a href="#json-depth-json-doc" class="header-anchor"></a></h2><p>计算 JSON 深度，计算方式 <code>{} []</code> 有一个符号即为一层，符号下有数据增加一层，复杂 JSON 算到最深的一次为止，官方文档说 <code>null</code> 值深度为 0，但是实际效果并非如此，列举几个例子</p><p><img src="http://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/json_depth_360.png" alt="json_depth"></p><h2><span id="json-length-json-doc-path">JSON_LENGTH(json_doc [, path])</span><a href="#json-length-json-doc-path" class="header-anchor"></a></h2><p>计算 JSON 最外层或者指定 path 的长度，标量的长度为1。数组的长度是数组元素的数量，对象的长度是对象成员的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_LENGTH(&apos;[1, 2, &#123;&quot;a&quot;: 3&#125;]&apos;);</span><br><span class="line">+---------------------------------+</span><br><span class="line">| JSON_LENGTH(&apos;[1, 2, &#123;&quot;a&quot;: 3&#125;]&apos;) |</span><br><span class="line">+---------------------------------+</span><br><span class="line">|                               3 |</span><br><span class="line">+---------------------------------+</span><br><span class="line">mysql&gt; SELECT JSON_LENGTH(&apos;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 30&#125;&#125;&apos;);</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">| JSON_LENGTH(&apos;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 30&#125;&#125;&apos;) |</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">|                                       2 |</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">mysql&gt; SELECT JSON_LENGTH(&apos;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 30&#125;&#125;&apos;, &apos;$.b&apos;);</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">| JSON_LENGTH(&apos;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 30&#125;&#125;&apos;, &apos;$.b&apos;) |</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">|                                              1 |</span><br><span class="line">+------------------------------------------------+</span><br></pre></td></tr></table></figure><h2><span id="json-type-json-doc">JSON_TYPE(json_doc)</span><a href="#json-type-json-doc" class="header-anchor"></a></h2><p>返回一个utf8mb4字符串，指示JSON值的类型。 这可以是对象，数组或标量类型，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET @j = &apos;&#123;&quot;a&quot;: [10, true]&#125;&apos;;</span><br><span class="line">mysql&gt; SELECT JSON_TYPE(@j);</span><br><span class="line">+---------------+</span><br><span class="line">| JSON_TYPE(@j) |</span><br><span class="line">+---------------+</span><br><span class="line">| OBJECT        |</span><br><span class="line">+---------------+</span><br><span class="line">mysql&gt; SELECT JSON_TYPE(JSON_EXTRACT(@j, &apos;$.a&apos;));</span><br><span class="line">+------------------------------------+</span><br><span class="line">| JSON_TYPE(JSON_EXTRACT(@j, &apos;$.a&apos;)) |</span><br><span class="line">+------------------------------------+</span><br><span class="line">| ARRAY                              |</span><br><span class="line">+------------------------------------+</span><br><span class="line">mysql&gt; SELECT JSON_TYPE(JSON_EXTRACT(@j, &apos;$.a[0]&apos;));</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| JSON_TYPE(JSON_EXTRACT(@j, &apos;$.a[0]&apos;)) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| INTEGER                               |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">mysql&gt; SELECT JSON_TYPE(JSON_EXTRACT(@j, &apos;$.a[1]&apos;));</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| JSON_TYPE(JSON_EXTRACT(@j, &apos;$.a[1]&apos;)) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| BOOLEAN                               |</span><br><span class="line">+---------------------------------------+</span><br></pre></td></tr></table></figure><p>可能的返回类型</p><ul><li>纯JSON类型：<ul><li>OBJECT：JSON对象</li><li>ARRAY：JSON数组</li><li>BOOLEAN：JSON真假文字</li><li>NULL：JSON null文字</li></ul></li><li>数字类型：<ul><li>INTEGER：MySQL TINYINT，SMALLINT，MEDIUMINT以及INT和BIGINT标量</li><li>DOUBLE：MySQL DOUBLE FLOAT标量</li><li>DECIMAL：MySQL DECIMAL和NUMERIC标量</li></ul></li><li>时间类型：<ul><li>DATETIME：MySQL DATETIME和TIMESTAMP标量</li><li>日期：MySQL DATE标量</li><li>TIME：MySQL TIME标量</li></ul></li><li>字符串类型：<ul><li>STRING：MySQL utf8字符类型标量：CHAR，VARCHAR，TEXT，ENUM和SET</li></ul></li><li>二进制类型：<ul><li>BLOB：MySQL二进制类型标量，包括BINARY，VARBINARY，BLOB和BIT<br>所有其他类型：<br>OPAQUE（原始位）</li></ul></li></ul><h2><span id="json-valid">JSON_VALID</span><a href="#json-valid" class="header-anchor"></a></h2><p>返回0或1以指示值是否为有效JSON。 如果参数为NULL，则返回NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_VALID(&apos;&#123;&quot;a&quot;: 1&#125;&apos;);</span><br><span class="line">+------------------------+</span><br><span class="line">| JSON_VALID(&apos;&#123;&quot;a&quot;: 1&#125;&apos;) |</span><br><span class="line">+------------------------+</span><br><span class="line">|                      1 |</span><br><span class="line">+------------------------+</span><br><span class="line">mysql&gt; SELECT JSON_VALID(&apos;hello&apos;), JSON_VALID(&apos;&quot;hello&quot;&apos;);</span><br><span class="line">+---------------------+-----------------------+</span><br><span class="line">| JSON_VALID(&apos;hello&apos;) | JSON_VALID(&apos;&quot;hello&quot;&apos;) |</span><br><span class="line">+---------------------+-----------------------+</span><br><span class="line">|                   0 |                     1 |</span><br><span class="line">+---------------------+-----------------------+</span><br></pre></td></tr></table></figure><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/json-attribute-functions.html" target="_blank" rel="noopener">Functions That Return JSON Value Attributes</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSON 格式字段是 Mysql 5.7 新加的属性，不够它本质上以字符串性质保存在库中的，刚接触时我只了解 &lt;code&gt;$.xx&lt;/code&gt; 查询字段的方法，因为大部分时间，有这个就够了，其他交给程序就行了，但是最近一些操作需要更复杂的查询操作，所以赶紧了解下更多的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://wxnacy.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose 启动报错</title>
    <link href="http://wxnacy.com/2019/01/23/docker-compose-up-error/"/>
    <id>http://wxnacy.com/2019/01/23/docker-compose-up-error/</id>
    <published>2019-01-23T03:01:41.000Z</published>
    <updated>2019-01-23T03:06:49.052Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Couldn<span class="string">'t connect to Docker daemon at http+docker://localunixsocket - is it running?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If it'</span>s at a non-standard location, specify the URL with the DOCKER_HOST environment variable.</span><br></pre></td></tr></table></figure><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up -d</span><br></pre></td></tr></table></figure><p><code>docker-compose</code> 启动时报了如上错误，本身对该命令不太熟悉，所以开始一直在纠结 <code>http+docker://localunixsocket</code> 和 <code>DOCKER_HOST</code>，后来搜索下发现很简单。</p><p><code>docker</code> 和 <code>sudo docker</code> 在机器里会有两个启动的可能，<code>docker-compose</code> 也要跟他相对应</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose up -d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ERROR: Couldn&lt;span class=&quot;string&quot;&gt;&#39;t connect to Docker daemon at http+docker://localunixsocket - is it running?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;If it&#39;&lt;/span&gt;s at a non-standard location, specify the URL with the DOCKER_HOST environment variable.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 安装 PyAudio 出错</title>
    <link href="http://wxnacy.com/2019/01/22/centos7-install-pyaudio-error/"/>
    <id>http://wxnacy.com/2019/01/22/centos7-install-pyaudio-error/</id>
    <published>2019-01-22T08:19:08.000Z</published>
    <updated>2019-01-22T08:25:09.894Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 7 系统下安装 PyAudio 总是报错，关键信息如下</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">#include "portaudio.h"</span></span><br><span class="line">...</span><br><span class="line">error: Setup script exited with error: <span class="built_in">command</span> <span class="string">'gcc'</span> failed with <span class="built_in">exit</span> status 1</span><br></pre></td></tr></table></figure><p>错误原因在于缺少 <code>portaudio.h</code> 头文件，安装 portaudio 即可</p><p>访问下载页面 <a href="http://portaudio.com/download.html" target="_blank" rel="noopener">http://portaudio.com/download.html</a> 下载 <code>pa_stable_v190600_20161030.tgz</code> 或更高版本，并解压安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://portaudio.com/archives/pa_stable_v190600_20161030.tgz</span><br><span class="line">$ var -xvf pa_stable_v190600_20161030.tgz</span><br><span class="line">$ <span class="built_in">cd</span> portaudio</span><br><span class="line">$ ./configure</span><br><span class="line">$ sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>随后再次下载 PyAudio 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install PyAudio</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo easy_install PyAudio</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS 7 系统下安装 PyAudio 总是报错，关键信息如下&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 解决升级版本后渲染 Markdown TOC 不生效</title>
    <link href="http://wxnacy.com/2019/01/19/hexo-render-toc-error/"/>
    <id>http://wxnacy.com/2019/01/19/hexo-render-toc-error/</id>
    <published>2019-01-19T05:57:46.000Z</published>
    <updated>2019-01-19T06:22:00.301Z</updated>
    
    <content type="html"><![CDATA[<p>这两天因为升级 Node 环境到 <code>10.15.0</code> 版本，导致 Hexo 也做了升级，结果发生了意外。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>原来的很多文章，渲染 Markdown 文件都出现了问题，并没有渲染成相应的 <code>html</code> 代码，然而另一部分却正常。</p><p>开始以为是某些库的问题，进行了各种清除缓存重新下载的操作，依然有问题。</p><p>愁了好长时间，将没有问题的文章和有问题的一一对比，并且逐渐尝试，终于，终于找到了问题。</p><p>问题出在了 &#60;&#33;&#45;&#45; toc &#45;&#45;&#62; 上，在文章的开头我需要使用这个符号进行目录转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这两天因为升级 Node 环境到 `10.15.0` 版本，导致 Hexo 也做了升级，结果发生了意外。</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;&lt;!-- toc --&gt;</span><br></pre></td></tr></table></figure><p>如果去掉中间的空行，那么就会解析错误，我认为这是 hexo 插件的 bug，不过显然我等不到它来解决了，只能手动加上了空行。</p><p>不过我查看了，我的文章中有 300 多个有问题的，额，作为一个程序猿，怎么可能手动去改呢，写个程序，将这些全部都刷上空行，搞定。</p><p>经过了这次，也算是一个小教训，以后更加需要关注的是写作规范，每行间手动加上空格，也是一个良好的编写习惯。</p><p>哎！我也只能这样安慰自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天因为升级 Node 环境到 &lt;code&gt;10.15.0&lt;/code&gt; 版本，导致 Hexo 也做了升级，结果发生了意外。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://wxnacy.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>React 通过入门项目 create-react-app 了解其语法</title>
    <link href="http://wxnacy.com/2019/01/18/create-react-app/"/>
    <id>http://wxnacy.com/2019/01/18/create-react-app/</id>
    <published>2019-01-18T06:26:20.000Z</published>
    <updated>2019-01-19T09:10:37.177Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> 是 React 的入门项目，通过它可以窥见 React 项目的简单构成和基本语法。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#qi-dong-liu-cheng">启动流程</a></li><li><a href="#gou-jian-jing-tai-ye-mian">构建静态页面</a></li><li><a href="#wei-shi-me-ru-kou-zhi-you-index-html">为什么入口只有 index.html</a></li></ul><!-- tocstop --></div><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><p>三种方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx create-react-app my-app</span><br></pre></td></tr></table></figure><p>npx 来自 npm 5.2+ 或更高版本自带软件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init react-app my-app</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn create react-app my-app</span><br></pre></td></tr></table></figure><p><strong>启动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-app</span><br><span class="line">$ yarn start</span><br></pre></td></tr></table></figure><p>随后会启动 <code>3000</code> 端口服务，并自动在浏览器中打开地址 <code>http://localhost:300</code>，如图</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/react.png" alt="react-app"></p><p>为什么使用 <code>yarn start</code> 命令可以启动，原因在于 <code>package.json</code> 中的关键代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "react-scripts start",</span><br><span class="line">    "build": "react-scripts build",</span><br><span class="line">    "test": "react-scripts test",</span><br><span class="line">    "eject": "react-scripts eject"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是 <code>npm</code> 还是 <code>yarn</code>，相应的命令都会在 <code>scripts</code> 字段中转换为相应的 <code>react-scripts</code> 命令</p><h2><span id="qi-dong-liu-cheng">启动流程</span><a href="#qi-dong-liu-cheng" class="header-anchor"></a></h2><p>以下为 React 项目简单结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">my-app</span><br><span class="line">├── README.md</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── .gitignore</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── manifest.json</span><br><span class="line">└── src</span><br><span class="line">    ├── App.css</span><br><span class="line">    ├── App.js</span><br><span class="line">    ├── App.test.js</span><br><span class="line">    ├── index.css</span><br><span class="line">    ├── index.js</span><br><span class="line">    ├── logo.svg</span><br><span class="line">    └── serviceWorker.js</span><br></pre></td></tr></table></figure><p>通过项目结构，我们慢慢了解下，React 的启动流程。</p><p><strong>启动程序</strong></p><p>首先这是一个 Node 项目，所以默认的启动程序为 <code>src/index.js</code> 文件。</p><p>通过文件中的关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App from <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p>可以看到，<code>ReactDOM</code> 将 <code>&lt;App /&gt;</code> 渲染到 <code>document.getElementById(&#39;root&#39;)</code> 中，<code>root</code> 是从 <code>public/index.html</code> 获取的。</p><p><strong>渲染程序</strong></p><p>查看 <code>App.js</code> 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> logo from <span class="string">'./logo.svg'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;header className=<span class="string">"App-header"</span>&gt;</span><br><span class="line">          &lt;img src=&#123;logo&#125; className=<span class="string">"App-logo"</span> alt=<span class="string">"logo"</span> /&gt;</span><br><span class="line">          &lt;p&gt;</span><br><span class="line">            Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class="line">          &lt;/p&gt;</span><br><span class="line">          &lt;a</span><br><span class="line">            className=<span class="string">"App-link"</span></span><br><span class="line">            href=<span class="string">"https://reactjs.org"</span></span><br><span class="line">            target=<span class="string">"_blank"</span></span><br><span class="line">            rel=<span class="string">"noopener noreferrer"</span></span><br><span class="line">          &gt;</span><br><span class="line">            Learn React</span><br><span class="line">          &lt;/a&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><code>class App</code> 是渲染页面组件，在类中可以通过各种内置或自己写的 JS 方法，对页面进行处理，并通过 <code>render()</code> 方法渲染页面，在这个方法内返回的是由 JSX 语法编写的代码，该语法我认为就是由 <code>js/html/css</code> 组合而成，所以 React 也是经常被认为是大逆不道将 三种语言写在同一个文件里。</p><h2><span id="gou-jian-jing-tai-ye-mian">构建静态页面</span><a href="#gou-jian-jing-tai-ye-mian" class="header-anchor"></a></h2><p>虽然是 Node 项目，但是作为前端页面，我们总要将它构建成静态页面，才能发布到服务中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn build</span><br></pre></td></tr></table></figure><p>运行后，会在根目录生成 <code>build</code> 文件夹，构建后的静态内容都在其中，结构如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">build</span><br><span class="line">├── asset-manifest.json</span><br><span class="line">├── favicon.ico</span><br><span class="line">├── index.html</span><br><span class="line">├── manifest.json</span><br><span class="line">├── precache-manifest.3351d163fa29e67b0b41ea8c711c59df.js</span><br><span class="line">├── service-worker.js</span><br><span class="line">└── static</span><br><span class="line">    ├── css</span><br><span class="line">    │   ├── main.27a53a32.chunk.css</span><br><span class="line">    │   └── main.27a53a32.chunk.css.map</span><br><span class="line">    ├── js</span><br><span class="line">    │   ├── 1.fa92c112.chunk.js</span><br><span class="line">    │   ├── 1.fa92c112.chunk.js.map</span><br><span class="line">    │   ├── main.881217d8.chunk.js</span><br><span class="line">    │   ├── main.881217d8.chunk.js.map</span><br><span class="line">    │   ├── runtime~main.229c360f.js</span><br><span class="line">    │   └── runtime~main.229c360f.js.map</span><br><span class="line">    └── media</span><br><span class="line">        └── logo.5d5d9eef.svg</span><br><span class="line"></span><br><span class="line">4 directories, 15 files</span><br></pre></td></tr></table></figure><p>页面入口为 <code>index.html</code>，静态文件在 <code>static</code> 文件夹中。</p><p>不过整个文件夹为什么只有一个 <code>index.html</code>，如果有多个页面，它可以完成任务吗？</p><h2><span id="wei-shi-me-ru-kou-zhi-you-index-html">为什么入口只有 index.html</span><a href="#wei-shi-me-ru-kou-zhi-you-index-html" class="header-anchor"></a></h2><p>首先回答上面那个问题，React 项目只需要一个 <code>index.html</code> 就可以访问所有页面。</p><p>为什么呢？要回答这个问题需要看下源码。</p><p>上边我们说到 <code>index.js</code> 加载了 <code>App.js</code> 渲染的页面，那么我们可以写多个类似 <code>App.js</code> 的“页面”，而 <code>index.js</code> 中可以通过访问地址来决定渲染那个页面。</p><p>当然这需要借助其他依赖包，不在我们本次讨论返回内。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/facebook/create-react-app&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;create-react-app&lt;/a&gt; 是 React 的入门项目，通过它可以窥见 React 项目的简单构成和基本语法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://wxnacy.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Golang 图片压缩</title>
    <link href="http://wxnacy.com/2019/01/15/go-nfnt-resize/"/>
    <id>http://wxnacy.com/2019/01/15/go-nfnt-resize/</id>
    <published>2019-01-15T09:22:56.000Z</published>
    <updated>2019-01-21T03:57:53.895Z</updated>
    
    <content type="html"><![CDATA[<p>Golang 图片压缩可以直接使用第三方包 <a href="https://github.com/nfnt/resize" target="_blank" rel="noopener">resize</a></p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#shi-yong">使用</a></li></ul><!-- tocstop --></div><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/nfnt/resize</span><br></pre></td></tr></table></figure><h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor"></a></h2><p><strong>导入</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/nfnt/resize"</span></span><br></pre></td></tr></table></figure><p><strong>语法</strong></p><p><code>resize</code> 有两个方法 <code>Resize</code> <code>Thumbnail</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resize.Resize(width, height <span class="keyword">uint</span>, img image.Image, interp resize.InterpolationFunction) image.Image</span><br><span class="line"><span class="comment">// resize.Resize 使用插值函数interp创建具有新尺寸（宽度，高度）的缩放图像。 如果宽度或高度设置为0，则将其设置为保留宽高比值。</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resize.Thumbnail(maxWidth, maxHeight <span class="keyword">uint</span>, img image.Image, interp resize.InterpolationFunction) image.Image</span><br><span class="line"><span class="comment">// resize.Thumbnail 缩小图像，将其纵横比保持为最大尺寸（maxWidth，maxHeight）。 如果原始尺寸小于提供的尺寸，它将返回原始图像。</span></span><br></pre></td></tr></table></figure><p><strong>简单使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/nfnt/resize"</span></span><br><span class="line">    <span class="string">"image/png"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file_path := <span class="string">"/Users/wxnacy/Downloads/react-app1.png"</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">    file, err := os.Open(file_path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decode jpeg into image.Image</span></span><br><span class="line">img, err := png.Decode(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize to width 1000 using Lanczos resampling</span></span><br><span class="line"><span class="comment">// and preserve aspect ratio</span></span><br><span class="line">    m := resize.Resize(<span class="number">800</span>, <span class="number">0</span>, img, resize.NearestNeighbor)</span><br><span class="line"></span><br><span class="line">out, err := os.Create(<span class="string">"react.NearestNeighbor.png"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> out.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// write new image to file</span></span><br><span class="line">png.Encode(out, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里边需要关注的是参数 <code>resize.InterpolationFunction</code>，它有几个值</p><ul><li>NearestNeighbor: <a href="https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation" target="_blank" rel="noopener">Nearest-neighbor interpolation</a></li><li><a href="https://en.wikipedia.org/wiki/Bilinear_interpolation" target="_blank" rel="noopener">Bilinear: Bilinear interpolation</a></li><li>Bicubic: <a href="https://en.wikipedia.org/wiki/Bicubic_interpolation" target="_blank" rel="noopener">Bicubic interpolation</a></li><li>MitchellNetravali: <a href="https://dl.acm.org/citation.cfm?id=378514" target="_blank" rel="noopener">Mitchell-Netravali interpolation</a></li><li>Lanczos2: <a href="https://en.wikipedia.org/wiki/Lanczos_resampling" target="_blank" rel="noopener">Lanczos resampling</a> with a=2</li><li>Lanczos3: <a href="https://en.wikipedia.org/wiki/Lanczos_resampling" target="_blank" rel="noopener">Lanczos resampling</a> with a=3</li></ul><p>这个压缩方式的展示效果可以从这里看到 <a href="https://github.com/nfnt/resize#downsizing-samples" target="_blank" rel="noopener">https://github.com/nfnt/resize#downsizing-samples</a></p><p>我挨个点连接进行，发现实在不想去纠结他们的具体原理，我只想比较压缩后的文件大小</p><p>我依次按照集中格式进行了压缩，我们对比下文件大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--@  1 wxnacy  staff  64633 Jan 18 18:01 react-app1.png</span><br><span class="line">-rw-r--r--@  1 wxnacy  staff  19857 Jan 19 17:13 react.NearestNeighbor.png</span><br><span class="line">-rw-r--r--   1 wxnacy  staff  23336 Jan 19 17:12 react.Bilinear.png</span><br><span class="line">-rw-r--r--   1 wxnacy  staff  25966 Jan 19 17:12 react.MitchellNetravali.png</span><br><span class="line">-rw-r--r--@  1 wxnacy  staff  27241 Jan 19 17:12 react.Lanczos2.png</span><br><span class="line">-rw-r--r--   1 wxnacy  staff  27356 Jan 19 17:12 react.Bicubic.png</span><br><span class="line">-rw-r--r--@  1 wxnacy  staff  31222 Jan 19 17:09 react.Lanczos3.png</span><br></pre></td></tr></table></figure><p>经过对比，<code>Lanczos3</code> 算法文件最大，图片最清晰，<code>NearestNeighbor</code> 最差</p><p>ok，这样我们就知道了，如果你追求清晰的或者文件大小该选什么类型了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang 图片压缩可以直接使用第三方包 &lt;a href=&quot;https://github.com/nfnt/resize&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;resize&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="http://wxnacy.com/tags/go/"/>
    
  </entry>
  
</feed>
