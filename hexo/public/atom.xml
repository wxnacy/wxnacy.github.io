<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-03-29T01:47:02.823Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OSSFS 阿里云 OSS 本地挂载工具</title>
    <link href="http://wxnacy.com/2019/03/29/ossfs/"/>
    <id>http://wxnacy.com/2019/03/29/ossfs/</id>
    <published>2019-03-29T01:47:02.000Z</published>
    <updated>2019-03-29T01:47:02.823Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/aliyun/ossfs" target="_blank" rel="noopener">ossfs</a> 能让您在Linux/Mac OS X 系统中把Aliyun OSS bucket 挂载到本地文件 系统中，您能够便捷的通过本地文件系统操作OSS 上的对象，实现数据的共享。</p></blockquote><a id="more"></a><h2><span id="wei-shi-me-xu-yao-yong-dao-zhe-ge-ruan-jian-ni">为什么需要用到这个软件呢？</span><a href="#wei-shi-me-xu-yao-yong-dao-zhe-ge-ruan-jian-ni" class="header-anchor"></a></h2><p>我的情况是这样的，公司微信 h5 的静态文件是放在 OSS 上的，因为代码框架选用的 React，正常情况下地址路由都是交给 <code>index.html</code> 处理的，但是返回的状态码是 404，而微信非常流氓的把 404 状态的地址都转到它自己的页面，使得页面无法正常显示，AWS 的 s3 可以设置 404 状态改为 200，不过 OSS 没有，所以我只能借助 ossfs 的同步功能，在本地加一个 nginx 反向代理，单独处理 404 的请求。</p><p>挂载了 ossfs，OSS 和本地挂在之间可以实现双向同步，这是很方便的。</p><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><p>首先从<a href="https://github.com/aliyun/ossfs/releases" target="_blank" rel="noopener">版本发布页面</a>下载合适的安装包</p><p><strong>Ubuntu 16.04</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/aliyun/ossfs/releases/download/v1.80.5/ossfs_1.80.5_ubuntu16.04_amd64.deb</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install gdebi-core</span><br><span class="line">$ sudo gdebi ossfs_1.80.5_ubuntu16.04_amd64.deb</span><br></pre></td></tr></table></figure><p><strong>CentOS 7</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/aliyun/ossfs/releases/download/v1.80.5/ossfs_1.80.5_centos7.0_x86_64.rpm</span><br><span class="line">$ sudo yum localinstall ossfs_1.80.5_centos7.0_x86_64.rpm</span><br></pre></td></tr></table></figure><h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor"></a></h2><p><strong>配置 bucket 信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> my-bucket:my-access-key-id:my-access-key-secret &gt; /etc/passwd-ossfs  <span class="comment"># 配置 key 和 secret</span></span><br><span class="line">$ chmod 640 /etc/passwd-ossfs   <span class="comment"># 修改文件权限</span></span><br><span class="line">$ ossfs my-bucket local_dir_path -ourl=my-oss-endpoint  <span class="comment"># 将 bucket mount 到本地文件夹</span></span><br></pre></td></tr></table></figure><p>如果机器使用了阿里云 ECS 实例，<code>-ourl</code> 可以使用内网 <code>endpoint</code> 来<strong>避免流量收费</strong>和<strong>提高速度</strong></p><p>挂载命令可以添加 <code>-f -d</code> 参数来让 ossfs 运行在前台并输出debug日志</p><p>你也可以使用 <a href="http://supervisord.org/" target="_blank" rel="noopener">supervisor</a> 来管理 ossfs 进程，方法详见 <a href="https://github.com/aliyun/ossfs/wiki/FAQ#18" target="_blank" rel="noopener">FAQ</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/aliyun/ossfs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ossfs&lt;/a&gt; 能让您在Linux/Mac OS X 系统中把Aliyun OSS bucket 挂载到本地文件 系统中，您能够便捷的通过本地文件系统操作OSS 上的对象，实现数据的共享。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://wxnacy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python 协程库 gevent</title>
    <link href="http://wxnacy.com/2019/03/28/gevent/"/>
    <id>http://wxnacy.com/2019/03/28/gevent/</id>
    <published>2019-03-27T16:01:35.000Z</published>
    <updated>2019-03-28T01:47:16.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/gevent/gevent" target="_blank" rel="noopener">gevent</a> 是一个基于 libev 的并发库。它为各种并发和网络相关的任务提供了整洁的API。</p></blockquote><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#yi-bu-zhi-xing">异步执行</a></li><li><a href="#yin-xing-jiao-chu-zhi-xing-quan">隐形交出执行权</a></li><li><a href="#hou-zi-bu-ding">猴子补丁</a></li><li><a href="#gevent-without-code">gevent without code</a></li></ul><!-- tocstop --></div><p>Python 中多线程的性能极差，替代它的另一种“并发”方式是协程。</p><p>Python 版本中协程一直在不断的进化</p><ul><li><code>yeild</code> python2.x</li><li><code>asynico + yield from</code> python3.4</li><li><code>asynico + await</code> python3.5</li></ul><p>而这个过程中，一直可以拿来就用的三方库就是 gevent</p><p>在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p><blockquote><p>在任何时刻，只有一个协程在运行。</p></blockquote><p>换句话说，协程并不会切换线程或进程（所以性能会比多线程高很多），而是在 IO 阻塞时，可以切换到其他的 Greenlet，等到适当时机再切换回来，这样减少阻塞浪费的时间，使其看起来像是在并发。所以协程可以解决 IO 密集的性能问题，而 CPU 密集则无能为力。</p><h2><span id="yi-bu-zhi-xing">异步执行</span><a href="#yi-bu-zhi-xing" class="header-anchor"></a></h2><p>首先安装 gevent</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install gevent</span><br></pre></td></tr></table></figure><p>我们来模拟程序的阻塞，使用 <code>gevent.sleep(0)</code> 主动让程序交出执行权。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_progress</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'[&#123;&#125;] Greenlet &#123;&#125; Process &#123;&#125; - Thread &#123;&#125;'</span>.format(</span><br><span class="line">        time.time(), gevent.getcurrent(), os.getpid(), threading.current_thread().ident))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print_func_progress()</span><br><span class="line">    print(<span class="string">'Running in foo'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'Explicit context switch to foo again'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print_func_progress()</span><br><span class="line">    print(<span class="string">'Explicit context to bar'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'Implicit context switch back to bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    gevent.joinall([</span><br><span class="line">        gevent.spawn(foo),</span><br><span class="line">        gevent.spawn(bar),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1553694796.1719072] Greenlet &lt;Greenlet at 0x10e9a4930: foo&gt; Process 2022 - Thread 4683818432</span></span><br><span class="line"><span class="comment"># Running in foo</span></span><br><span class="line"><span class="comment"># [1553694796.171974] Greenlet &lt;Greenlet at 0x10e9a4a60: bar&gt; Process 2022 - Thread 4683818432</span></span><br><span class="line"><span class="comment"># Explicit context to bar</span></span><br><span class="line"><span class="comment"># Explicit context switch to foo again</span></span><br><span class="line"><span class="comment"># Implicit context switch back to bar</span></span><br></pre></td></tr></table></figure><p>从打印结果中，可以看到无论是进程 <code>Process</code>，还是线程 <code>Thread</code>，整个过程都是没有变化的，所以再次确定了协程是单线程运行的。并且在运行过程中，协程在两个方法间切换，以减少阻塞浪费的时间。</p><h2><span id="yin-xing-jiao-chu-zhi-xing-quan">隐形交出执行权</span><a href="#yin-xing-jiao-chu-zhi-xing-quan" class="header-anchor"></a></h2><p>当我们的程序受限于网络的 IO 阻塞时，gevent 才能真正发挥实力，它提供了方法，可以隐形的交出上下文执行权，这样我们可以在不改变程序结构的情况下来实现协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent.monkey</span><br><span class="line">gevent.monkey.patch_socket()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_run_time</span><span class="params">(count, func, **kw)</span>:</span></span><br><span class="line">    b = timeit.default_timer()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        func(**kw)</span><br><span class="line">    print(func.__name__, <span class="string">'run &#123;&#125; times used &#123;&#125;s'</span>.format(count,</span><br><span class="line">        timeit.default_timer() -b ))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(pid)</span>:</span></span><br><span class="line">    print(<span class="string">'pid &#123;&#125; begin request url'</span>, pid)</span><br><span class="line">    response = requests.get(<span class="string">'http://baidu.com'</span>)</span><br><span class="line">    print(<span class="string">'pid &#123;&#125; get response status &#123;&#125;'</span>, pid, response.status_code)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronous</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">        fetch(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asynchronous</span><span class="params">()</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">        threads.append(gevent.spawn(fetch, i))</span><br><span class="line">    gevent.joinall(threads)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Synchronous:'</span>)</span><br><span class="line">print_func_run_time(<span class="number">1</span>, synchronous)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Asynchronous:'</span>)</span><br><span class="line">print_func_run_time(<span class="number">1</span>, asynchronous)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Synchronous:</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 0</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 0 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 1</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 1 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 2</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 2 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 3</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 3 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 4</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 4 200</span></span><br><span class="line"><span class="comment"># synchronous run 1 times used 0.13507633499102667s</span></span><br><span class="line"><span class="comment"># Asynchronous:</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 0</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 1</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 2</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 3</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 4</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 0 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 4 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 3 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 1 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 2 200</span></span><br><span class="line"><span class="comment"># asynchronous run 1 times used 0.03902721201302484s</span></span><br></pre></td></tr></table></figure><p>从结果中我们可以看到，使用 gevent 执行的程序，性能比顺序执行好了很多倍，而在功能函数中，我们也并没有主动交出执行权，这一些都归功于猴子补丁 <code>gevent.monkey</code></p><h2><span id="hou-zi-bu-ding">猴子补丁</span><a href="#hou-zi-bu-ding" class="header-anchor"></a></h2><p>猴子补丁(monkey patching) 得以让 gevent 变得更加强大。上面的代码中我们用到了 <code>gevent.monkey.patch_socket()</code>，它修改了 Python 的 socket 标准库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> socket</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>socket.socket</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">socket</span>.<span class="title">socket</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">from</span> <span class="title">gevent</span> <span class="title">import</span> <span class="title">monkey</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">monkey</span>.<span class="title">patch_socket</span><span class="params">()</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">socket</span>.<span class="title">socket</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">gevent</span>.<span class="title">_socket3</span>.<span class="title">socket</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>Python的运行环境允许我们在运行时修改大部分的对象，包括模块，类甚至函数。所以猴子补丁的实现原理很简单，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.__name__</span><br><span class="line"><span class="string">'json'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">patch_json</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    json.__name__ = <span class="string">'wjson'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>patch_json()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.__name__</span><br><span class="line"><span class="string">'wjson'</span></span><br></pre></td></tr></table></figure><p>在这种情况下，gevent能够 修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。通常情况下我们只需要调用 <code>gevent.monkey.patch_all()</code>，它可以修改所有可以兼容的模块</p><p><code>patch_all()</code> 方法语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_all</span><span class="params">(socket=True, dns=True, time=True, select=True, thread=True, os=True, ssl=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              httplib=False, # Deprecated, to be removed.</span></span></span><br><span class="line"><span class="function"><span class="params">              subprocess=True, sys=False, aggressive=True, Event=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              builtins=True, signal=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              queue=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              **kwargs)</span>:</span></span><br></pre></td></tr></table></figure><p>如果不想修改某个模块，直接传参即可，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch_all(socket=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>或者在该方法之后导入，让原始模块覆盖掉 monkey 的修改即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>monkey.patch_all()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> select</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select.select</span><br><span class="line">&lt;function select at <span class="number">0x100e40f28</span>&gt;</span><br></pre></td></tr></table></figure><h2><span id="gevent-without-code">gevent without code</span><a href="#gevent-without-code" class="header-anchor"></a></h2><p>猴子补丁如此厉害，好像可以不用主动写 gevent 代码就可以实现。其实真的可以不用任何 gevent 代码，就可以让程序实现协程，只需要使用可以调用 gevent 的容器来启动程序即可。</p><p>我们来使用 gunicorn 来启动一个 Flask 程序。</p><p>如果你不了解 gunicorn，可以看我的这篇文章<a href="/2017/08/15/python-2017-08-15-gunicorn-run/">使用 gunicorn 启动你的项目</a></p><p>安装模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install gunicorn</span><br><span class="line">$ pip install flask</span><br></pre></td></tr></table></figure><p>编辑文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch gevent_without_code.py</span><br><span class="line">$ vim gevent_without_code.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">print(socket.socket)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/for')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"for"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/bar')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><p>不使用 gevent 启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gunicorn gevent_without_code:app</span><br><span class="line"></span><br><span class="line">[2019-03-27 23:06:53 +0800] [53872] [INFO] Starting gunicorn 19.7.1</span><br><span class="line">[2019-03-27 23:06:53 +0800] [53872] [INFO] Listening at: http://127.0.0.1:8000 (53872)</span><br><span class="line">[2019-03-27 23:06:53 +0800] [53872] [INFO] Using worker: sync</span><br><span class="line">[2019-03-27 23:06:53 +0800] [53932] [INFO] Booting worker with pid: 53932</span><br><span class="line">&lt;class <span class="string">'socket.socket'</span>&gt;</span><br><span class="line">[2019-03-27 23:06:56 +0800] [53872] [INFO] Handling signal: winch</span><br></pre></td></tr></table></figure><p>gunicorn 默认启动一个 8000 端口的 web 程序，我们有两个接口 <code>/for</code> 强制睡眠 4 秒钟，<code>/bar</code> 直接返回结果</p><p>这时候我们先访问 <code>/for</code> 在访问 <code>/bar</code> 会发生阻塞</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/gevent1.gif" alt="gevent1"></p><p><code>/bar</code> 需要等待 <code>/for</code> 返回结果后才能执行，这显然不是一个健康的程序。我们试试使用 gevent。</p><p><code>&lt;ctrl&gt; + c</code> 停掉程序，重新启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gunicorn gevent_without_code:app -k gevent</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63766] [INFO] Starting gunicorn 19.7.1</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63766] [INFO] Listening at: http://127.0.0.1:8000 (63766)</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63766] [INFO] Using worker: gevent</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63826] [INFO] Booting worker with pid: 63826</span><br><span class="line">&lt;class <span class="string">'gevent._socket3.socket'</span>&gt;</span><br></pre></td></tr></table></figure><p>再次访问两个接口，效果非常明显</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/gevent2.gif" alt="gevent2"></p><p>当 <code>/for</code> 阻塞时，gevent 直接跳过执行 <code>/bar</code>，等阻塞过后，在继续执行 <code>/for</code>。</p><p>这里我们一句 gevent 代码都没写，那它是什么实现的呢？</p><p>如果你留意刚才的启动日志，会发现我们代码有句 <code>print(socket.socket)</code>，在使用 gevent 前后是有不同的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;class <span class="string">'socket.socket'</span>&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&lt;class <span class="string">'gevent._socket3.socket'</span>&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>就像我们上面讲到的那样，gevent 在这里隐形的调用了 <code>gevent.monkey.patch_all()</code> 方法，使得相关的程序都自动变成了协程可调用的状态。</p><p>不管你代码写的怎么样，用 gevent 来启动你的项目吧，一定会让你觉得物有所值。</p><ul><li><a href="https://github.com/wxnacy/study/tree/master/python/gevent_demo" target="_blank" rel="noopener">本文 demo 源码</a></li><li><a href="https://github.com/gevent/gevent" target="_blank" rel="noopener">gevent 源码</a></li><li><a href="http://hhkbp2.github.io/gevent-tutorial/" target="_blank" rel="noopener">gevent 程序员指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gevent/gevent&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gevent&lt;/a&gt; 是一个基于 libev 的并发库。它为各种并发和网络相关的任务提供了整洁的API。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 访问中文文档</title>
    <link href="http://wxnacy.com/2019/03/27/python-doc-zh/"/>
    <id>http://wxnacy.com/2019/03/27/python-doc-zh/</id>
    <published>2019-03-27T06:42:32.000Z</published>
    <updated>2019-03-27T07:11:12.743Z</updated>
    
    <content type="html"><![CDATA[<p>今天使用中文 Google 时，以外发现了 Python 的中文文档，地址： <a href="https://docs.python.org/zh-cn" target="_blank" rel="noopener">https://docs.python.org/zh-cn</a></p><a id="more"></a><p>它会默认跳转到 Python 3.7 的文档</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/python-doc-zh_1411_705.png" alt="python"></p><p>有意思的是，如果使用地址：<a href="https://docs.python.org" target="_blank" rel="noopener">https://docs.python.org</a> 打开文档，左上角是看不到 <code>zh-cn</code> 选项的，大概是官方认为还没到直接开发的地步，因为确实很多东西还没做好。</p><p>比如搜索功能，现在还是只能搜索英文，如何的中文信息都搜索不到。</p><p>很多文档也还保留了大量的英文内容。</p><p>不过这不影响，一些基础模块的查看，毕竟有和没有是两个概念，这对很多初学者也是很重要的。</p><!-- 现在文档有 `2.7` `3.5` `3.6` `3.7` `3.8` 多个版本 --><p>文档左侧可以跳转其他版本，但是有个坑，直接点过去依然进入的是英文页面，我们需要<br>修改下地址，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.python.org/3.6/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.python.org/zh-cn/3.6/</span><br></pre></td></tr></table></figure><p>但是 <code>3.5</code> 版本修改后是 404，说明官方还完全没有开始这个版本的翻译工作，这里也是希望官方可以尽快完善。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天使用中文 Google 时，以外发现了 Python 的中文文档，地址： &lt;a href=&quot;https://docs.python.org/zh-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/zh-cn&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 计时器 timeit</title>
    <link href="http://wxnacy.com/2019/03/26/python-timeit/"/>
    <id>http://wxnacy.com/2019/03/26/python-timeit/</id>
    <published>2019-03-26T14:10:02.000Z</published>
    <updated>2019-03-26T14:10:02.111Z</updated>
    
    <content type="html"><![CDATA[<p>网上很多帖子讨论 Python 中计时用 <code>time.clock()</code> 还是用 <code>time.time()</code>。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#time-clock-vs-time-time">time.clock() vs time.time()</a></li><li><a href="#timeit">timeit</a></li><li><a href="#ming-ling-xing-yu-fa">命令行语法</a></li></ul><!-- tocstop --></div><h2><span id="time-clock-vs-time-time">time.clock() vs time.time()</span><a href="#time-clock-vs-time-time" class="header-anchor"></a></h2><ul><li><code>time.clock()</code> 计算的是 CPU 的时间，在 windows 平台上精度比较高</li><li><code>time.time()</code> 计算的是程序的运行时间，会受到机器负载的影响，除了 windows 以外的平台精度比较高</li></ul><p>所以我们可以按照平台来使用不同的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.platform == <span class="string">"win32"</span>:</span><br><span class="line">    <span class="comment"># On Windows, the best timer is time.clock()</span></span><br><span class="line">    default_timer = time.clock</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># On most other platforms the best timer is time.time()</span></span><br><span class="line">    default_timer = time.time</span><br></pre></td></tr></table></figure><p>或者呢，直接使用 <code>timeit</code> 模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">b = timeit.default_timer()</span><br><span class="line"><span class="comment"># to some</span></span><br><span class="line">e = timeit.default_timer()</span><br><span class="line">print(e - b)</span><br></pre></td></tr></table></figure><p><code>timeit.default_timer()</code> 可以自动选择当前平台适合的计时器，因为它的源代码就是上面那段判断代码。</p><p>下面我们重点来介绍下 <code>timeit</code> 模块</p><p><code>timeit</code> 模块提供了一种简单的方法来计算一小段Python代码。 它既有命令行界面，也有可调用界面。 它避免了许多用于测量执行时间的常见陷阱。</p><h2><span id="timeit">timeit</span><a href="#timeit" class="header-anchor"></a></h2><p><strong>命令行使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m timeit <span class="string">'"-".join(str(n) for n in range(100))'</span></span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">40.3</span> usec per loop</span><br></pre></td></tr></table></figure><p>默认情况下，命令行对小段代码，重复执行三个循环，每个循环执行 10000 次，其中最好的用了 40.3 秒</p><p><strong>代码块中使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># attribute is missing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"""\</span></span><br><span class="line"><span class="string"><span class="meta">... </span>try:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    str.__nonzero__</span></span><br><span class="line"><span class="string"><span class="meta">... </span>except AttributeError:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    pass</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(s)</span><br><span class="line"><span class="number">0.5832341330096824</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(s, number=<span class="number">1000</span>)</span><br><span class="line"><span class="number">0.000628526002401486</span></span><br></pre></td></tr></table></figure><p><code>number</code> 不指定时，默认为 <code>default_number = 1000000</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.repeat(s)</span><br><span class="line">[<span class="number">0.5949273270089179</span>, <span class="number">0.6405833000026178</span>, <span class="number">0.5868908820120851</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.repeat(s, repeat=<span class="number">4</span>)</span><br><span class="line">[<span class="number">0.5963048749981681</span>, <span class="number">0.5834796829876723</span>, <span class="number">0.5749933830084046</span>, <span class="number">0.5814367970015155</span>]</span><br></pre></td></tr></table></figure><p>增加重复次数，使用 <code>repeat()</code> 方法，不指定 <code>repeat</code> 时，默认 <code>default_repeat = 3</code></p><h2><span id="ming-ling-xing-yu-fa">命令行语法</span><a href="#ming-ling-xing-yu-fa" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m timeit [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement ...]</span><br></pre></td></tr></table></figure><ul><li><code>-n N, --number=N</code> 执行 <code>statement</code> 的次数</li><li><code>-r N, --repeat=N</code> 循环的重复次数，默认：3</li><li><code>-s S, --setup=S</code> 最初要执行的语句，默认：pass</li><li><code>-t, --time</code> 使用 <code>time.time()</code> 计时，在 windows 以外平台默认使用该模式</li><li><code>-c, --clock</code> 使用 <code>time.clock()</code> 计时，在 windows 平台默认使用该模式</li><li><code>-v, --verbose</code> 打印原始计时结果，得到更多数字精度</li><li><code>-h, --help</code> 帮助信息</li></ul><p>当 <code>-n</code> 不指定时，程序会自动执行 10 的倍数，使执行时间不少于 0.2 秒</p><p><code>-s</code> 可以执行一段前置代码，这在很多场景是很有用的</p><p><strong>命令行中使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m timeit -s <span class="string">'text = "sample string"; char = "g"'</span>  <span class="string">'char in text'</span></span><br><span class="line">10000000 loops, best of 3: 0.0877 usec per loop</span><br></pre></td></tr></table></figure><p><strong>代码块中使用</strong></p><p>在代码快中，这个参数更有用处，我们不必把代码都写在字符串中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Stupid test function"""</span></span><br><span class="line">    L = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        L.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> timeit</span><br><span class="line">    print(timeit.timeit(<span class="string">"test()"</span>, setup=<span class="string">"from __main__ import test"</span>))</span><br></pre></td></tr></table></figure><ul><li>文档：<a href="https://docs.python.org/2/library/timeit.html" target="_blank" rel="noopener">https://docs.python.org/2/library/timeit.html</a></li><li>源代码：<a href="https://github.com/python/cpython/blob/2.7/Lib/timeit.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/2.7/Lib/timeit.py</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上很多帖子讨论 Python 中计时用 &lt;code&gt;time.clock()&lt;/code&gt; 还是用 &lt;code&gt;time.time()&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>adb 如何连接夜神模拟器</title>
    <link href="http://wxnacy.com/2019/03/25/adb-connect-yeshen/"/>
    <id>http://wxnacy.com/2019/03/25/adb-connect-yeshen/</id>
    <published>2019-03-25T07:16:27.000Z</published>
    <updated>2019-03-25T07:23:11.548Z</updated>
    
    <content type="html"><![CDATA[<p>夜神模拟器无法自动出现在 <code>adb devices</code> 列表中，需要先打开开发者模式</p><a id="more"></a><p>步骤如下：</p><ul><li>点击<code>设置</code> -》<code>关于平板电脑</code> -》连续点击 5 次版本号，进入开发者模式</li><li>重新进入设置，滑到最下边，进入开发者模式，并打开 USB 调试模式</li><li>链接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb connect 127.0.0.1:62001</span><br></pre></td></tr></table></figure><ul><li>查看</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;夜神模拟器无法自动出现在 &lt;code&gt;adb devices&lt;/code&gt; 列表中，需要先打开开发者模式&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wxnacy.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 Redis watch 完成秒杀活动防止超卖 demo</title>
    <link href="http://wxnacy.com/2019/03/17/python-redis-watch/"/>
    <id>http://wxnacy.com/2019/03/17/python-redis-watch/</id>
    <published>2019-03-17T02:49:48.000Z</published>
    <updated>2019-03-17T02:49:48.511Z</updated>
    
    <content type="html"><![CDATA[<p>在做类似抢购活动的程序，我们通常会使用“乐观锁”思路，既保证库存不会超卖，也能够应付大并发的情况，Redis 中 watch 就可以实现“乐观锁”。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>Redis 中的事务 <code>multi/exec</code> 可以保证数据的原子性，但不能像 Mysql 那样在事务中出错回滚数据，而用 <code>watch</code> 来监听数据，就可以实现类似的功能。</p><p>先用 <code>watch</code> 监听后，在接下来事务的过程，如果数据被修改，则在执行 <code>exec</code> 时，则会报错，我们可以根据业务选择重试和返回结果。</p><p>Python 中通过管道 Pipeline 来实现 Redis 事务相关操作。</p><p><strong>初始化线程池</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接池</span></span><br><span class="line">pool = redis.ConnectionPool(host = <span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 初始化 redis</span></span><br><span class="line">r = redis.Redis(connection_pool = pool)</span><br></pre></td></tr></table></figure><p><strong>初始化管道</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe = r.pipeline()</span><br></pre></td></tr></table></figure><p><strong>使用事务</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">KEY = <span class="string">'count'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pipe.watch(KEY)         <span class="comment"># 监听库存</span></span><br><span class="line">    pipe.multi()            <span class="comment"># 开始事务</span></span><br><span class="line">    pipe.set(KEY, <span class="number">2</span>)        <span class="comment"># 执行操作</span></span><br><span class="line">    pipe.execute()          <span class="comment"># 执行事务</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 事务执行过程中，如果数据被修改，则抛出异常，程序可以选择重试或退出</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    pipe.reset()            <span class="comment"># 重置管道，为重试做准备</span></span><br></pre></td></tr></table></figure><p>通过这些操作，我们可以先实现一个防止商品超卖的 demo。</p><p>代码位置 <a href="https://github.com/wxnacy/study/blob/master/python/redis_demo/watch_demo.py" target="_blank" rel="noopener">watch_demo.py</a></p><p><strong>运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ python watch_demo.py</span><br><span class="line">用户 0 抢购成功，商品剩余 9</span><br><span class="line">用户 1 抢购成功，商品剩余 8</span><br><span class="line">用户 2 抢购失败，重试一次</span><br><span class="line">用户 3 抢购成功，商品剩余 7</span><br><span class="line">用户 5 抢购失败，重试一次</span><br><span class="line">用户 4 抢购失败，重试一次</span><br><span class="line">用户 2 抢购失败，重试一次</span><br><span class="line">用户 6 抢购失败，重试一次</span><br><span class="line">用户 7 抢购失败，重试一次</span><br><span class="line">用户 9 抢购失败，重试一次</span><br><span class="line">用户 8 抢购成功，商品剩余 6</span><br><span class="line">用户 10 抢购成功，商品剩余 5</span><br><span class="line">用户 5 抢购成功，商品剩余 4</span><br><span class="line">用户 12 抢购失败，重试一次</span><br><span class="line">用户 6 抢购失败，重试一次</span><br><span class="line">用户 13 抢购成功，商品剩余 3</span><br><span class="line">用户 11 抢购失败，重试一次</span><br><span class="line">用户 14 抢购失败，重试一次</span><br><span class="line">用户 2 抢购失败，重试一次</span><br><span class="line">用户 4 抢购失败，重试一次</span><br><span class="line">用户 9 抢购成功，商品剩余 2</span><br><span class="line">用户 7 抢购失败，重试一次</span><br><span class="line">用户 12 抢购成功，商品剩余 1</span><br><span class="line">用户 2 抢购停止，商品卖完</span><br><span class="line">用户 6 抢购失败，重试一次</span><br><span class="line">用户 14 抢购失败，重试一次</span><br><span class="line">用户 4 抢购停止，商品卖完</span><br><span class="line">用户 11 抢购成功，商品剩余 0</span><br><span class="line">用户 7 抢购停止，商品卖完</span><br><span class="line">用户 6 抢购停止，商品卖完</span><br><span class="line">用户 14 抢购停止，商品卖完</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做类似抢购活动的程序，我们通常会使用“乐观锁”思路，既保证库存不会超卖，也能够应付大并发的情况，Redis 中 watch 就可以实现“乐观锁”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
      <category term="redis" scheme="http://wxnacy.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Shell 几种算术运算方式</title>
    <link href="http://wxnacy.com/2019/03/16/shell-calculation/"/>
    <id>http://wxnacy.com/2019/03/16/shell-calculation/</id>
    <published>2019-03-16T08:40:29.000Z</published>
    <updated>2019-03-16T08:40:29.518Z</updated>
    
    <content type="html"><![CDATA[<p>Shell 脚本中，我们可以使用几种方式来实现算数运算。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#expr">expr</a></li><li><a href="#xiao-gua-hao">小括号</a></li><li><a href="#zhong-gua-hao">中括号</a></li><li><a href="#let">let</a></li></ul><!-- tocstop --></div><h2><span id="expr">expr</span><a href="#expr" class="header-anchor"></a></h2><p>expr 本身是一个算数运算命令，Shell 可以直接拿到它的执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `expr 1 + 2`</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>expr 有很多缺点，比如：只能运算整数、数字和符号之间必须都有空格、<code>*</code> 号需要转义、无法使用次方运算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ expr 1+2</span><br><span class="line">1+2</span><br><span class="line"></span><br><span class="line">$ expr 1 +2</span><br><span class="line">expr: syntax error</span><br><span class="line"></span><br><span class="line">$ expr 1 \* 2</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">$ expr 1 + 2.3</span><br><span class="line">expr: not a decimal number: <span class="string">'2.3'</span></span><br></pre></td></tr></table></figure><h2><span id="xiao-gua-hao">小括号</span><a href="#xiao-gua-hao" class="header-anchor"></a></h2><p>下面我们来看 shell 本身的计算方式，第一个是小括号，这种方式需要把运算表达式用两层小括号包裹起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((1+2))</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">$ ((i=1+2))</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $((1 + 2.3))</span><br><span class="line">3.2999999999999998</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $((2 ** 3))  <span class="comment"># 计算三次方</span></span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>通过例子可以看到，这种方式比 <code>expr</code> 写起来更好更舒服，就是在计算浮点数字时会有精度损失。</p><h2><span id="zhong-gua-hao">中括号</span><a href="#zhong-gua-hao" class="header-anchor"></a></h2><p>中括号的方式必须加上 <code>$</code> 前缀，并不支持像小括号一样，在括号内赋值，其他与小括号无异。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $[1 + 2]</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $[2 ** 3]</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2><span id="let">let</span><a href="#let" class="header-anchor"></a></h2><p>let 用来指示运算表达式，也可以达到效果，但是同样的有很多缺点，比如运算符和数字不能有空格、不支持次方运算、浮点运算会忽略小数点部分、<code>*</code> 需要转义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ <span class="built_in">let</span> i = 1 + 2</span><br><span class="line">zsh: bad math expression: operand expected at =</span><br><span class="line"></span><br><span class="line">&gt; $ <span class="built_in">let</span> i=1+2</span><br><span class="line">&gt; $ <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt; $ <span class="built_in">let</span> i=1+2.3</span><br><span class="line">&gt; $ <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt; $ <span class="built_in">let</span> i=2**3</span><br><span class="line">zsh: no matches found: i=2**3</span><br><span class="line"></span><br><span class="line">&gt; $ <span class="built_in">let</span> i=1+2.6</span><br><span class="line">&gt; $ <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt; $ <span class="built_in">let</span> i=2\*3</span><br><span class="line">&gt; $ <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>经过对比可以发现，小括号和中括号的方式最好，两者只是书写存在细微差异，其他两个不建议使用。</p><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7231832.html" target="_blank" rel="noopener">SHELL脚本–expr命令全解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shell 脚本中，我们可以使用几种方式来实现算数运算。&lt;/p&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://wxnacy.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Vim 报错：Caught deadly signal SEGV</title>
    <link href="http://wxnacy.com/2019/03/15/vim-error-caught-deadly-signal-segv/"/>
    <id>http://wxnacy.com/2019/03/15/vim-error-caught-deadly-signal-segv/</id>
    <published>2019-03-15T02:15:35.000Z</published>
    <updated>2019-03-15T02:56:31.291Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 系统大版本的升级总是会引来一些灾难，这次升级到 macOS Mojave 就有很多软件都用不了了，Vim 就是其中一个。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vim: Caught deadly signal SEGV</span><br><span class="line">Error detected <span class="keyword">while</span> processing <span class="keyword">function</span> 81_PollServerReady[7]..81_Pyeval:Vim: Finished.</span><br><span class="line"></span><br><span class="line">line 4:</span><br><span class="line">Exception MemoryError: MemoryError() <span class="keyword">in</span> &lt;module <span class="string">'threading'</span> from <span class="string">'/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.pyc'</span>&gt; ignored</span><br></pre></td></tr></table></figure><p>这不，每次启动都报这个错误，然后闪退程序。这就很尴尬了，我现在的开发工作都是在 Vim 中进行，用不了可咋整，网上的说法是因为 YouCompleteMe 插件导致的，需要重新安装 Vim 并使之支持 lua。</p><p>我使用 <code>vim --version</code> 查看，发现果然当前不支持</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim --version</span><br><span class="line">...</span><br><span class="line">-lua</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>按照网上教程安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew install vim --with-lua --with-override-system-vi</span><br><span class="line">...</span><br><span class="line">Error: invalid option: --with-lua</span><br></pre></td></tr></table></figure><p>结果报错，无效的参数？？？但是翻遍了 Google 给出的都是这个教程，继续搜索，发现现在新版本的 brew 认为 <code>--</code> 会让使用者困惑，所以慢慢去掉了这些参数，去的真及时，那你倒是把新的方法贴出来啊。</p><p>我只能暂时退而求其次把 YouCompleteMe 插件删掉好了，结果果然正常了，反正是能用了，就是补全功能差劲点，别扭点就别扭点吧，还要工作呢。</p><p>勉强用了一天，觉得还是不行，已经被 YouCompleteMe 惯出毛病了，转了一圈，发现只输入点后自动提示补全和写入文字自动补全时忽略大小写这两点，就没有一个插件可以代替，无奈还是要想办法解决这个问题。</p><p>既然 brew 不能带这些参数，那去掉试试好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install vim</span><br></pre></td></tr></table></figure><p>再次运行 <code>vim</code> 还是不行，我试着查看了下 vim 的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> vim</span><br><span class="line">/usr/bin/vim</span><br></pre></td></tr></table></figure><p>隐约觉得事情不太对，通常 brew 安装的软件二进制文件是在 <code>/usr/local/bin</code> 中的，查看了下发现果然没有链接过去，再次链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown $(whoami):wheel /usr/<span class="built_in">local</span>/share/man/de/man1</span><br><span class="line">$ brew link vim</span><br></pre></td></tr></table></figure><p>再次查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> vim</span><br><span class="line">/usr/bin/vim</span><br></pre></td></tr></table></figure><p>还是不行，查看环境变量发现 <code>$PATH</code> 中，<code>/usr/bin</code> 靠后，会覆盖的 <code>/usr/local/bin</code> 中的命令，再次调整</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim .bash_profile</span><br><span class="line"><span class="built_in">export</span> <span class="variable">$PATH</span>=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/bin</span><br><span class="line">$ <span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure><p>再次查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> vim</span><br><span class="line">/usr/<span class="built_in">local</span>/bin/vim</span><br></pre></td></tr></table></figure><p>搞定，查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim --version</span><br><span class="line">...</span><br><span class="line">+lua</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>好像有戏了，我怀着忐忑的心情，再次安装上 YouCompleteMe，打开 Vim，一切正常。</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/vim1_1440_720.png" alt="vim"></p><p><strong><em>有些时候就是这样，事情总会得到解决，我们可以逃避过去，也可以休息一下，然后重新挑战。</em></strong></p><ul><li><a href="https://github.com/Valloric/YouCompleteMe/issues/3165" target="_blank" rel="noopener">#3165</a></li><li><a href="https://blog.csdn.net/weixin_39569611/article/details/87278729" target="_blank" rel="noopener">brew - Error: invalid option</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac 系统大版本的升级总是会引来一些灾难，这次升级到 macOS Mojave 就有很多软件都用不了了，Vim 就是其中一个。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Python 列表的交集、并集、差集</title>
    <link href="http://wxnacy.com/2019/03/12/python-list-diff-inter/"/>
    <id>http://wxnacy.com/2019/03/12/python-list-diff-inter/</id>
    <published>2019-03-12T08:12:57.000Z</published>
    <updated>2019-03-12T08:26:16.097Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中列表的交集、并集、差集可以有两种方式，列表解析和 set 的函数</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>直接上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 列表的交集、并集、差集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rand_int_arr</span><span class="params">(length)</span>:</span></span><br><span class="line">    arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        r = random.randrange(<span class="number">19</span>)</span><br><span class="line">        arr.append(r)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''交集：使用列表解析'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set([i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i <span class="keyword">in</span> b]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''交集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).intersection(set(b)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''并集：使用列表相加'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a + b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''并集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).union(set(b)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''差集：使用列表解析'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set([i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> b]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''差集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).difference(set(b)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = rand_int_arr(<span class="number">10</span>)</span><br><span class="line">    b = rand_int_arr(<span class="number">10</span>)</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    r1 = intersection1(a, b)</span><br><span class="line">    print(<span class="string">'交集：使用列表解析'</span>, r1)</span><br><span class="line">    r2 = intersection2(a, b)</span><br><span class="line">    print(<span class="string">'交集：使用自带函数'</span>, r2)</span><br><span class="line">    r3 = union1(a, b)</span><br><span class="line">    print(<span class="string">'并集：使用列表相加'</span>, r3)</span><br><span class="line">    r4 = union2(a, b)</span><br><span class="line">    print(<span class="string">'并集：使用自带函数'</span>, r4)</span><br><span class="line">    r5 = difference1(a, b)</span><br><span class="line">    print(<span class="string">'差集：使用列表解析'</span>, r5)</span><br><span class="line">    r6 = difference2(a, b)</span><br><span class="line">    print(<span class="string">'差集：使用自带函数'</span>, r6)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># [5, 8, 13, 0, 7, 16, 13, 2, 2, 7]</span></span><br><span class="line">    <span class="comment"># [11, 10, 6, 17, 7, 13, 2, 16, 10, 13]</span></span><br><span class="line">    <span class="comment"># 交集：使用列表解析 [16, 2, 13, 7]</span></span><br><span class="line">    <span class="comment"># 交集：使用自带函数 [16, 2, 13, 7]</span></span><br><span class="line">    <span class="comment"># 并集：使用列表相加 [0, 2, 5, 6, 7, 8, 10, 11, 13, 16, 17]</span></span><br><span class="line">    <span class="comment"># 并集：使用自带函数 [0, 2, 5, 6, 7, 8, 10, 11, 13, 16, 17]</span></span><br><span class="line">    <span class="comment"># 差集：使用列表解析 [8, 0, 5]</span></span><br><span class="line">    <span class="comment"># 差集：使用自带函数 [0, 8, 5]</span></span><br></pre></td></tr></table></figure><p>除了并集可以通过列表相加实现，其他的如果不用函数就需要用到列表解析，下面我们来对比下速度</p><p>将 a 和 b 的长度改为 10000，将随机数的幅度也改了 10000，运行以下程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 列表的交集、并集、差集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rand_int_arr</span><span class="params">(length)</span>:</span></span><br><span class="line">    arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        r = random.randrange(<span class="number">10000</span>)</span><br><span class="line">        arr.append(r)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''交集：使用列表解析'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set([i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i <span class="keyword">in</span> b]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''交集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).intersection(set(b)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''并集：使用列表相加'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a + b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''并集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).union(set(b)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''差集：使用列表解析'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set([i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> b]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''差集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).difference(set(b)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = rand_int_arr(<span class="number">10000</span>)</span><br><span class="line">    b = rand_int_arr(<span class="number">10000</span>)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r1 = intersection1(a, b)</span><br><span class="line">    print(<span class="string">'交集：使用列表解析'</span>, time.clock() - begin)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r2 = intersection2(a, b)</span><br><span class="line">    print(<span class="string">'交集：使用自带函数'</span>, time.clock() - begin)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r3 = union1(a, b)</span><br><span class="line">    print(<span class="string">'并集：使用列表相加'</span>, time.clock() - begin)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r4 = union2(a, b)</span><br><span class="line">    print(<span class="string">'并集：使用自带函数'</span>, time.clock() - begin)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r5 = difference1(a, b)</span><br><span class="line">    print(<span class="string">'差集：使用列表解析'</span>, time.clock() - begin)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r6 = difference2(a, b)</span><br><span class="line">    print(<span class="string">'差集：使用自带函数'</span>, time.clock() - begin)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  交集：使用列表解析 0.9532590000000001</span></span><br><span class="line"><span class="comment">#  交集：使用自带函数 0.002062999999999926</span></span><br><span class="line"><span class="comment">#  并集：使用列表相加 0.0010879999999999779</span></span><br><span class="line"><span class="comment">#  并集：使用自带函数 0.0022370000000000445</span></span><br><span class="line"><span class="comment">#  差集：使用列表解析 0.9966799999999998</span></span><br><span class="line"><span class="comment">#  差集：使用自带函数 0.0014449999999999186</span></span><br></pre></td></tr></table></figure><p>通过这个结果看，列表解析和函数相比，还是函数的速度快很多，并且不是一个量级的，而在并集中列表相加则比函数要快一些，但是幅度并不大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中列表的交集、并集、差集可以有两种方式，列表解析和 set 的函数&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Android 远程调试命令 adb</title>
    <link href="http://wxnacy.com/2019/03/11/adb/"/>
    <id>http://wxnacy.com/2019/03/11/adb/</id>
    <published>2019-03-11T08:28:59.000Z</published>
    <updated>2019-03-12T03:04:51.242Z</updated>
    
    <content type="html"><![CDATA[<p>adb 是 Android 的远程调试命令，在 Android 打开 USB 调试模式或直接打开 ADB 功能，就可以用 shell 命令来控制系统。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#android-da-kai-usb-diao-shi">Android 打开 USB 调试</a></li><li><a href="#an-zhuang-adb">安装 adb</a><ul><li><a href="#mac-os-x">Mac OS X</a></li></ul></li><li><a href="#lian-jie-she-bei">链接设备</a></li><li><a href="#shi-yong-shell-ming-ling">使用 shell 命令</a></li><li><a href="#bao-guan-li">包管理</a></li><li><a href="#jin-cheng-guan-li">进程管理</a></li><li><a href="#geng-duo-ming-ling">更多命令</a></li></ul><!-- tocstop --></div><h2><span id="android-da-kai-usb-diao-shi">Android 打开 USB 调试</span><a href="#android-da-kai-usb-diao-shi" class="header-anchor"></a></h2><p>打开 Android 系统的开发者模式的通用模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.打开“设置”应用，然后滚动到底部。</span><br><span class="line">2.如果它没有“开发者选项”设置，请点击“关于手机”（或“关于平板电脑”），滚动到底部，然后点击内置版本号7次。</span><br><span class="line">3.返回并点击开发者选项。</span><br><span class="line">4.启用 USB 调试。</span><br></pre></td></tr></table></figure><h2><span id="an-zhuang-adb">安装 adb</span><a href="#an-zhuang-adb" class="header-anchor"></a></h2><h3><span id="mac-os-x">Mac OS X</span><a href="#mac-os-x" class="header-anchor"></a></h3><p>使用 brew 可以很简单的安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install android-platform-tools</span><br><span class="line">$ adb devices</span><br></pre></td></tr></table></figure><p>随后就可以使用 adb 命令，不需要在配置各种环境变量</p><p>其他安装方式见 <a href="https://stackoverflow.com/questions/17901692/set-up-adb-on-mac-os-x" target="_blank" rel="noopener">Set up adb on Mac OS X</a></p><h2><span id="lian-jie-she-bei">链接设备</span><a href="#lian-jie-she-bei" class="header-anchor"></a></h2><p><strong>启动服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb start-server</span><br></pre></td></tr></table></figure><p><strong>查看设备列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line"></span><br><span class="line">List of devices attached</span><br><span class="line">emulator-5554   device</span><br></pre></td></tr></table></figure><p><strong>关闭服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb <span class="built_in">kill</span>-server</span><br></pre></td></tr></table></figure><p><strong>链接设备</strong></p><p>当设备没有出现在设备列表中时，我们可以手动链接设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb connect &lt;ip&gt;:5555</span><br></pre></td></tr></table></figure><p>Android 的 uiautomator 模块默认使用了 5555 端口号</p><p>链接成功后，设备会出现在设备列表中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line"></span><br><span class="line">List of devices attached</span><br><span class="line">10.0.2.1:5555   device</span><br><span class="line">emulator-5554   device</span><br></pre></td></tr></table></figure><h2><span id="shi-yong-shell-ming-ling">使用 shell 命令</span><a href="#shi-yong-shell-ming-ling" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">root@x86:/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>当有一个设备时，默认链接，如果有多个设备，需要指定设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb -s 10.0.2.1:5555 shell</span><br><span class="line">root@x86:/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如果不想每次都手动指定，可以设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_SERIAL=<span class="string">"DC886B75"</span></span><br></pre></td></tr></table></figure><p>shell 登陆后即可使用常见的脚本命令，比如 <code>ls</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">root@x86:/ <span class="comment"># ls</span></span><br><span class="line">mnt</span><br><span class="line">lib</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果只是执行简单的命令，我们也可以直接在本地执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell ls</span><br><span class="line">mnt</span><br><span class="line">lib</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2><span id="bao-guan-li">包管理</span><a href="#bao-guan-li" class="header-anchor"></a></h2><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ adb install test.apk</span><br><span class="line">$ adb install -l test.apk     <span class="comment"># forward lock application</span></span><br><span class="line">$ adb install -r test.apk     <span class="comment"># replace existing application</span></span><br><span class="line">$ adb install -t test.apk     <span class="comment"># allow test packages</span></span><br><span class="line">$ adb install -s test.apk     <span class="comment"># install application on sdcard</span></span><br><span class="line">$ adb install -d test.apk     <span class="comment"># allow version code downgrade</span></span><br><span class="line">$ adb install -p test.apk     <span class="comment"># partial application install</span></span><br></pre></td></tr></table></figure><p><strong>卸载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb uninstall com.test.app</span><br><span class="line">$ adb uninstall -k com.test.app <span class="comment"># Keep the data and cache directories around after package removal.</span></span><br></pre></td></tr></table></figure><p><strong>查看包安装列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell pm list packages</span><br><span class="line">$ adb shell pm list packages -f   <span class="comment"># See their associated file.</span></span><br><span class="line">$ adb shell pm list packages -d   <span class="comment"># Filter to only show disabled packages.</span></span><br><span class="line">$ adb shell pm list packages -e   <span class="comment"># Filter to only show enabled packages.</span></span><br><span class="line">$ adb shell pm list packages -s   <span class="comment"># Filter to only show system packages.</span></span><br><span class="line">$ adb shell pm list packages -3   <span class="comment"># Filter to only show third party packages.</span></span><br><span class="line">$ adb shell pm list packages -i   <span class="comment"># See the installer for the packages.</span></span><br><span class="line">$ adb shell pm list packages -u   <span class="comment"># Also include uninstalled packages.</span></span><br><span class="line">$ adb shell pm list packages --user &lt;USER_ID&gt; <span class="comment"># The user space to query.</span></span><br></pre></td></tr></table></figure><p><strong>包路径</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell pm path com.android.phone</span><br><span class="line">package:/system/priv-app/TeleService/TeleService.apk</span><br></pre></td></tr></table></figure><p><strong>清除数据和缓存</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell pm clear com.test.abc</span><br></pre></td></tr></table></figure><h2><span id="jin-cheng-guan-li">进程管理</span><a href="#jin-cheng-guan-li" class="header-anchor"></a></h2><p><strong>启动应用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell 进入 Android</span><br><span class="line">$ am start -n &lt;package-name&gt;/&lt;package-name&gt;.&lt;activity-name&gt;</span><br></pre></td></tr></table></figure><p>一些系统应用打开方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日历</span></span><br><span class="line">$ am start -n com.android.calendar/com.android.calendar.LaunchActivity</span><br><span class="line"><span class="comment"># 闹钟</span></span><br><span class="line">$ am start -n com.android.alarmclock/com.android.alarmclock.AlarmClock</span><br><span class="line"><span class="comment"># 音乐和视频</span></span><br><span class="line">$ am start -n com.android.music/com.android.music.MusicBrowserActivity</span><br><span class="line">$ am start -n com.android.music/com.android.music.VideoBrowserActivity</span><br><span class="line">$ am start -n com.android.music/com.android.music.MediaPlaybackActivity</span><br><span class="line"><span class="comment"># 照相机</span></span><br><span class="line">$ am start -n com.android.camera/com.android.camera.Camera</span><br><span class="line"><span class="comment"># 浏览器</span></span><br><span class="line">$ am start -n com.android.browser/com.android.browser.BrowserActivity</span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">$ am start -a android.intent.action.VIEW -d  http://www.google.cn/</span><br><span class="line"><span class="comment"># 拨打电话</span></span><br><span class="line">$ am start -a android.intent.action.CALL -d tel:10086</span><br></pre></td></tr></table></figure><p>这里有个问题，我们可以通过 <code>pm</code> 命令查到 apk 的包名，但是 <code>activity</code> 就不方便知道了，我们希望只通过包名就能启动应用，从网上查到这个方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ am start -a android.intent.action.MAIN -n &lt;package-name&gt;</span><br></pre></td></tr></table></figure><p>但是这种方式，我在模拟器中只可以打开系统应用，第三方应用会报错，再次查找发现可以使用 <code>monkey</code> 命令来启动应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ monkey -p &lt;package-name&gt; -c android.intent.category.LAUNCHER 1</span><br></pre></td></tr></table></figure><p>经过测试，这种方式是比较方便打开各种应用</p><p><strong>杀掉应用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ am force-stop &lt;package-name&gt;</span><br></pre></td></tr></table></figure><p><strong>杀掉所有后台进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ am <span class="built_in">kill</span>-all</span><br></pre></td></tr></table></figure><h2><span id="geng-duo-ming-ling">更多命令</span><a href="#geng-duo-ming-ling" class="header-anchor"></a></h2><p><strong>推送文件到设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb push test.apk /data</span><br></pre></td></tr></table></figure><p><strong>拉取设备的文件到本地</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb pull /data/test.apk</span><br><span class="line">$ adb pull /data/test.apk ~/Downloads</span><br></pre></td></tr></table></figure><p><strong>查看设备 SSN 号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell getprop | grep ro.boot.serialno</span><br></pre></td></tr></table></figure><p><strong>参考</strong></p><ul><li><a href="http://adbshell.com/commands" target="_blank" rel="noopener">adb</a></li><li><a href="https://blog.csdn.net/u012041204/article/details/53957664" target="_blank" rel="noopener">Android使用ADB启动应用程序</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;adb 是 Android 的远程调试命令，在 Android 打开 USB 调试模式或直接打开 ADB 功能，就可以用 shell 命令来控制系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wxnacy.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Go 自动打开系统默认浏览器</title>
    <link href="http://wxnacy.com/2019/03/04/go-open-brower/"/>
    <id>http://wxnacy.com/2019/03/04/go-open-brower/</id>
    <published>2019-03-04T05:48:03.000Z</published>
    <updated>2019-03-04T05:48:03.181Z</updated>
    
    <content type="html"><![CDATA[<p>因为 Go 可以编译 <code>Windows</code> <code>Darwin</code> <code>Linux</code> 三个平台的二进制文件，如果编写一个 Web 项目，启动后可以自动打开浏览器，那就非常方便了。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>首先看下三个平台打开浏览器的命令</p><p><strong>Darwin</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ open http://baidu.com</span><br></pre></td></tr></table></figure><p><strong>Windows</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ start http://baidu.com</span><br></pre></td></tr></table></figure><p><strong>Linux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xdg-open http://baidu.com</span><br></pre></td></tr></table></figure><p>接下来需要 Go 能区分平台，这里需要 <code>runtime</code> 包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"runtime"</span></span><br><span class="line">platform := runtime.GOOS</span><br><span class="line">// darwin windows linux</span><br></pre></td></tr></table></figure><p>好接下来就可以写代码了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// 打开系统默认浏览器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os/exec"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> commands = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"windows"</span>: <span class="string">"start"</span>,</span><br><span class="line">    <span class="string">"darwin"</span>:  <span class="string">"open"</span>,</span><br><span class="line">    <span class="string">"linux"</span>:   <span class="string">"xdg-open"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(uri <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    run, ok := commands[runtime.GOOS]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"don't know how to open things on %s platform"</span>, runtime.GOOS)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmd := exec.Command(run, uri)</span><br><span class="line">    <span class="keyword">return</span> cmd.Start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Open(<span class="string">"http://baidu.com"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为 Go 可以编译 &lt;code&gt;Windows&lt;/code&gt; &lt;code&gt;Darwin&lt;/code&gt; &lt;code&gt;Linux&lt;/code&gt; 三个平台的二进制文件，如果编写一个 Web 项目，启动后可以自动打开浏览器，那就非常方便了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="http://wxnacy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go Web 框架 iris 简单入门</title>
    <link href="http://wxnacy.com/2019/03/01/go-iris-simple/"/>
    <id>http://wxnacy.com/2019/03/01/go-iris-simple/</id>
    <published>2019-03-01T09:22:15.000Z</published>
    <updated>2019-03-01T09:22:15.925Z</updated>
    
    <content type="html"><![CDATA[<p>作为后端开发，初识一门语言时，选一款合适的 Web 框架是很有必要的。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#xia-zai">下载</a></li><li><a href="#hello-world">Hello World</a></li><li><a href="#ri-zhi-shu-chu">日志输出</a></li><li><a href="#template-shi-yong">template 使用</a></li><li><a href="#geng-duo-de-method">更多的 method</a></li></ul><!-- tocstop --></div><p>经过这篇文章 <a href="https://studygolang.com/articles/11897?fr=sidebar" target="_blank" rel="noopener">6 款最棒的 Go 语言 Web 框架简介</a>的介绍，有理由相信 <a href="https://github.com/kataras/iris" target="_blank" rel="noopener">iris</a> 是目前最优秀的 Web 框架，今天简单了解下这个框架的使用。</p><h2><span id="xia-zai">下载</span><a href="#xia-zai" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u github.com/kataras/iris</span><br></pre></td></tr></table></figure><h2><span id="hello-world">Hello World</span><a href="#hello-world" class="header-anchor"></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/kataras/iris"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app *iris.Application</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app = iris.Default()</span><br><span class="line">    app.Get(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span> &#123;</span><br><span class="line">        ctx.JSON(iris.Map&#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"Hello World"</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// listen and serve on http://0.0.0.0:8080.</span></span><br><span class="line">    app.Run(iris.Addr(<span class="string">":8080"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化和路由配置都很简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">$ http :8080/hello</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 25</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Date: Thu, 28 Feb 2019 07:25:00 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"Hello World"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="ri-zhi-shu-chu">日志输出</span><a href="#ri-zhi-shu-chu" class="header-anchor"></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/kataras/iris"</span></span><br><span class="line">    <span class="string">"github.com/kataras/iris/middleware/logger"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app *iris.Application</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app = iris.Default()</span><br><span class="line">    app.Use(logger.New())</span><br><span class="line">    app.Logger().SetLevel(<span class="string">"debug"</span>)</span><br><span class="line">    app.Get(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span> &#123;</span><br><span class="line">        app.Logger().Debug(<span class="string">"Hello World"</span>)</span><br><span class="line">        app.Logger().Info(<span class="string">"Hello World"</span>)</span><br><span class="line">        app.Logger().Error(<span class="string">"Hello World"</span>)</span><br><span class="line">        ctx.JSON(iris.Map&#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"Hello World"</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// listen and serve on http://0.0.0.0:8080.</span></span><br><span class="line">    app.Run(iris.Addr(<span class="string">":8080"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="template-shi-yong">template 使用</span><a href="#template-shi-yong" class="header-anchor"></a></h2><p>使项目目录结构如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── main.go</span><br><span class="line">├── static</span><br><span class="line">│   └── hello.js</span><br><span class="line">└── templates</span><br><span class="line">    └── index.html</span><br></pre></td></tr></table></figure><p>注册 template 目录和匹配文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.RegisterView(iris.HTML(<span class="string">"./templates"</span>, <span class="string">".html"</span>))</span><br></pre></td></tr></table></figure><p>初始化静态文件目录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.StaticWeb(<span class="string">"static"</span>, <span class="string">"./static"</span>)</span><br></pre></td></tr></table></figure><p>传递 template 变量，并显示页面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.Get(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span> &#123;</span><br><span class="line">    ctx.ViewData(<span class="string">"name"</span>, <span class="string">"wxnacy"</span>)</span><br><span class="line">    ctx.View(<span class="string">"index.html"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">$ http :8080/index</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 129</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Thu, 28 Feb 2019 07:56:57 GMT</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  Hello wxnacy</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">$ http :8080/static/hello.js</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 51</span><br><span class="line">Content-Type: application/javascript; charset=UTF-8</span><br><span class="line">Date: Thu, 28 Feb 2019 07:57:33 GMT</span><br><span class="line">Last-Modified: Thu, Feb 28 2019 07:47:22 GMT</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hello</span></span>()&#123;</span><br><span class="line">  console.log(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整代码地址：<a href="https://github.com/wxnacy/study/tree/master/goland/src/iris_examples/mvc-templates" target="_blank" rel="noopener">https://github.com/wxnacy/study/tree/master/goland/src/iris_examples/mvc-templates</a></p><h2><span id="geng-duo-de-method">更多的 method</span><a href="#geng-duo-de-method" class="header-anchor"></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.Post(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;) -&gt; <span class="keyword">for</span> POST http method.</span><br><span class="line">app.Put(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"PUT"</span> http method.</span><br><span class="line">app.Delete(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"DELETE"</span> http method.</span><br><span class="line">app.Options(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"OPTIONS"</span> http method.</span><br><span class="line">app.Trace(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"TRACE"</span> http method.</span><br><span class="line">app.Head(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"HEAD"</span> http method.</span><br><span class="line">app.Connect(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"CONNECT"</span> http method.</span><br><span class="line">app.Patch(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"PATCH"</span> http method.</span><br><span class="line">app.Any(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;) <span class="keyword">for</span> all http methods.</span><br></pre></td></tr></table></figure><p><a href="https://github.com/iris-contrib/examples" target="_blank" rel="noopener">更多例子</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为后端开发，初识一门语言时，选一款合适的 Web 框架是很有必要的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="http://wxnacy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>简单了解非对称加密算法</title>
    <link href="http://wxnacy.com/2019/02/28/asymmetric-encryption/"/>
    <id>http://wxnacy.com/2019/02/28/asymmetric-encryption/</id>
    <published>2019-02-28T02:01:48.000Z</published>
    <updated>2019-02-28T02:01:48.056Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们要讲的是非对称加密算法。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#why">why</a></li><li><a href="#what">what</a></li><li><a href="#how">how</a></li></ul><!-- tocstop --></div><p>课程分三个步骤</p><ul><li>为什么要用到非对称加密算法(why)</li><li>什么是非对称加密算法(what)</li><li>如何用 Python 实现加密算法(how)</li></ul><h2><span id="why">why</span><a href="#why" class="header-anchor"></a></h2><p>非对称加密提供了数据加密和数字签名两个功能。</p><p>而这两个功能分别有更简单的实现方式对称加密和散列运算。</p><p>那为什么还需要非对称加密呢？</p><p>先来看一个例子。</p><p>小明和小红是一对恋人，他们分居上海和北京，路途遥远不便见面，只能通过网络联系，这种方式快捷方便，开始两人并没有觉得不妥。</p><p>有一天两人到了谈婚论嫁的年纪，开始讨论结婚事宜，说到了彩礼的事情。</p><p>小明很有安全意识，他觉得涉及到钱的问题，应该小心翼翼，网络并不安全，如果谈的是 5 万，结果在网络中被人篡改了，变成 10 万怎么办？他想到了使用数字签名的方式，将数据进行 MD5 加密，并将加密过的签名，一起发给小红，并让小红对数据再次使用 MD5 加密，并将自己计算的结果跟小明发过来的进行对比，一致则数据没有被篡改。</p><p>在这个方案下，两人安全的将结婚事宜谈妥，小红很高兴，想对小明说些悄悄话，但是她又不想让网络中其他人听到她说的是什么。她想到了数据加密的方式，她先将要说的话使用 AES 算法做对称加密，然后将加密后密文和加密使用的秘钥发给小明，然后小明使用秘钥对密文进行解密，即可看到小红要说的话。</p><p>然而事情真的像他们想的这么安全吗？</p><p>小明的签名算法必须是公开的，小红才能用相同的算法验证，只要是公开的，别人就可以使用相同的算法，先将明文篡改，再对新明文进行签名再发给小红，这样小红验证到的只是被篡改的数据。</p><p>同样的道理，小红的对称加密算法，想要让小明对其进行解密，必须将加密用的秘钥公开出来。这样小明可以解密，别人也可以解密。</p><p>那怎么解决呢？你会想不公开不就行了吗，小明自己写一个签名算法偷偷告诉小红，小红将加密的秘钥偷偷告诉小明。说起来简单，做起来难，怎么偷偷告诉？小明先坐飞机到北京告诉小红，然后每次发现算法有漏洞，修改算法后在坐飞机到北京？</p><p>没有必要，此时非对称加密可以出场了。</p><h2><span id="what">what</span><a href="#what" class="header-anchor"></a></h2><p>什么是非对称加密？</p><p>对称加密是用相同的秘钥对数据进行加解密，那非对称加密顾名思义就是用不同的秘钥对数据进行加解密。</p><p>非对称加密算法有两个秘钥，公有秘钥和私有秘钥，两个秘钥是一对。每个人都可以生成属于自己的公私钥，公钥可以公布给任何人知道，所以它也叫公开密钥算法，私钥只能自己保留，不能泄露。</p><p>现在我们再来看小明的问题，小明使用非对称加密算法做数字签名，他先使用私钥将明文做签名，然后将明文、签名和公钥一起发给小红，小红可以使用公钥对签名进行验证。此时其他及时拿到了公钥也无济于事，因为<strong><em>签名只能使用私钥</em></strong>。</p><p>而小红的问题也很简单，她可以使用小明的公钥对明文进行加密，再将密文发给小明，小明使用自己的私钥对数据进行解密，即可拿到明文。此时其他人及时拿到公钥和密文也无济于事，因为<strong><em>公钥加密的密文只能用对应的秘钥进行解密</em></strong></p><p>然后小红再生成自己的公私钥，双方互换公钥，各自保留私钥，加密和签名双管齐下，互发消息都可以做到非常安全。</p><p>总结一下</p><p>公钥用来加密，对应秘钥解密<br>私钥用来签名，对应公钥验证</p><h2><span id="how">how</span><a href="#how" class="header-anchor"></a></h2><p>下面我们来看看如何使用 Python 实现加密算法</p><p><strong>生成公私钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C your_email</span><br></pre></td></tr></table></figure><p><strong>安装依赖</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pycrypto</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><ul><li><a href="https://github.com/wxnacy/study/blob/master/python/crypto_demo/rsa_cipher.py" target="_blank" rel="noopener">加解密</a></li><li><a href="https://github.com/wxnacy/study/blob/master/python/crypto_demo/rsa_signature.py" target="_blank" rel="noopener">签名验证</a></li></ul><p><strong>youtube 视频</strong></p><iframe width="560" height="315" src="https://www.youtube.com/embed/OKIfTOEo7P0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><strong>youku 视频</strong></p><iframe height="498" width="510" src="http://player.youku.com/embed/XNDA2Nzg3NTY4MA==" frameborder="0" 'allowfullscreen'=""></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们要讲的是非对称加密算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://wxnacy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux Tab 命令提示时忽略大小写</title>
    <link href="http://wxnacy.com/2019/02/27/linux-caseignore/"/>
    <id>http://wxnacy.com/2019/02/27/linux-caseignore/</id>
    <published>2019-02-27T01:56:39.000Z</published>
    <updated>2019-02-27T02:01:37.183Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 环境如何不装 <code>zsh</code> 等更加智能的 bash 工具，通常在 Tab 键提示命令时都会区分大小写，这样很不方便，我们可以做点简单修改让它忽略大小写。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>默认情况下 <code>~</code> 目录下是没有 <code>.inputrc</code> 文件的，手动创建并赋值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'set completion-ignore-case on'</span> &gt;&gt; .inputrc</span><br></pre></td></tr></table></figure><p>然后退出终端，重新进入，这时命令行已经忽略大小写了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 环境如何不装 &lt;code&gt;zsh&lt;/code&gt; 等更加智能的 bash 工具，通常在 Tab 键提示命令时都会区分大小写，这样很不方便，我们可以做点简单修改让它忽略大小写。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Vim8 内置插件管理方案</title>
    <link href="http://wxnacy.com/2019/02/26/vim8-pack/"/>
    <id>http://wxnacy.com/2019/02/26/vim8-pack/</id>
    <published>2019-02-26T09:42:43.000Z</published>
    <updated>2019-02-26T10:05:43.418Z</updated>
    
    <content type="html"><![CDATA[<p>Vim8，更新到这个版本，Vim 终于有自己的插件管理方案，引入了 <code>packages</code> 的概念。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>如果你对 <a href="/2017/09/20/vim-plugin-pathogen/">pathogen</a> 了解的话，应该会很喜欢这种方案，跟它一样，你只需要将插件扔到指定的目录下，Vim 会自动加载这个插件。</p><p>假如你有插件 <code>nerdtree</code>，现在只需要在放在 <code>~/.vim/pack/vendor/start/</code> 目录下即可。</p><p>Vim8 会自动加载 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/start/</span><br></pre></td></tr></table></figure><p>目录下的插件，换句话说我也可以把它放在 <code>~/.vim/pack/foo/start/</code> 下，<code>*</code> 所代表的目录是任意值。</p><p>而那些我们不想自动加载的插件可以放到 <code>opt</code> 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/opt</span><br></pre></td></tr></table></figure><p>随后在 <code>~/.vimrc</code> 中使用 <code>packadd</code> 来手动加载插件，有应用场景如下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> foo_compiler_version &gt; <span class="number">34</span></span><br><span class="line">    packadd foo_new</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    packadd foo_old</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>我们可以根据某个编译版本来选择使用插件的版本。</p><p>查看文档 <code>:h packages</code> 获取更多信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vim8，更新到这个版本，Vim 终于有自己的插件管理方案，引入了 &lt;code&gt;packages&lt;/code&gt; 的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Mysql insert ... on duplicate key update 的用法及在 SQLAlchemy 中的使用</title>
    <link href="http://wxnacy.com/2019/02/24/mysql-insert-on-duplicate-key-update/"/>
    <id>http://wxnacy.com/2019/02/24/mysql-insert-on-duplicate-key-update/</id>
    <published>2019-02-24T04:09:12.000Z</published>
    <updated>2019-02-24T04:53:03.357Z</updated>
    
    <content type="html"><![CDATA[<p>在项目高并发时，很容易出现数据库插入相同数据的情况，虽然可以使用唯一索引避免插入相同数据，但是不断的程序报错也是我们也避免的。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#yu-fa">语法</a></li><li><a href="#sqlalchemy-zhong-de-shi-yong">SQLAlchemy 中的使用</a></li></ul><!-- tocstop --></div><h2><span id="yu-fa">语法</span><a href="#yu-fa" class="header-anchor"></a></h2><p>使用 <code>insert ... on duplicate key update ..</code> 语法可以避免这种情况，举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists `test`;</span><br><span class="line">create table `test` (</span><br><span class="line">`id` int(11) not null AUTO_INCREMENT,</span><br><span class="line">`name` varchar(32) not null default &apos;&apos;,</span><br><span class="line">`update_ts` timestamp not null default current_timestamp(),</span><br><span class="line">primary key (`id`)</span><br><span class="line">) engine=InnoDB default charset=utf8mb4;</span><br></pre></td></tr></table></figure><p>主键 <code>id</code> 是天然的唯一索引，我们插入重复数据时会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT INTO test (id, name) VALUES (1, &apos;wxnacy&apos;);</span><br><span class="line">&gt; INSERT INTO test (id, name) VALUES (1, &apos;wxnacy&apos;);</span><br><span class="line">Error 1062: Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos;</span><br></pre></td></tr></table></figure><p>查看数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">|------------------------------------</span><br><span class="line">| 1  | wxnacy | 2019-02-24 12:26:58 |</span><br></pre></td></tr></table></figure><p>下面我们来换个语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; insert into test (id, name) values (1, &apos;wxnacy&apos;) on duplicate key update update_ts = current_timestamp();</span><br><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line"></span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">|  1 | wxnacy | 2019-02-24 12:31:49 |</span><br><span class="line">+----+--------+---------------------+</span><br></pre></td></tr></table></figure><p><code>on duplicate key update</code> 前面是正常的插入语句，其后跟着的是当唯一索引冲突时，想要更新的数据。</p><p>再换个使用场景，如果我想让数据库中用户名是唯一的，则可以先建立唯一索引，在使用该语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; alter table test add unique index_name (name);</span><br><span class="line">&gt; insert into test (name) values (&apos;wenn&apos;) on duplicate key update update_ts = current_timestamp();</span><br><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">|  1 | wxnacy | 2019-02-24 12:31:49 |</span><br><span class="line">|  2 | wenn   | 2019-02-24 12:39:25 |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line"></span><br><span class="line">&gt; insert into test (name) values (&apos;wenn&apos;) on duplicate key update update_ts = current_timestamp();</span><br><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line"></span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">|  1 | wxnacy | 2019-02-24 12:31:49 |</span><br><span class="line">|  2 | wenn   | 2019-02-24 12:40:15 |</span><br><span class="line">+----+--------+---------------------+</span><br></pre></td></tr></table></figure><p>这样及保证了避免插入重复数据，同时程序也没有报错，我还可以根据 <code>update</code> 的数据来分析问题的根源。</p><h2><span id="sqlalchemy-zhong-de-shi-yong">SQLAlchemy 中的使用</span><a href="#sqlalchemy-zhong-de-shi-yong" class="header-anchor"></a></h2><p>这个功能需要 SQLAlchemy 1.2 版本以上才支持，官方的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.dialects.mysql <span class="keyword">import</span> insert</span><br><span class="line"></span><br><span class="line">insert_stmt = insert(my_table). \</span><br><span class="line">    values(id=<span class="string">'some_id'</span>, data=<span class="string">'some data to insert'</span>)</span><br><span class="line"></span><br><span class="line">on_conflict_stmt = insert_stmt.on_duplicate_key_update(</span><br><span class="line">    data=insert_stmt.inserted.data,</span><br><span class="line">    status=<span class="string">'U'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">conn.execute(on_conflict_stmt)</span><br></pre></td></tr></table></figure><p>析出的 sql 语句为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO my_table (id, data)</span><br><span class="line">VALUES (:id, :data)</span><br><span class="line">ON DUPLICATE KEY UPDATE data=VALUES(data), status=:status_1</span><br></pre></td></tr></table></figure><p>参考资料</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html" target="_blank" rel="noopener">INSERT … ON DUPLICATE KEY UPDATE Syntax</a></li><li><a href="https://docs.sqlalchemy.org/en/latest/changelog/migration_12.html#support-for-insert-on-duplicate-key-update" target="_blank" rel="noopener">Support for INSERT..ON DUPLICATE KEY UPDATE</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目高并发时，很容易出现数据库插入相同数据的情况，虽然可以使用唯一索引避免插入相同数据，但是不断的程序报错也是我们也避免的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="sqlalchemy" scheme="http://wxnacy.com/tags/sqlalchemy/"/>
    
      <category term="mysql" scheme="http://wxnacy.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Vimscript 判断文件是否存在</title>
    <link href="http://wxnacy.com/2019/02/21/vimscript-file-exists/"/>
    <id>http://wxnacy.com/2019/02/21/vimscript-file-exists/</id>
    <published>2019-02-21T10:28:52.000Z</published>
    <updated>2019-02-26T13:25:50.185Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>~/.vimrc</code> 我希望可以通过判断当前环境是否含有某插件，再加载相应的参数配置，此时可以通过判断文件是否存在来完成。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">filereadable</span>(<span class="string">'test.txt'</span>)    <span class="string">" 判断文件是否存在"</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'file is exists'</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>文件路径可以加上环境变量，用 <code>.</code> 链接</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME . <span class="string">'/.vim/bundle/jedi-vim/Makefile'</span></span><br></pre></td></tr></table></figure><p>或者使用 <code>expand()</code> 函数</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">expand</span>(<span class="string">"$HOME/.vim/bundle/jedi-vim/Makefile"</span>)</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">filereadable</span>(<span class="built_in">expand</span>(<span class="string">"$HOME/.vim/bundle/jedi-vim/Makefile"</span>))    <span class="string">" 判断文件是否存在"</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'jedi-vim is exists'</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;~/.vimrc&lt;/code&gt; 我希望可以通过判断当前环境是否含有某插件，再加载相应的参数配置，此时可以通过判断文件是否存在来完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>简单理解时间复杂度</title>
    <link href="http://wxnacy.com/2019/02/20/time-complexity/"/>
    <id>http://wxnacy.com/2019/02/20/time-complexity/</id>
    <published>2019-02-20T07:01:12.000Z</published>
    <updated>2019-02-20T07:01:12.608Z</updated>
    
    <content type="html"><![CDATA[<p>时间复杂度是一个及基础又重要，但却不那么显性的概念。对于很多程序员来说仿佛只会出现在面试题里，因为不了解它好像也不影响我开发程序。</p><p>时间复杂度是算法的一个重要概念，但并不是一句重要就可以逼着别人去学习的，首先我们要提出三问。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#di-yi-wen-wei-shi-me-yao-shi-yong-shi-jian-fu-za-du">第一问，为什么要使用时间复杂度</a></li><li><a href="#di-er-wen-shi-me-shi-shi-jian-fu-za-du">第二问，什么是时间复杂度</a></li><li><a href="#di-san-wen-ru-he-ji-suan-shi-jian-fu-za-du">第三问，如何计算时间复杂度</a></li><li><a href="#geng-duo-de-shi-jian-fu-za-du">更多的时间复杂度</a></li></ul><!-- tocstop --></div><h2><span id="di-yi-wen-wei-shi-me-yao-shi-yong-shi-jian-fu-za-du">第一问，为什么要使用时间复杂度</span><a href="#di-yi-wen-wei-shi-me-yao-shi-yong-shi-jian-fu-za-du" class="header-anchor"></a></h2><p>一个算法在证明<strong>数学正确性</strong>后，我们要关心它的运行时间，这是一个程序性能的重要指标。</p><p>算法的时间可以通过实际运行得到，但有两个缺点</p><ul><li>复杂的算法通过开发到运行后在又优化，流程会很长，整体操作时间长，很不方便</li><li>运行时间受硬件、软件的影响，这对我们评估算法本身存在影响</li></ul><p>我们更希望可以在运行前，或者在编写前就预估出可能执行的“时间”。</p><p>所以引入了<strong>时间复杂度</strong>的概念，时间复杂度不是计算算法运行时间，而是估算出算法的复杂度，是个量级的概念。我们可以通过可能出现的时间复杂度，来选择可以接受的算法。</p><h2><span id="di-er-wen-shi-me-shi-shi-jian-fu-za-du">第二问，什么是时间复杂度</span><a href="#di-er-wen-shi-me-shi-shi-jian-fu-za-du" class="header-anchor"></a></h2><blockquote><p><strong>时间频度</strong> 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p></blockquote><blockquote><p><strong>时间复杂度</strong> 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p></blockquote><p>简单总结为</p><ul><li><code>n</code> 为算法使用者可以传入的变量，通常时间复杂度受该参数影响。</li><li><code>T(n)</code> 算法的运行次数，次数随着 n 的变化，而变化。</li><li><code>O(f(n))</code> 算法运行次数变化的规律，也就是时间复杂度，以大写的 O 为符号标记。</li><li><code>f(n)</code> 时间复杂度的值，是个近似值。</li></ul><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure><p>执行一次 <code>Hello World</code> 语句，我们称为一次运算，这个算法的时间复杂度就是 <code>O(1)</code>，也称为常数阶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个算法里，<code>console.log(i);</code> 的执行次数，随着参数 <code>n</code> 的变化而变化，那么这个算法的时间复杂度为 <code>O(n)</code>，也称为线性阶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        console.log(i + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个算法里，<code>console.log(i + j);</code> 的执行次数为 <code>n * n</code>，那么时间复杂度就是 <code>O(n^2)</code>，也成为平方阶。</p><p>在后续的描述中，<strong><em><code>^</code> 符号代表后面跟的是上角标，<code>_</code> 符号代表后面跟着下角标。</em></strong></p><p>通过这几个例子，我们可以得到计算时间复杂度的三个步骤</p><ul><li>找出算法的基本运行语句</li><li>计算运行次数的量级</li><li>使用 O 将其标记起来</li></ul><h2><span id="di-san-wen-ru-he-ji-suan-shi-jian-fu-za-du">第三问，如何计算时间复杂度</span><a href="#di-san-wen-ru-he-ji-suan-shi-jian-fu-za-du" class="header-anchor"></a></h2><p>计算时间复杂度也就是计算函数 <code>f(n)</code> 的值，是一个<strong>量级</strong>，在复杂算法中，时间复杂度关心的是最大的量级。</p><p>计算方式有如下规则</p><ul><li>不受参数 <code>n</code> 影响的运算次数，我们用常量 <code>C</code> 表示，当算法有参数 <code>n</code> 时，<code>C</code> 可以忽略不计，否则用 <code>1</code> 代替。(常数变1，然后去常数，去常参)</li><li>不受 <code>for</code> 循环影响的运算次数，使用加减法计算，否则使用乘法计算。</li><li>在最后的计算公式中，我们使用最大量级的值，来代表整个算法的时间复杂度。（去低阶）</li></ul><p>举几个例子</p><p><strong>常量变 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"Hello World"</span>);     <span class="comment">// 1</span></span><br><span class="line">console.log(<span class="string">"Hello World"</span>);     <span class="comment">// 1</span></span><br><span class="line">console.log(<span class="string">"Hello World"</span>);     <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>可以推导出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = Θ(1 + 1 + 1) = 1 <span class="comment"># Θ 表示常量变1、去常数、去常参、去低阶</span></span><br><span class="line">T(n) = O(f(n)) = O(1)</span><br></pre></td></tr></table></figure><p><strong>去常数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"Hello World"</span>);     <span class="comment">// 1</span></span><br><span class="line">console.log(<span class="string">"Hello World"</span>);     <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;     <span class="comment">// n</span></span><br><span class="line">    console.log(<span class="string">"Hello World"</span>); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推导公式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = Θ(1 + 1 + n * 1) = Θ(2 + n) = n</span><br><span class="line">T(n) = O(f(n)) = O(n)</span><br></pre></td></tr></table></figure><p><strong>为什么可以去掉常量？</strong>，当 <code>n</code> 趋近无穷大时，所以的常量都可以忽略不计，时间复杂度只关心最大的量级，所以可以去掉常量。</p><p><strong>去常参</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"Hello World"</span>);         <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;         <span class="comment">// n</span></span><br><span class="line">    console.log(<span class="string">"Hello World "</span>);    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;         <span class="comment">// n</span></span><br><span class="line">    console.log(<span class="string">"Hello World "</span>);    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推导公式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = Θ(1 + n * 1 + n * 1) = Θ(1 + 2n) = n</span><br><span class="line">T(n) = O(f(n)) = O(n)</span><br></pre></td></tr></table></figure><p><strong>去低阶</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;         <span class="comment">// n</span></span><br><span class="line">    console.log(<span class="string">"Hello World "</span>);    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;         <span class="comment">// n - 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;     <span class="comment">// n - 1</span></span><br><span class="line">        console.log(<span class="string">"Hello World "</span>);<span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推导公式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = Θ(n * 1 + (n - 1) * (n - 1) * 1) = Θ(n + n * n) = Θ(n + n^2) = n^2</span><br><span class="line">T(n) = O(f(n)) = O(n)</span><br></pre></td></tr></table></figure><p><strong>为什么可以去低阶?</strong>，同样的道理，当 <code>n</code> 趋近无穷时，<code>n</code> 在 <code>n^2</code> 的量级面前不止一提，所以我们可以去低阶。</p><h2><span id="geng-duo-de-shi-jian-fu-za-du">更多的时间复杂度</span><a href="#geng-duo-de-shi-jian-fu-za-du" class="header-anchor"></a></h2><p>前面我提到了三种时间复杂度，分别为常数阶 <code>O(1)</code>、线性阶 <code>O(n)</code>、平方阶 <code>O(n^2)</code></p><p>常用的时间复杂度还有：对数阶 <code>O(log_2n)</code>、线性对数阶 <code>O(nlog_2n)</code>、立方阶 <code>O(n^3)</code>、k 次方阶 <code>O(n^k)</code>、指数阶 <code>O(2^n)/O(n!)</code></p><p><strong>对数阶例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">    i = i * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推导公式需要使用到对数，假设 <code>while</code> 运行的次数为 <code>k</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = 2^(k-1)</span><br><span class="line">k = log_2n + 1</span><br><span class="line">f(n) = Θ(1 + log_2n + 1) = log_2n</span><br><span class="line">T(n) = O(f(n)) = O(log_2n)</span><br></pre></td></tr></table></figure><p><strong>O(n!) 例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void nFacRuntimeFunc(int n) &#123;</span><br><span class="line">  <span class="keyword">for</span>(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">    nFacRuntimeFunc(n-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的算法时间复杂度由小到大依次为：<code>Ο(1)＜Ο(log_2n)＜Ο(n)＜Ο(nlog_2n)＜Ο(n^2)＜Ο(n^3)＜…＜Ο(2^n)＜Ο(n!)</code></p><ul><li>常数阶算法不包含任务循环语句和回调函数，我们不用担心此类算法的运算时间</li><li>对数阶、线性阶和次方阶，称为多项时间。通常包含循环语句，此类算法归为 <strong>P（Polynomial,多项式）类问题</strong></li><li>指数阶，称为指数时间。通常包含回调函数，此类算法归为 <strong>NP（Non-Deterministic Polynomial, 非确定多项式）问题</strong></li></ul><p>一般我们认为常数阶、对数阶、线性阶是可以接收的时间复杂度，因为次方阶和指数阶 <code>n</code> 的变量稍微变大，运行时间就成指数增加，让程序无法动弹。</p><p>通过这篇文章应该可以简单的了解时间复杂度，并可以计算常见的算法时间复杂度，但是仍需要不断的练习才可以熟练掌握。</p><p>参考资料</p><ul><li><a href="https://www.jianshu.com/p/f4cca5ce055a" target="_blank" rel="noopener">（数据结构）十分钟搞定时间复杂度（算法的时间复杂度）</a></li><li><a href="https://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="noopener">算法的时间复杂度和空间复杂度-总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间复杂度是一个及基础又重要，但却不那么显性的概念。对于很多程序员来说仿佛只会出现在面试题里，因为不了解它好像也不影响我开发程序。&lt;/p&gt;
&lt;p&gt;时间复杂度是算法的一个重要概念，但并不是一句重要就可以逼着别人去学习的，首先我们要提出三问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://wxnacy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Go 简单了解 interface</title>
    <link href="http://wxnacy.com/2019/02/19/go-interface/"/>
    <id>http://wxnacy.com/2019/02/19/go-interface/</id>
    <published>2019-02-19T07:08:51.000Z</published>
    <updated>2019-02-19T07:10:22.886Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中 interface 是很常用的，因为父类单继承的特性，interface 可以让类的实现更加灵活。</p><p>而同样在强类型的 GO 中，interface 也是必不可少的。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#interface-de-shi-xian">interface 的实现</a></li><li><a href="#pan-duan-interface-cun-chu-zhi-de-lei-xing">判断 interface 存储值的类型</a></li><li><a href="#shi-yong-interface-shi-xian-fan-xing">使用 interface 实现泛型</a></li></ul><!-- tocstop --></div><h2><span id="interface-de-shi-xian">interface 的实现</span><a href="#interface-de-shi-xian" class="header-anchor"></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface 是一种<strong>类型</strong>，可以包含 0 或更多的方法，如果一个类型实现了一个 interface 的所有方法，则它实现了该 interface，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// interface 的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">     <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IUser <span class="keyword">interface</span> &#123;</span><br><span class="line">    SetName(<span class="keyword">string</span>)</span><br><span class="line">    GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self User)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> self.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    self.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i IUser</span><br><span class="line">    i = &amp;User&#123;&#125;</span><br><span class="line">    i.SetName(<span class="string">"wxnacy"</span>)</span><br><span class="line">    fmt.Println(i.GetName())</span><br><span class="line">    <span class="comment">// wxnacy</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，因为 <code>SetName</code> 方法是在指针中实现的，所有 <code>i</code> 需要储存指针才可以实现 <code>struct</code> 中的所有方法</p><h2><span id="pan-duan-interface-cun-chu-zhi-de-lei-xing">判断 interface 存储值的类型</span><a href="#pan-duan-interface-cun-chu-zhi-de-lei-xing" class="header-anchor"></a></h2><p>使用 <code>i.(T)</code> 或 <code>i.(type)</code> 可以判断 interface 中储存的值，后者只能在 <code>switch</code> 中使用。</p><p>i 是 interface 类型的变量，T 代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> t, ok := i.(*User); ok &#123;</span><br><span class="line">    fmt.Println(t)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &amp;&#123;User&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> t := m.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> Man: &#123;</span><br><span class="line">        fmt.Println(<span class="string">"m is "</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        fmt.Println(<span class="string">"m is default"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m is  &#123;Man&#125;</span></span><br></pre></td></tr></table></figure><h2><span id="shi-yong-interface-shi-xian-fan-xing">使用 interface 实现泛型</span><a href="#shi-yong-interface-shi-xian-fan-xing" class="header-anchor"></a></h2><p>强类型语言可以实现类似 Java 的泛型是必不可少的，在 Go 中可以使用 interface 来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InArray</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;, array <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(index <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免通过编写重复代码实现方法的多态，我们可以使用 <code>interface{}</code> 来传入任意类型，<br>并使用 <code>reflect</code> 反射包来实现具体方法。</p><p>我们使用该特性，实现一个判断数组中是否包含某值的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 reflect 反射方法判断 val 是否包含在 array 中，如果包含返回索引位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InArray</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;, array <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">switch</span> reflect.TypeOf(array).Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.Slice: &#123;</span><br><span class="line">            arr := reflect.ValueOf(array)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; arr.Len(); i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> reflect.DeepEqual(val, arr.Index(i).Interface()) &#123;</span><br><span class="line">                    index = i</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(InArray(<span class="number">3</span>, arr))</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://golang.org/pkg/reflect" target="_blank" rel="noopener">reflact</a></li></ul><p>Demo 地址：<a href="https://github.com/wxnacy/study/tree/master/goland/src/interfaces" target="_blank" rel="noopener">https://github.com/wxnacy/study/tree/master/goland/src/interfaces</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 中 interface 是很常用的，因为父类单继承的特性，interface 可以让类的实现更加灵活。&lt;/p&gt;
&lt;p&gt;而同样在强类型的 GO 中，interface 也是必不可少的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="http://wxnacy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Python 单例的四种实现方式</title>
    <link href="http://wxnacy.com/2019/02/18/python-signletion/"/>
    <id>http://wxnacy.com/2019/02/18/python-signletion/</id>
    <published>2019-02-18T08:21:49.000Z</published>
    <updated>2019-02-18T08:35:37.121Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式中，单例模式是很常见的，今天总结下 Python 的几种实现方式。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#shi-yong-import">使用 import</a></li><li><a href="#shi-yong-new-fang-fa">使用 <strong>new</strong> 方法</a></li><li><a href="#shi-yong-zhuang-shi-qi">使用装饰器</a></li><li><a href="#shi-yong-yuan-lei">使用元类</a></li></ul><!-- tocstop --></div><h2><span id="shi-yong-import">使用 import</span><a href="#shi-yong-import" class="header-anchor"></a></h2><p><code>import</code> 是 Python 中的天然单例模式，我最先推荐这种方式。</p><p>创建两个文件 <code>signletion.py</code> <code>signletion_import.py</code>，文件内容如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: import 需要的部分</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">"new instance"</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, *args, **kw)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get class"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u = User()</span><br><span class="line">u.get()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: import 模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> singletion <span class="keyword">import</span> u</span><br><span class="line"></span><br><span class="line">u.get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># new instance</span></span><br><span class="line"><span class="comment"># get class</span></span><br><span class="line"><span class="comment"># get class</span></span><br></pre></td></tr></table></figure><p>运行结果只输出一次 <code>new instance</code>，代表只生成一个实例，创建单例成功，后续我们都用这种验证方式。</p><h2><span id="shi-yong-new-fang-fa">使用 <strong>new</strong> 方法</span><a href="#shi-yong-new-fang-fa" class="header-anchor"></a></h2><p>直接修改 <code>__new__</code> 方法，类似 Java 的实现方式，实际开发中，我们可以在父类中实现方法，并继承</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 使用 __new__ 方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singletion</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            print(<span class="string">"new instance"</span>)</span><br><span class="line">            cls._instance = super().__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingClass</span><span class="params">(Singletion)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get class"</span>)</span><br><span class="line"></span><br><span class="line">c = SingClass()</span><br><span class="line">c.get()</span><br><span class="line"></span><br><span class="line">c1 = SingClass()</span><br><span class="line">c1.get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># new instance</span></span><br><span class="line"><span class="comment"># get class</span></span><br><span class="line"><span class="comment"># get class</span></span><br></pre></td></tr></table></figure><h2><span id="shi-yong-zhuang-shi-qi">使用装饰器</span><a href="#shi-yong-zhuang-shi-qi" class="header-anchor"></a></h2><p>装饰器是比较 Python 的方式，内部实现跟 <code>__new__</code> 很像，判断已经有实例则不再生成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 装饰器模式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singletion</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instance = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instance:</span><br><span class="line">            print(<span class="string">"new instance"</span>)</span><br><span class="line">            instance[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instance[cls]</span><br><span class="line">    <span class="keyword">return</span> get_instance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singletion</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get class"</span>)</span><br><span class="line"></span><br><span class="line">u = User()</span><br><span class="line">u.get()</span><br><span class="line">u1 = User()</span><br><span class="line">u1.get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># new instance</span></span><br><span class="line"><span class="comment"># get class</span></span><br><span class="line"><span class="comment"># get class</span></span><br></pre></td></tr></table></figure><h2><span id="shi-yong-yuan-lei">使用元类</span><a href="#shi-yong-yuan-lei" class="header-anchor"></a></h2><p>元类同样是 Python 特有的，不过并不常用，我们可以利用它的特性来实现单例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 使用元类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            print(<span class="string">"new instance"</span>)</span><br><span class="line">            cls._instances[cls] = super().__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingClass</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get class"</span>)</span><br><span class="line"></span><br><span class="line">c = SingClass()</span><br><span class="line">c.get()</span><br><span class="line"></span><br><span class="line">c1 = SingClass()</span><br><span class="line">c1.get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># new instance</span></span><br><span class="line"><span class="comment"># get class</span></span><br><span class="line"><span class="comment"># get class</span></span><br></pre></td></tr></table></figure><p>完整 demo 地址：<a href="https://github.com/wxnacy/study/tree/master/python/singletion" target="_blank" rel="noopener">https://github.com/wxnacy/study/tree/master/python/singletion</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式中，单例模式是很常见的，今天总结下 Python 的几种实现方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
</feed>
