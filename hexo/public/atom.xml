<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-04-01T09:08:09.817Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 中循环语句速度对比</title>
    <link href="http://wxnacy.com/2019/04/01/python-loop-speed-comparison/"/>
    <id>http://wxnacy.com/2019/04/01/python-loop-speed-comparison/</id>
    <published>2019-04-01T05:31:39.000Z</published>
    <updated>2019-04-01T09:08:09.817Z</updated>
    
    <content type="html"><![CDATA[<p>今天来比较下 Python 中循环语句的性能，参赛选手为 <code>while</code> <code>for</code> <code>生成器</code> <code>内置函数</code> <code>列表解析</code></p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: for while generator list_comprehension map 对比速度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_for</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        res.append(abs(i))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_while</span><span class="params">(n)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        res.append(abs(i))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_generator</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''使用生成器'''</span></span><br><span class="line">    res = (abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    res =  list(res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_list_compre</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''使用列表解析'''</span></span><br><span class="line">    res = [abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_map</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''使用内置函数 map'''</span></span><br><span class="line">    <span class="keyword">return</span> list(map(abs, range(n)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMain</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''before each test function'''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''after each test function'''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_func</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">10</span></span><br><span class="line">        <span class="comment"># 我们要求他们生成的结果是一样的</span></span><br><span class="line">        flag = (loop_for(n) == loop_while(n) == loop_generator(n) ==</span><br><span class="line">                loop_list_compre(n) == loop_map(n))</span><br><span class="line">        self.assertTrue(flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_run_time</span><span class="params">(count, func, **kw)</span>:</span></span><br><span class="line">    b = timeit.default_timer()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        func(**kw)</span><br><span class="line">    print(<span class="string">'&#123;&#125; run &#123;&#125; times used &#123;&#125;s'</span>.format(</span><br><span class="line">        func.__name__.ljust(<span class="number">20</span>),</span><br><span class="line">        count,</span><br><span class="line">        timeit.default_timer() -b ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    count = <span class="number">1000</span></span><br><span class="line">    n = <span class="number">1000</span></span><br><span class="line">    print_func_run_time(count, loop_for, n = n)</span><br><span class="line">    print_func_run_time(count, loop_while, n = n)</span><br><span class="line">    print_func_run_time(count, loop_generator, n = n)</span><br><span class="line">    print_func_run_time(count, loop_list_compre, n = n)</span><br><span class="line">    print_func_run_time(count, loop_map, n = n)</span><br><span class="line">    unittest.main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># .</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Ran 1 test in 0.000s</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># OK</span></span><br><span class="line"><span class="comment"># loop_for             run 1000 times used 0.14018906400087872s</span></span><br><span class="line"><span class="comment"># loop_while           run 1000 times used 0.21399457900042762s</span></span><br><span class="line"><span class="comment"># loop_generator       run 1000 times used 0.12857274799898732s</span></span><br><span class="line"><span class="comment"># loop_list_compre     run 1000 times used 0.08585307099929196s</span></span><br><span class="line"><span class="comment"># loop_map             run 1000 times used 0.043123570998432115s</span></span><br></pre></td></tr></table></figure><p>我们以性能好坏来区分，得到的结论</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &gt; 列表解析 &gt; 生成器 &gt; <span class="keyword">for</span> &gt; <span class="keyword">while</span></span><br></pre></td></tr></table></figure><p><code>map</code> 是内置函数，底层由 C 来编写，最快是毫无疑问的。而 <code>while</code> 是纯 Python 实现的，所以性能最差。</p><p>列表解析比生成器要快一些，这里多少有些存疑，因为我们想要返回列表，所以其实 <code>map</code> 和生成器都是在负重前行，我们修改下测试方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_generator</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = (abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_list_compre</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = [abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_map</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> map(abs, range(n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_run_time</span><span class="params">(count, func, **kw)</span>:</span></span><br><span class="line">    b = timeit.default_timer()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        func(**kw)</span><br><span class="line">    print(<span class="string">'&#123;&#125; run &#123;&#125; times used &#123;&#125;s'</span>.format(</span><br><span class="line">        func.__name__.ljust(<span class="number">20</span>),</span><br><span class="line">        count,</span><br><span class="line">        timeit.default_timer() -b ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    count = <span class="number">1000</span></span><br><span class="line">    n = <span class="number">1000</span></span><br><span class="line">    print_func_run_time(count, loop_list_compre, n = n)</span><br><span class="line">    print_func_run_time(count, loop_map, n = n)</span><br><span class="line">    print_func_run_time(count, loop_generator, n = n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loop_list_compre     run 1000 times used 0.08865494900237536s</span></span><br><span class="line"><span class="comment"># loop_map             run 1000 times used 0.0007684140000492334s</span></span><br><span class="line"><span class="comment"># loop_generator       run 1000 times used 0.0009459810025873594s</span></span><br></pre></td></tr></table></figure><p>好了，这次我们不再强制转换 list，而仅仅只是返回一个可迭代的对象，发现 <code>map</code> 依然最快，生成器稍慢，而列表解析竟然慢了近百倍。</p><p>这次我们可以下个结论，处理循环时，我们已经尽可能的使用内置方法，然后根据业务需求来选择使用列表解析和生成器，实在不行了使用 <code>for</code> 循环，而 <code>while</code> 则是尽量不去使用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来比较下 Python 中循环语句的性能，参赛选手为 &lt;code&gt;while&lt;/code&gt; &lt;code&gt;for&lt;/code&gt; &lt;code&gt;生成器&lt;/code&gt; &lt;code&gt;内置函数&lt;/code&gt; &lt;code&gt;列表解析&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Pyenv 安装 Python3.7 报错：zlib not available</title>
    <link href="http://wxnacy.com/2019/03/31/pyenv-zlib-not-available/"/>
    <id>http://wxnacy.com/2019/03/31/pyenv-zlib-not-available/</id>
    <published>2019-03-31T05:30:55.000Z</published>
    <updated>2019-04-01T05:33:15.866Z</updated>
    
    <content type="html"><![CDATA[<p>最近升级 Mac 系统，又手贱升级了 pyenv，结果安装 Python3.7 时报了错</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.7 zipimport.ZipImportError: can<span class="string">'t decompress data; zlib not available</span></span><br></pre></td></tr></table></figure><p>查询了下，发现是因为 Xcode 命令行工具没有安装需要的头，需要手动进行安装，运行如下命令可以解决这个问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xcode-select --install</span><br><span class="line">$ sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target /</span><br></pre></td></tr></table></figure><p>我的环境是</p><ul><li>macOS Mojave 10.14.3</li><li>pyenv 1.2.9</li><li><p>安装 3.7.2 版本</p></li><li><p><a href="https://github.com/pyenv/pyenv/issues/1219" target="_blank" rel="noopener">Install failed, “zlib not available” on macOS Mojave</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近升级 Mac 系统，又手贱升级了 pyenv，结果安装 Python3.7 时报了错&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy 升级报错：Can&#39;t resolve label reference for ORDER BY / GROUP BY ...</title>
    <link href="http://wxnacy.com/2019/03/30/sqlalchemy-error-order-by/"/>
    <id>http://wxnacy.com/2019/03/30/sqlalchemy-error-order-by/</id>
    <published>2019-03-30T09:53:36.000Z</published>
    <updated>2019-03-30T09:53:37.021Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间因为要使用 <code>insert ... on duplicate key update ..</code> 语句的功能，SQLAlchemy 从 1.1.5 升级到了 1.3.1，结果程序报了错</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Can<span class="string">'t resolve label reference for ORDER BY / GROUP BY. Textual SQL expression '</span>rank desc<span class="string">' should be explicitly declared as text('</span>rank desc<span class="string">')</span></span><br></pre></td></tr></table></figure><p>其实一看到这个错误，我就知道是怎么回事了，因为之前的版本其实报过警告，只是当时没有在意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAWarning: Can<span class="string">'t resolve label reference '</span>rank desc<span class="string">'; converting to text() (this warning may be suppressed after 10 occurrences)</span></span><br></pre></td></tr></table></figure><p>它的意思是在未来的版本 <code>order_by(&#39;rank desc&#39;)</code> 写法将不再支持。</p><p>那换个写法就好了。</p><p>我们先来回顾下，老版本 <code>ORDER BY</code> 的几种写法，原始 SQL 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; select * from user order by id desc;</span><br></pre></td></tr></table></figure><p>SQLAlchemy 的写法有三种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种最简单</span></span><br><span class="line">db.session.query(User).order_by(<span class="string">'id desc'</span>).all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种比较符合 SQLAlchemy 语法</span></span><br><span class="line">db.session.query(User).order_by(User.id.desc()).all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种最麻烦</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> desc</span><br><span class="line">db.session.query(User).order_by(desc(User.id)).all()</span><br></pre></td></tr></table></figure><p>既然新版本第一种方式不让用了，那就用第二种好了，OK，正常情况下没有，但是我修改后报了如下错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: <span class="built_in">type</span> object <span class="string">'VisitorLog'</span> has no attribute <span class="string">'rank'</span></span><br></pre></td></tr></table></figure><p>找不到属性？我回看了下代码发现了问题。</p><p>原始 SQL 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; select url, count(url) as rank from visit_log group by url order by rank desc;</span><br></pre></td></tr></table></figure><p>老版本 SQLAlchemy 写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line">cls = VisitLog</span><br><span class="line">res = db.session.query(</span><br><span class="line">    cls.url, func.count(cls.url).label(<span class="string">'rank'</span>)</span><br><span class="line">).group_by(cls.url).order_by(<span class="string">'rank desc'</span>).all()</span><br></pre></td></tr></table></figure><p>新版本理论写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line">cls = VisitLog</span><br><span class="line">res = db.session.query(</span><br><span class="line">    cls.url, func.count(cls.url).label(<span class="string">'rank'</span>)</span><br><span class="line">).group_by(cls.url).order_by(cls.rank.desc).all()</span><br></pre></td></tr></table></figure><p>因为 <code>rank</code> 我是用了 <code>label</code> 方法模拟了 <code>as</code> 功能，所以报错找不到属性也是可以理解的，那这里我们需要将 <code>label</code> 单提出一个变量了，在进行 <code>desc()</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line">cls = VisitLog</span><br><span class="line">rank = func.count(cls.url).label(<span class="string">'rank'</span>)</span><br><span class="line">res = db.session.query(</span><br><span class="line">    cls.url, rank</span><br><span class="line">).group_by(cls.url).order_by(rank.desc).all()</span><br></pre></td></tr></table></figure><p>在执行，完美解决</p><p>这套逻辑同样适用于 <code>GROUP BY</code> 语法</p><ul><li><a href="https://docs.sqlalchemy.org/en/latest/core/sqlelement.html#sqlalchemy.sql.expression.desc" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://stackoverflow.com/questions/15555920/python-sqlalchemy-label-usage" target="_blank" rel="noopener">python-sqlalchemy-label-usage</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间因为要使用 &lt;code&gt;insert ... on duplicate key update ..&lt;/code&gt; 语句的功能，SQLAlchemy 从 1.1.5 升级到了 1.3.1，结果程序报了错&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
      <category term="sqlalchemy" scheme="http://wxnacy.com/tags/sqlalchemy/"/>
    
  </entry>
  
  <entry>
    <title>OSSFS 阿里云 OSS 本地挂载工具</title>
    <link href="http://wxnacy.com/2019/03/29/ossfs/"/>
    <id>http://wxnacy.com/2019/03/29/ossfs/</id>
    <published>2019-03-29T01:47:02.000Z</published>
    <updated>2019-03-29T01:47:02.823Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/aliyun/ossfs" target="_blank" rel="noopener">ossfs</a> 能让您在Linux/Mac OS X 系统中把Aliyun OSS bucket 挂载到本地文件 系统中，您能够便捷的通过本地文件系统操作OSS 上的对象，实现数据的共享。</p></blockquote><a id="more"></a><h2><span id="wei-shi-me-xu-yao-yong-dao-zhe-ge-ruan-jian-ni">为什么需要用到这个软件呢？</span><a href="#wei-shi-me-xu-yao-yong-dao-zhe-ge-ruan-jian-ni" class="header-anchor"></a></h2><p>我的情况是这样的，公司微信 h5 的静态文件是放在 OSS 上的，因为代码框架选用的 React，正常情况下地址路由都是交给 <code>index.html</code> 处理的，但是返回的状态码是 404，而微信非常流氓的把 404 状态的地址都转到它自己的页面，使得页面无法正常显示，AWS 的 s3 可以设置 404 状态改为 200，不过 OSS 没有，所以我只能借助 ossfs 的同步功能，在本地加一个 nginx 反向代理，单独处理 404 的请求。</p><p>挂载了 ossfs，OSS 和本地挂在之间可以实现双向同步，这是很方便的。</p><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><p>首先从<a href="https://github.com/aliyun/ossfs/releases" target="_blank" rel="noopener">版本发布页面</a>下载合适的安装包</p><p><strong>Ubuntu 16.04</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/aliyun/ossfs/releases/download/v1.80.5/ossfs_1.80.5_ubuntu16.04_amd64.deb</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install gdebi-core</span><br><span class="line">$ sudo gdebi ossfs_1.80.5_ubuntu16.04_amd64.deb</span><br></pre></td></tr></table></figure><p><strong>CentOS 7</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/aliyun/ossfs/releases/download/v1.80.5/ossfs_1.80.5_centos7.0_x86_64.rpm</span><br><span class="line">$ sudo yum localinstall ossfs_1.80.5_centos7.0_x86_64.rpm</span><br></pre></td></tr></table></figure><h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor"></a></h2><p><strong>配置 bucket 信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> my-bucket:my-access-key-id:my-access-key-secret &gt; /etc/passwd-ossfs  <span class="comment"># 配置 key 和 secret</span></span><br><span class="line">$ chmod 640 /etc/passwd-ossfs   <span class="comment"># 修改文件权限</span></span><br><span class="line">$ ossfs my-bucket local_dir_path -ourl=my-oss-endpoint  <span class="comment"># 将 bucket mount 到本地文件夹</span></span><br></pre></td></tr></table></figure><p>如果机器使用了阿里云 ECS 实例，<code>-ourl</code> 可以使用内网 <code>endpoint</code> 来<strong>避免流量收费</strong>和<strong>提高速度</strong></p><p>挂载命令可以添加 <code>-f -d</code> 参数来让 ossfs 运行在前台并输出debug日志</p><p>你也可以使用 <a href="http://supervisord.org/" target="_blank" rel="noopener">supervisor</a> 来管理 ossfs 进程，方法详见 <a href="https://github.com/aliyun/ossfs/wiki/FAQ#18" target="_blank" rel="noopener">FAQ</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/aliyun/ossfs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ossfs&lt;/a&gt; 能让您在Linux/Mac OS X 系统中把Aliyun OSS bucket 挂载到本地文件 系统中，您能够便捷的通过本地文件系统操作OSS 上的对象，实现数据的共享。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://wxnacy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python 协程库 gevent</title>
    <link href="http://wxnacy.com/2019/03/28/gevent/"/>
    <id>http://wxnacy.com/2019/03/28/gevent/</id>
    <published>2019-03-27T16:01:35.000Z</published>
    <updated>2019-03-28T01:47:16.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/gevent/gevent" target="_blank" rel="noopener">gevent</a> 是一个基于 libev 的并发库。它为各种并发和网络相关的任务提供了整洁的API。</p></blockquote><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#yi-bu-zhi-xing">异步执行</a></li><li><a href="#yin-xing-jiao-chu-zhi-xing-quan">隐形交出执行权</a></li><li><a href="#hou-zi-bu-ding">猴子补丁</a></li><li><a href="#gevent-without-code">gevent without code</a></li></ul><!-- tocstop --></div><p>Python 中多线程的性能极差，替代它的另一种“并发”方式是协程。</p><p>Python 版本中协程一直在不断的进化</p><ul><li><code>yeild</code> python2.x</li><li><code>asynico + yield from</code> python3.4</li><li><code>asynico + await</code> python3.5</li></ul><p>而这个过程中，一直可以拿来就用的三方库就是 gevent</p><p>在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p><blockquote><p>在任何时刻，只有一个协程在运行。</p></blockquote><p>换句话说，协程并不会切换线程或进程（所以性能会比多线程高很多），而是在 IO 阻塞时，可以切换到其他的 Greenlet，等到适当时机再切换回来，这样减少阻塞浪费的时间，使其看起来像是在并发。所以协程可以解决 IO 密集的性能问题，而 CPU 密集则无能为力。</p><h2><span id="yi-bu-zhi-xing">异步执行</span><a href="#yi-bu-zhi-xing" class="header-anchor"></a></h2><p>首先安装 gevent</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install gevent</span><br></pre></td></tr></table></figure><p>我们来模拟程序的阻塞，使用 <code>gevent.sleep(0)</code> 主动让程序交出执行权。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_progress</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'[&#123;&#125;] Greenlet &#123;&#125; Process &#123;&#125; - Thread &#123;&#125;'</span>.format(</span><br><span class="line">        time.time(), gevent.getcurrent(), os.getpid(), threading.current_thread().ident))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print_func_progress()</span><br><span class="line">    print(<span class="string">'Running in foo'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'Explicit context switch to foo again'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print_func_progress()</span><br><span class="line">    print(<span class="string">'Explicit context to bar'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'Implicit context switch back to bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    gevent.joinall([</span><br><span class="line">        gevent.spawn(foo),</span><br><span class="line">        gevent.spawn(bar),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1553694796.1719072] Greenlet &lt;Greenlet at 0x10e9a4930: foo&gt; Process 2022 - Thread 4683818432</span></span><br><span class="line"><span class="comment"># Running in foo</span></span><br><span class="line"><span class="comment"># [1553694796.171974] Greenlet &lt;Greenlet at 0x10e9a4a60: bar&gt; Process 2022 - Thread 4683818432</span></span><br><span class="line"><span class="comment"># Explicit context to bar</span></span><br><span class="line"><span class="comment"># Explicit context switch to foo again</span></span><br><span class="line"><span class="comment"># Implicit context switch back to bar</span></span><br></pre></td></tr></table></figure><p>从打印结果中，可以看到无论是进程 <code>Process</code>，还是线程 <code>Thread</code>，整个过程都是没有变化的，所以再次确定了协程是单线程运行的。并且在运行过程中，协程在两个方法间切换，以减少阻塞浪费的时间。</p><h2><span id="yin-xing-jiao-chu-zhi-xing-quan">隐形交出执行权</span><a href="#yin-xing-jiao-chu-zhi-xing-quan" class="header-anchor"></a></h2><p>当我们的程序受限于网络的 IO 阻塞时，gevent 才能真正发挥实力，它提供了方法，可以隐形的交出上下文执行权，这样我们可以在不改变程序结构的情况下来实现协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent.monkey</span><br><span class="line">gevent.monkey.patch_socket()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_run_time</span><span class="params">(count, func, **kw)</span>:</span></span><br><span class="line">    b = timeit.default_timer()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        func(**kw)</span><br><span class="line">    print(func.__name__, <span class="string">'run &#123;&#125; times used &#123;&#125;s'</span>.format(count,</span><br><span class="line">        timeit.default_timer() -b ))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(pid)</span>:</span></span><br><span class="line">    print(<span class="string">'pid &#123;&#125; begin request url'</span>, pid)</span><br><span class="line">    response = requests.get(<span class="string">'http://baidu.com'</span>)</span><br><span class="line">    print(<span class="string">'pid &#123;&#125; get response status &#123;&#125;'</span>, pid, response.status_code)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronous</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">        fetch(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asynchronous</span><span class="params">()</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">        threads.append(gevent.spawn(fetch, i))</span><br><span class="line">    gevent.joinall(threads)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Synchronous:'</span>)</span><br><span class="line">print_func_run_time(<span class="number">1</span>, synchronous)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Asynchronous:'</span>)</span><br><span class="line">print_func_run_time(<span class="number">1</span>, asynchronous)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Synchronous:</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 0</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 0 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 1</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 1 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 2</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 2 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 3</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 3 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 4</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 4 200</span></span><br><span class="line"><span class="comment"># synchronous run 1 times used 0.13507633499102667s</span></span><br><span class="line"><span class="comment"># Asynchronous:</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 0</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 1</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 2</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 3</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 4</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 0 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 4 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 3 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 1 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 2 200</span></span><br><span class="line"><span class="comment"># asynchronous run 1 times used 0.03902721201302484s</span></span><br></pre></td></tr></table></figure><p>从结果中我们可以看到，使用 gevent 执行的程序，性能比顺序执行好了很多倍，而在功能函数中，我们也并没有主动交出执行权，这一些都归功于猴子补丁 <code>gevent.monkey</code></p><h2><span id="hou-zi-bu-ding">猴子补丁</span><a href="#hou-zi-bu-ding" class="header-anchor"></a></h2><p>猴子补丁(monkey patching) 得以让 gevent 变得更加强大。上面的代码中我们用到了 <code>gevent.monkey.patch_socket()</code>，它修改了 Python 的 socket 标准库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> socket</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>socket.socket</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">socket</span>.<span class="title">socket</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">from</span> <span class="title">gevent</span> <span class="title">import</span> <span class="title">monkey</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">monkey</span>.<span class="title">patch_socket</span><span class="params">()</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">socket</span>.<span class="title">socket</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">gevent</span>.<span class="title">_socket3</span>.<span class="title">socket</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>Python的运行环境允许我们在运行时修改大部分的对象，包括模块，类甚至函数。所以猴子补丁的实现原理很简单，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.__name__</span><br><span class="line"><span class="string">'json'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">patch_json</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    json.__name__ = <span class="string">'wjson'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>patch_json()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.__name__</span><br><span class="line"><span class="string">'wjson'</span></span><br></pre></td></tr></table></figure><p>在这种情况下，gevent能够 修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。通常情况下我们只需要调用 <code>gevent.monkey.patch_all()</code>，它可以修改所有可以兼容的模块</p><p><code>patch_all()</code> 方法语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_all</span><span class="params">(socket=True, dns=True, time=True, select=True, thread=True, os=True, ssl=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              httplib=False, # Deprecated, to be removed.</span></span></span><br><span class="line"><span class="function"><span class="params">              subprocess=True, sys=False, aggressive=True, Event=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              builtins=True, signal=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              queue=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              **kwargs)</span>:</span></span><br></pre></td></tr></table></figure><p>如果不想修改某个模块，直接传参即可，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch_all(socket=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>或者在该方法之后导入，让原始模块覆盖掉 monkey 的修改即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>monkey.patch_all()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> select</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select.select</span><br><span class="line">&lt;function select at <span class="number">0x100e40f28</span>&gt;</span><br></pre></td></tr></table></figure><h2><span id="gevent-without-code">gevent without code</span><a href="#gevent-without-code" class="header-anchor"></a></h2><p>猴子补丁如此厉害，好像可以不用主动写 gevent 代码就可以实现。其实真的可以不用任何 gevent 代码，就可以让程序实现协程，只需要使用可以调用 gevent 的容器来启动程序即可。</p><p>我们来使用 gunicorn 来启动一个 Flask 程序。</p><p>如果你不了解 gunicorn，可以看我的这篇文章<a href="/2017/08/15/python-2017-08-15-gunicorn-run/">使用 gunicorn 启动你的项目</a></p><p>安装模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install gunicorn</span><br><span class="line">$ pip install flask</span><br></pre></td></tr></table></figure><p>编辑文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch gevent_without_code.py</span><br><span class="line">$ vim gevent_without_code.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">print(socket.socket)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/for')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"for"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/bar')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><p>不使用 gevent 启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gunicorn gevent_without_code:app</span><br><span class="line"></span><br><span class="line">[2019-03-27 23:06:53 +0800] [53872] [INFO] Starting gunicorn 19.7.1</span><br><span class="line">[2019-03-27 23:06:53 +0800] [53872] [INFO] Listening at: http://127.0.0.1:8000 (53872)</span><br><span class="line">[2019-03-27 23:06:53 +0800] [53872] [INFO] Using worker: sync</span><br><span class="line">[2019-03-27 23:06:53 +0800] [53932] [INFO] Booting worker with pid: 53932</span><br><span class="line">&lt;class <span class="string">'socket.socket'</span>&gt;</span><br><span class="line">[2019-03-27 23:06:56 +0800] [53872] [INFO] Handling signal: winch</span><br></pre></td></tr></table></figure><p>gunicorn 默认启动一个 8000 端口的 web 程序，我们有两个接口 <code>/for</code> 强制睡眠 4 秒钟，<code>/bar</code> 直接返回结果</p><p>这时候我们先访问 <code>/for</code> 在访问 <code>/bar</code> 会发生阻塞</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/gevent1.gif" alt="gevent1"></p><p><code>/bar</code> 需要等待 <code>/for</code> 返回结果后才能执行，这显然不是一个健康的程序。我们试试使用 gevent。</p><p><code>&lt;ctrl&gt; + c</code> 停掉程序，重新启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gunicorn gevent_without_code:app -k gevent</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63766] [INFO] Starting gunicorn 19.7.1</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63766] [INFO] Listening at: http://127.0.0.1:8000 (63766)</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63766] [INFO] Using worker: gevent</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63826] [INFO] Booting worker with pid: 63826</span><br><span class="line">&lt;class <span class="string">'gevent._socket3.socket'</span>&gt;</span><br></pre></td></tr></table></figure><p>再次访问两个接口，效果非常明显</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/gevent2.gif" alt="gevent2"></p><p>当 <code>/for</code> 阻塞时，gevent 直接跳过执行 <code>/bar</code>，等阻塞过后，在继续执行 <code>/for</code>。</p><p>这里我们一句 gevent 代码都没写，那它是什么实现的呢？</p><p>如果你留意刚才的启动日志，会发现我们代码有句 <code>print(socket.socket)</code>，在使用 gevent 前后是有不同的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;class <span class="string">'socket.socket'</span>&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&lt;class <span class="string">'gevent._socket3.socket'</span>&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>就像我们上面讲到的那样，gevent 在这里隐形的调用了 <code>gevent.monkey.patch_all()</code> 方法，使得相关的程序都自动变成了协程可调用的状态。</p><p>不管你代码写的怎么样，用 gevent 来启动你的项目吧，一定会让你觉得物有所值。</p><ul><li><a href="https://github.com/wxnacy/study/tree/master/python/gevent_demo" target="_blank" rel="noopener">本文 demo 源码</a></li><li><a href="https://github.com/gevent/gevent" target="_blank" rel="noopener">gevent 源码</a></li><li><a href="http://hhkbp2.github.io/gevent-tutorial/" target="_blank" rel="noopener">gevent 程序员指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gevent/gevent&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gevent&lt;/a&gt; 是一个基于 libev 的并发库。它为各种并发和网络相关的任务提供了整洁的API。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 访问中文文档</title>
    <link href="http://wxnacy.com/2019/03/27/python-doc-zh/"/>
    <id>http://wxnacy.com/2019/03/27/python-doc-zh/</id>
    <published>2019-03-27T06:42:32.000Z</published>
    <updated>2019-03-27T07:11:12.743Z</updated>
    
    <content type="html"><![CDATA[<p>今天使用中文 Google 时，以外发现了 Python 的中文文档，地址： <a href="https://docs.python.org/zh-cn" target="_blank" rel="noopener">https://docs.python.org/zh-cn</a></p><a id="more"></a><p>它会默认跳转到 Python 3.7 的文档</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/python-doc-zh_1411_705.png" alt="python"></p><p>有意思的是，如果使用地址：<a href="https://docs.python.org" target="_blank" rel="noopener">https://docs.python.org</a> 打开文档，左上角是看不到 <code>zh-cn</code> 选项的，大概是官方认为还没到直接开发的地步，因为确实很多东西还没做好。</p><p>比如搜索功能，现在还是只能搜索英文，如何的中文信息都搜索不到。</p><p>很多文档也还保留了大量的英文内容。</p><p>不过这不影响，一些基础模块的查看，毕竟有和没有是两个概念，这对很多初学者也是很重要的。</p><!-- 现在文档有 `2.7` `3.5` `3.6` `3.7` `3.8` 多个版本 --><p>文档左侧可以跳转其他版本，但是有个坑，直接点过去依然进入的是英文页面，我们需要<br>修改下地址，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.python.org/3.6/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.python.org/zh-cn/3.6/</span><br></pre></td></tr></table></figure><p>但是 <code>3.5</code> 版本修改后是 404，说明官方还完全没有开始这个版本的翻译工作，这里也是希望官方可以尽快完善。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天使用中文 Google 时，以外发现了 Python 的中文文档，地址： &lt;a href=&quot;https://docs.python.org/zh-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/zh-cn&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 计时器 timeit</title>
    <link href="http://wxnacy.com/2019/03/26/python-timeit/"/>
    <id>http://wxnacy.com/2019/03/26/python-timeit/</id>
    <published>2019-03-26T14:10:02.000Z</published>
    <updated>2019-03-26T14:10:02.111Z</updated>
    
    <content type="html"><![CDATA[<p>网上很多帖子讨论 Python 中计时用 <code>time.clock()</code> 还是用 <code>time.time()</code>。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#time-clock-vs-time-time">time.clock() vs time.time()</a></li><li><a href="#timeit">timeit</a></li><li><a href="#ming-ling-xing-yu-fa">命令行语法</a></li></ul><!-- tocstop --></div><h2><span id="time-clock-vs-time-time">time.clock() vs time.time()</span><a href="#time-clock-vs-time-time" class="header-anchor"></a></h2><ul><li><code>time.clock()</code> 计算的是 CPU 的时间，在 windows 平台上精度比较高</li><li><code>time.time()</code> 计算的是程序的运行时间，会受到机器负载的影响，除了 windows 以外的平台精度比较高</li></ul><p>所以我们可以按照平台来使用不同的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.platform == <span class="string">"win32"</span>:</span><br><span class="line">    <span class="comment"># On Windows, the best timer is time.clock()</span></span><br><span class="line">    default_timer = time.clock</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># On most other platforms the best timer is time.time()</span></span><br><span class="line">    default_timer = time.time</span><br></pre></td></tr></table></figure><p>或者呢，直接使用 <code>timeit</code> 模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">b = timeit.default_timer()</span><br><span class="line"><span class="comment"># to some</span></span><br><span class="line">e = timeit.default_timer()</span><br><span class="line">print(e - b)</span><br></pre></td></tr></table></figure><p><code>timeit.default_timer()</code> 可以自动选择当前平台适合的计时器，因为它的源代码就是上面那段判断代码。</p><p>下面我们重点来介绍下 <code>timeit</code> 模块</p><p><code>timeit</code> 模块提供了一种简单的方法来计算一小段Python代码。 它既有命令行界面，也有可调用界面。 它避免了许多用于测量执行时间的常见陷阱。</p><h2><span id="timeit">timeit</span><a href="#timeit" class="header-anchor"></a></h2><p><strong>命令行使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m timeit <span class="string">'"-".join(str(n) for n in range(100))'</span></span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">40.3</span> usec per loop</span><br></pre></td></tr></table></figure><p>默认情况下，命令行对小段代码，重复执行三个循环，每个循环执行 10000 次，其中最好的用了 40.3 秒</p><p><strong>代码块中使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># attribute is missing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"""\</span></span><br><span class="line"><span class="string"><span class="meta">... </span>try:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    str.__nonzero__</span></span><br><span class="line"><span class="string"><span class="meta">... </span>except AttributeError:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    pass</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(s)</span><br><span class="line"><span class="number">0.5832341330096824</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(s, number=<span class="number">1000</span>)</span><br><span class="line"><span class="number">0.000628526002401486</span></span><br></pre></td></tr></table></figure><p><code>number</code> 不指定时，默认为 <code>default_number = 1000000</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.repeat(s)</span><br><span class="line">[<span class="number">0.5949273270089179</span>, <span class="number">0.6405833000026178</span>, <span class="number">0.5868908820120851</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.repeat(s, repeat=<span class="number">4</span>)</span><br><span class="line">[<span class="number">0.5963048749981681</span>, <span class="number">0.5834796829876723</span>, <span class="number">0.5749933830084046</span>, <span class="number">0.5814367970015155</span>]</span><br></pre></td></tr></table></figure><p>增加重复次数，使用 <code>repeat()</code> 方法，不指定 <code>repeat</code> 时，默认 <code>default_repeat = 3</code></p><h2><span id="ming-ling-xing-yu-fa">命令行语法</span><a href="#ming-ling-xing-yu-fa" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m timeit [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement ...]</span><br></pre></td></tr></table></figure><ul><li><code>-n N, --number=N</code> 执行 <code>statement</code> 的次数</li><li><code>-r N, --repeat=N</code> 循环的重复次数，默认：3</li><li><code>-s S, --setup=S</code> 最初要执行的语句，默认：pass</li><li><code>-t, --time</code> 使用 <code>time.time()</code> 计时，在 windows 以外平台默认使用该模式</li><li><code>-c, --clock</code> 使用 <code>time.clock()</code> 计时，在 windows 平台默认使用该模式</li><li><code>-v, --verbose</code> 打印原始计时结果，得到更多数字精度</li><li><code>-h, --help</code> 帮助信息</li></ul><p>当 <code>-n</code> 不指定时，程序会自动执行 10 的倍数，使执行时间不少于 0.2 秒</p><p><code>-s</code> 可以执行一段前置代码，这在很多场景是很有用的</p><p><strong>命令行中使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m timeit -s <span class="string">'text = "sample string"; char = "g"'</span>  <span class="string">'char in text'</span></span><br><span class="line">10000000 loops, best of 3: 0.0877 usec per loop</span><br></pre></td></tr></table></figure><p><strong>代码块中使用</strong></p><p>在代码快中，这个参数更有用处，我们不必把代码都写在字符串中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Stupid test function"""</span></span><br><span class="line">    L = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        L.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> timeit</span><br><span class="line">    print(timeit.timeit(<span class="string">"test()"</span>, setup=<span class="string">"from __main__ import test"</span>))</span><br></pre></td></tr></table></figure><ul><li>文档：<a href="https://docs.python.org/2/library/timeit.html" target="_blank" rel="noopener">https://docs.python.org/2/library/timeit.html</a></li><li>源代码：<a href="https://github.com/python/cpython/blob/2.7/Lib/timeit.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/2.7/Lib/timeit.py</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上很多帖子讨论 Python 中计时用 &lt;code&gt;time.clock()&lt;/code&gt; 还是用 &lt;code&gt;time.time()&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>adb 如何连接夜神模拟器</title>
    <link href="http://wxnacy.com/2019/03/25/adb-connect-yeshen/"/>
    <id>http://wxnacy.com/2019/03/25/adb-connect-yeshen/</id>
    <published>2019-03-25T07:16:27.000Z</published>
    <updated>2019-03-25T07:23:11.548Z</updated>
    
    <content type="html"><![CDATA[<p>夜神模拟器无法自动出现在 <code>adb devices</code> 列表中，需要先打开开发者模式</p><a id="more"></a><p>步骤如下：</p><ul><li>点击<code>设置</code> -》<code>关于平板电脑</code> -》连续点击 5 次版本号，进入开发者模式</li><li>重新进入设置，滑到最下边，进入开发者模式，并打开 USB 调试模式</li><li>链接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb connect 127.0.0.1:62001</span><br></pre></td></tr></table></figure><ul><li>查看</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;夜神模拟器无法自动出现在 &lt;code&gt;adb devices&lt;/code&gt; 列表中，需要先打开开发者模式&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wxnacy.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 Redis watch 完成秒杀活动防止超卖 demo</title>
    <link href="http://wxnacy.com/2019/03/17/python-redis-watch/"/>
    <id>http://wxnacy.com/2019/03/17/python-redis-watch/</id>
    <published>2019-03-17T02:49:48.000Z</published>
    <updated>2019-03-17T02:49:48.511Z</updated>
    
    <content type="html"><![CDATA[<p>在做类似抢购活动的程序，我们通常会使用“乐观锁”思路，既保证库存不会超卖，也能够应付大并发的情况，Redis 中 watch 就可以实现“乐观锁”。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>Redis 中的事务 <code>multi/exec</code> 可以保证数据的原子性，但不能像 Mysql 那样在事务中出错回滚数据，而用 <code>watch</code> 来监听数据，就可以实现类似的功能。</p><p>先用 <code>watch</code> 监听后，在接下来事务的过程，如果数据被修改，则在执行 <code>exec</code> 时，则会报错，我们可以根据业务选择重试和返回结果。</p><p>Python 中通过管道 Pipeline 来实现 Redis 事务相关操作。</p><p><strong>初始化线程池</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接池</span></span><br><span class="line">pool = redis.ConnectionPool(host = <span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 初始化 redis</span></span><br><span class="line">r = redis.Redis(connection_pool = pool)</span><br></pre></td></tr></table></figure><p><strong>初始化管道</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe = r.pipeline()</span><br></pre></td></tr></table></figure><p><strong>使用事务</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">KEY = <span class="string">'count'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pipe.watch(KEY)         <span class="comment"># 监听库存</span></span><br><span class="line">    pipe.multi()            <span class="comment"># 开始事务</span></span><br><span class="line">    pipe.set(KEY, <span class="number">2</span>)        <span class="comment"># 执行操作</span></span><br><span class="line">    pipe.execute()          <span class="comment"># 执行事务</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 事务执行过程中，如果数据被修改，则抛出异常，程序可以选择重试或退出</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    pipe.reset()            <span class="comment"># 重置管道，为重试做准备</span></span><br></pre></td></tr></table></figure><p>通过这些操作，我们可以先实现一个防止商品超卖的 demo。</p><p>代码位置 <a href="https://github.com/wxnacy/study/blob/master/python/redis_demo/watch_demo.py" target="_blank" rel="noopener">watch_demo.py</a></p><p><strong>运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ python watch_demo.py</span><br><span class="line">用户 0 抢购成功，商品剩余 9</span><br><span class="line">用户 1 抢购成功，商品剩余 8</span><br><span class="line">用户 2 抢购失败，重试一次</span><br><span class="line">用户 3 抢购成功，商品剩余 7</span><br><span class="line">用户 5 抢购失败，重试一次</span><br><span class="line">用户 4 抢购失败，重试一次</span><br><span class="line">用户 2 抢购失败，重试一次</span><br><span class="line">用户 6 抢购失败，重试一次</span><br><span class="line">用户 7 抢购失败，重试一次</span><br><span class="line">用户 9 抢购失败，重试一次</span><br><span class="line">用户 8 抢购成功，商品剩余 6</span><br><span class="line">用户 10 抢购成功，商品剩余 5</span><br><span class="line">用户 5 抢购成功，商品剩余 4</span><br><span class="line">用户 12 抢购失败，重试一次</span><br><span class="line">用户 6 抢购失败，重试一次</span><br><span class="line">用户 13 抢购成功，商品剩余 3</span><br><span class="line">用户 11 抢购失败，重试一次</span><br><span class="line">用户 14 抢购失败，重试一次</span><br><span class="line">用户 2 抢购失败，重试一次</span><br><span class="line">用户 4 抢购失败，重试一次</span><br><span class="line">用户 9 抢购成功，商品剩余 2</span><br><span class="line">用户 7 抢购失败，重试一次</span><br><span class="line">用户 12 抢购成功，商品剩余 1</span><br><span class="line">用户 2 抢购停止，商品卖完</span><br><span class="line">用户 6 抢购失败，重试一次</span><br><span class="line">用户 14 抢购失败，重试一次</span><br><span class="line">用户 4 抢购停止，商品卖完</span><br><span class="line">用户 11 抢购成功，商品剩余 0</span><br><span class="line">用户 7 抢购停止，商品卖完</span><br><span class="line">用户 6 抢购停止，商品卖完</span><br><span class="line">用户 14 抢购停止，商品卖完</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做类似抢购活动的程序，我们通常会使用“乐观锁”思路，既保证库存不会超卖，也能够应付大并发的情况，Redis 中 watch 就可以实现“乐观锁”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
      <category term="redis" scheme="http://wxnacy.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Shell 几种算术运算方式</title>
    <link href="http://wxnacy.com/2019/03/16/shell-calculation/"/>
    <id>http://wxnacy.com/2019/03/16/shell-calculation/</id>
    <published>2019-03-16T08:40:29.000Z</published>
    <updated>2019-03-16T08:40:29.518Z</updated>
    
    <content type="html"><![CDATA[<p>Shell 脚本中，我们可以使用几种方式来实现算数运算。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#expr">expr</a></li><li><a href="#xiao-gua-hao">小括号</a></li><li><a href="#zhong-gua-hao">中括号</a></li><li><a href="#let">let</a></li></ul><!-- tocstop --></div><h2><span id="expr">expr</span><a href="#expr" class="header-anchor"></a></h2><p>expr 本身是一个算数运算命令，Shell 可以直接拿到它的执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `expr 1 + 2`</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>expr 有很多缺点，比如：只能运算整数、数字和符号之间必须都有空格、<code>*</code> 号需要转义、无法使用次方运算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ expr 1+2</span><br><span class="line">1+2</span><br><span class="line"></span><br><span class="line">$ expr 1 +2</span><br><span class="line">expr: syntax error</span><br><span class="line"></span><br><span class="line">$ expr 1 \* 2</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">$ expr 1 + 2.3</span><br><span class="line">expr: not a decimal number: <span class="string">'2.3'</span></span><br></pre></td></tr></table></figure><h2><span id="xiao-gua-hao">小括号</span><a href="#xiao-gua-hao" class="header-anchor"></a></h2><p>下面我们来看 shell 本身的计算方式，第一个是小括号，这种方式需要把运算表达式用两层小括号包裹起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((1+2))</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">$ ((i=1+2))</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $((1 + 2.3))</span><br><span class="line">3.2999999999999998</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $((2 ** 3))  <span class="comment"># 计算三次方</span></span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>通过例子可以看到，这种方式比 <code>expr</code> 写起来更好更舒服，就是在计算浮点数字时会有精度损失。</p><h2><span id="zhong-gua-hao">中括号</span><a href="#zhong-gua-hao" class="header-anchor"></a></h2><p>中括号的方式必须加上 <code>$</code> 前缀，并不支持像小括号一样，在括号内赋值，其他与小括号无异。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $[1 + 2]</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $[2 ** 3]</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2><span id="let">let</span><a href="#let" class="header-anchor"></a></h2><p>let 用来指示运算表达式，也可以达到效果，但是同样的有很多缺点，比如运算符和数字不能有空格、不支持次方运算、浮点运算会忽略小数点部分、<code>*</code> 需要转义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ <span class="built_in">let</span> i = 1 + 2</span><br><span class="line">zsh: bad math expression: operand expected at =</span><br><span class="line"></span><br><span class="line">&gt; $ <span class="built_in">let</span> i=1+2</span><br><span class="line">&gt; $ <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt; $ <span class="built_in">let</span> i=1+2.3</span><br><span class="line">&gt; $ <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt; $ <span class="built_in">let</span> i=2**3</span><br><span class="line">zsh: no matches found: i=2**3</span><br><span class="line"></span><br><span class="line">&gt; $ <span class="built_in">let</span> i=1+2.6</span><br><span class="line">&gt; $ <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt; $ <span class="built_in">let</span> i=2\*3</span><br><span class="line">&gt; $ <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>经过对比可以发现，小括号和中括号的方式最好，两者只是书写存在细微差异，其他两个不建议使用。</p><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7231832.html" target="_blank" rel="noopener">SHELL脚本–expr命令全解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shell 脚本中，我们可以使用几种方式来实现算数运算。&lt;/p&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://wxnacy.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Vim 报错：Caught deadly signal SEGV</title>
    <link href="http://wxnacy.com/2019/03/15/vim-error-caught-deadly-signal-segv/"/>
    <id>http://wxnacy.com/2019/03/15/vim-error-caught-deadly-signal-segv/</id>
    <published>2019-03-15T02:15:35.000Z</published>
    <updated>2019-03-15T02:56:31.291Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 系统大版本的升级总是会引来一些灾难，这次升级到 macOS Mojave 就有很多软件都用不了了，Vim 就是其中一个。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vim: Caught deadly signal SEGV</span><br><span class="line">Error detected <span class="keyword">while</span> processing <span class="keyword">function</span> 81_PollServerReady[7]..81_Pyeval:Vim: Finished.</span><br><span class="line"></span><br><span class="line">line 4:</span><br><span class="line">Exception MemoryError: MemoryError() <span class="keyword">in</span> &lt;module <span class="string">'threading'</span> from <span class="string">'/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.pyc'</span>&gt; ignored</span><br></pre></td></tr></table></figure><p>这不，每次启动都报这个错误，然后闪退程序。这就很尴尬了，我现在的开发工作都是在 Vim 中进行，用不了可咋整，网上的说法是因为 YouCompleteMe 插件导致的，需要重新安装 Vim 并使之支持 lua。</p><p>我使用 <code>vim --version</code> 查看，发现果然当前不支持</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim --version</span><br><span class="line">...</span><br><span class="line">-lua</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>按照网上教程安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew install vim --with-lua --with-override-system-vi</span><br><span class="line">...</span><br><span class="line">Error: invalid option: --with-lua</span><br></pre></td></tr></table></figure><p>结果报错，无效的参数？？？但是翻遍了 Google 给出的都是这个教程，继续搜索，发现现在新版本的 brew 认为 <code>--</code> 会让使用者困惑，所以慢慢去掉了这些参数，去的真及时，那你倒是把新的方法贴出来啊。</p><p>我只能暂时退而求其次把 YouCompleteMe 插件删掉好了，结果果然正常了，反正是能用了，就是补全功能差劲点，别扭点就别扭点吧，还要工作呢。</p><p>勉强用了一天，觉得还是不行，已经被 YouCompleteMe 惯出毛病了，转了一圈，发现只输入点后自动提示补全和写入文字自动补全时忽略大小写这两点，就没有一个插件可以代替，无奈还是要想办法解决这个问题。</p><p>既然 brew 不能带这些参数，那去掉试试好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install vim</span><br></pre></td></tr></table></figure><p>再次运行 <code>vim</code> 还是不行，我试着查看了下 vim 的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> vim</span><br><span class="line">/usr/bin/vim</span><br></pre></td></tr></table></figure><p>隐约觉得事情不太对，通常 brew 安装的软件二进制文件是在 <code>/usr/local/bin</code> 中的，查看了下发现果然没有链接过去，再次链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown $(whoami):wheel /usr/<span class="built_in">local</span>/share/man/de/man1</span><br><span class="line">$ brew link vim</span><br></pre></td></tr></table></figure><p>再次查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> vim</span><br><span class="line">/usr/bin/vim</span><br></pre></td></tr></table></figure><p>还是不行，查看环境变量发现 <code>$PATH</code> 中，<code>/usr/bin</code> 靠后，会覆盖的 <code>/usr/local/bin</code> 中的命令，再次调整</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim .bash_profile</span><br><span class="line"><span class="built_in">export</span> <span class="variable">$PATH</span>=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/bin</span><br><span class="line">$ <span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure><p>再次查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> vim</span><br><span class="line">/usr/<span class="built_in">local</span>/bin/vim</span><br></pre></td></tr></table></figure><p>搞定，查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim --version</span><br><span class="line">...</span><br><span class="line">+lua</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>好像有戏了，我怀着忐忑的心情，再次安装上 YouCompleteMe，打开 Vim，一切正常。</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/vim1_1440_720.png" alt="vim"></p><p><strong><em>有些时候就是这样，事情总会得到解决，我们可以逃避过去，也可以休息一下，然后重新挑战。</em></strong></p><ul><li><a href="https://github.com/Valloric/YouCompleteMe/issues/3165" target="_blank" rel="noopener">#3165</a></li><li><a href="https://blog.csdn.net/weixin_39569611/article/details/87278729" target="_blank" rel="noopener">brew - Error: invalid option</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac 系统大版本的升级总是会引来一些灾难，这次升级到 macOS Mojave 就有很多软件都用不了了，Vim 就是其中一个。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Python 列表的交集、并集、差集</title>
    <link href="http://wxnacy.com/2019/03/12/python-list-diff-inter/"/>
    <id>http://wxnacy.com/2019/03/12/python-list-diff-inter/</id>
    <published>2019-03-12T08:12:57.000Z</published>
    <updated>2019-03-12T08:26:16.097Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中列表的交集、并集、差集可以有两种方式，列表解析和 set 的函数</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>直接上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 列表的交集、并集、差集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rand_int_arr</span><span class="params">(length)</span>:</span></span><br><span class="line">    arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        r = random.randrange(<span class="number">19</span>)</span><br><span class="line">        arr.append(r)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''交集：使用列表解析'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set([i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i <span class="keyword">in</span> b]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''交集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).intersection(set(b)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''并集：使用列表相加'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a + b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''并集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).union(set(b)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''差集：使用列表解析'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set([i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> b]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''差集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).difference(set(b)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = rand_int_arr(<span class="number">10</span>)</span><br><span class="line">    b = rand_int_arr(<span class="number">10</span>)</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    r1 = intersection1(a, b)</span><br><span class="line">    print(<span class="string">'交集：使用列表解析'</span>, r1)</span><br><span class="line">    r2 = intersection2(a, b)</span><br><span class="line">    print(<span class="string">'交集：使用自带函数'</span>, r2)</span><br><span class="line">    r3 = union1(a, b)</span><br><span class="line">    print(<span class="string">'并集：使用列表相加'</span>, r3)</span><br><span class="line">    r4 = union2(a, b)</span><br><span class="line">    print(<span class="string">'并集：使用自带函数'</span>, r4)</span><br><span class="line">    r5 = difference1(a, b)</span><br><span class="line">    print(<span class="string">'差集：使用列表解析'</span>, r5)</span><br><span class="line">    r6 = difference2(a, b)</span><br><span class="line">    print(<span class="string">'差集：使用自带函数'</span>, r6)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># [5, 8, 13, 0, 7, 16, 13, 2, 2, 7]</span></span><br><span class="line">    <span class="comment"># [11, 10, 6, 17, 7, 13, 2, 16, 10, 13]</span></span><br><span class="line">    <span class="comment"># 交集：使用列表解析 [16, 2, 13, 7]</span></span><br><span class="line">    <span class="comment"># 交集：使用自带函数 [16, 2, 13, 7]</span></span><br><span class="line">    <span class="comment"># 并集：使用列表相加 [0, 2, 5, 6, 7, 8, 10, 11, 13, 16, 17]</span></span><br><span class="line">    <span class="comment"># 并集：使用自带函数 [0, 2, 5, 6, 7, 8, 10, 11, 13, 16, 17]</span></span><br><span class="line">    <span class="comment"># 差集：使用列表解析 [8, 0, 5]</span></span><br><span class="line">    <span class="comment"># 差集：使用自带函数 [0, 8, 5]</span></span><br></pre></td></tr></table></figure><p>除了并集可以通过列表相加实现，其他的如果不用函数就需要用到列表解析，下面我们来对比下速度</p><p>将 a 和 b 的长度改为 10000，将随机数的幅度也改了 10000，运行以下程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 列表的交集、并集、差集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rand_int_arr</span><span class="params">(length)</span>:</span></span><br><span class="line">    arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        r = random.randrange(<span class="number">10000</span>)</span><br><span class="line">        arr.append(r)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''交集：使用列表解析'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set([i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i <span class="keyword">in</span> b]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''交集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).intersection(set(b)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''并集：使用列表相加'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a + b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''并集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).union(set(b)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''差集：使用列表解析'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set([i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> b]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">'''差集：使用自带函数'''</span></span><br><span class="line">    <span class="keyword">return</span> list(set(a).difference(set(b)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = rand_int_arr(<span class="number">10000</span>)</span><br><span class="line">    b = rand_int_arr(<span class="number">10000</span>)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r1 = intersection1(a, b)</span><br><span class="line">    print(<span class="string">'交集：使用列表解析'</span>, time.clock() - begin)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r2 = intersection2(a, b)</span><br><span class="line">    print(<span class="string">'交集：使用自带函数'</span>, time.clock() - begin)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r3 = union1(a, b)</span><br><span class="line">    print(<span class="string">'并集：使用列表相加'</span>, time.clock() - begin)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r4 = union2(a, b)</span><br><span class="line">    print(<span class="string">'并集：使用自带函数'</span>, time.clock() - begin)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r5 = difference1(a, b)</span><br><span class="line">    print(<span class="string">'差集：使用列表解析'</span>, time.clock() - begin)</span><br><span class="line">    begin = time.clock()</span><br><span class="line">    r6 = difference2(a, b)</span><br><span class="line">    print(<span class="string">'差集：使用自带函数'</span>, time.clock() - begin)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  交集：使用列表解析 0.9532590000000001</span></span><br><span class="line"><span class="comment">#  交集：使用自带函数 0.002062999999999926</span></span><br><span class="line"><span class="comment">#  并集：使用列表相加 0.0010879999999999779</span></span><br><span class="line"><span class="comment">#  并集：使用自带函数 0.0022370000000000445</span></span><br><span class="line"><span class="comment">#  差集：使用列表解析 0.9966799999999998</span></span><br><span class="line"><span class="comment">#  差集：使用自带函数 0.0014449999999999186</span></span><br></pre></td></tr></table></figure><p>通过这个结果看，列表解析和函数相比，还是函数的速度快很多，并且不是一个量级的，而在并集中列表相加则比函数要快一些，但是幅度并不大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中列表的交集、并集、差集可以有两种方式，列表解析和 set 的函数&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Android 远程调试命令 adb</title>
    <link href="http://wxnacy.com/2019/03/11/adb/"/>
    <id>http://wxnacy.com/2019/03/11/adb/</id>
    <published>2019-03-11T08:28:59.000Z</published>
    <updated>2019-03-12T03:04:51.242Z</updated>
    
    <content type="html"><![CDATA[<p>adb 是 Android 的远程调试命令，在 Android 打开 USB 调试模式或直接打开 ADB 功能，就可以用 shell 命令来控制系统。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#android-da-kai-usb-diao-shi">Android 打开 USB 调试</a></li><li><a href="#an-zhuang-adb">安装 adb</a><ul><li><a href="#mac-os-x">Mac OS X</a></li></ul></li><li><a href="#lian-jie-she-bei">链接设备</a></li><li><a href="#shi-yong-shell-ming-ling">使用 shell 命令</a></li><li><a href="#bao-guan-li">包管理</a></li><li><a href="#jin-cheng-guan-li">进程管理</a></li><li><a href="#geng-duo-ming-ling">更多命令</a></li></ul><!-- tocstop --></div><h2><span id="android-da-kai-usb-diao-shi">Android 打开 USB 调试</span><a href="#android-da-kai-usb-diao-shi" class="header-anchor"></a></h2><p>打开 Android 系统的开发者模式的通用模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.打开“设置”应用，然后滚动到底部。</span><br><span class="line">2.如果它没有“开发者选项”设置，请点击“关于手机”（或“关于平板电脑”），滚动到底部，然后点击内置版本号7次。</span><br><span class="line">3.返回并点击开发者选项。</span><br><span class="line">4.启用 USB 调试。</span><br></pre></td></tr></table></figure><h2><span id="an-zhuang-adb">安装 adb</span><a href="#an-zhuang-adb" class="header-anchor"></a></h2><h3><span id="mac-os-x">Mac OS X</span><a href="#mac-os-x" class="header-anchor"></a></h3><p>使用 brew 可以很简单的安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install android-platform-tools</span><br><span class="line">$ adb devices</span><br></pre></td></tr></table></figure><p>随后就可以使用 adb 命令，不需要在配置各种环境变量</p><p>其他安装方式见 <a href="https://stackoverflow.com/questions/17901692/set-up-adb-on-mac-os-x" target="_blank" rel="noopener">Set up adb on Mac OS X</a></p><h2><span id="lian-jie-she-bei">链接设备</span><a href="#lian-jie-she-bei" class="header-anchor"></a></h2><p><strong>启动服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb start-server</span><br></pre></td></tr></table></figure><p><strong>查看设备列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line"></span><br><span class="line">List of devices attached</span><br><span class="line">emulator-5554   device</span><br></pre></td></tr></table></figure><p><strong>关闭服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb <span class="built_in">kill</span>-server</span><br></pre></td></tr></table></figure><p><strong>链接设备</strong></p><p>当设备没有出现在设备列表中时，我们可以手动链接设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb connect &lt;ip&gt;:5555</span><br></pre></td></tr></table></figure><p>Android 的 uiautomator 模块默认使用了 5555 端口号</p><p>链接成功后，设备会出现在设备列表中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line"></span><br><span class="line">List of devices attached</span><br><span class="line">10.0.2.1:5555   device</span><br><span class="line">emulator-5554   device</span><br></pre></td></tr></table></figure><h2><span id="shi-yong-shell-ming-ling">使用 shell 命令</span><a href="#shi-yong-shell-ming-ling" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">root@x86:/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>当有一个设备时，默认链接，如果有多个设备，需要指定设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb -s 10.0.2.1:5555 shell</span><br><span class="line">root@x86:/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如果不想每次都手动指定，可以设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_SERIAL=<span class="string">"DC886B75"</span></span><br></pre></td></tr></table></figure><p>shell 登陆后即可使用常见的脚本命令，比如 <code>ls</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">root@x86:/ <span class="comment"># ls</span></span><br><span class="line">mnt</span><br><span class="line">lib</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果只是执行简单的命令，我们也可以直接在本地执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell ls</span><br><span class="line">mnt</span><br><span class="line">lib</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2><span id="bao-guan-li">包管理</span><a href="#bao-guan-li" class="header-anchor"></a></h2><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ adb install test.apk</span><br><span class="line">$ adb install -l test.apk     <span class="comment"># forward lock application</span></span><br><span class="line">$ adb install -r test.apk     <span class="comment"># replace existing application</span></span><br><span class="line">$ adb install -t test.apk     <span class="comment"># allow test packages</span></span><br><span class="line">$ adb install -s test.apk     <span class="comment"># install application on sdcard</span></span><br><span class="line">$ adb install -d test.apk     <span class="comment"># allow version code downgrade</span></span><br><span class="line">$ adb install -p test.apk     <span class="comment"># partial application install</span></span><br></pre></td></tr></table></figure><p><strong>卸载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb uninstall com.test.app</span><br><span class="line">$ adb uninstall -k com.test.app <span class="comment"># Keep the data and cache directories around after package removal.</span></span><br></pre></td></tr></table></figure><p><strong>查看包安装列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell pm list packages</span><br><span class="line">$ adb shell pm list packages -f   <span class="comment"># See their associated file.</span></span><br><span class="line">$ adb shell pm list packages -d   <span class="comment"># Filter to only show disabled packages.</span></span><br><span class="line">$ adb shell pm list packages -e   <span class="comment"># Filter to only show enabled packages.</span></span><br><span class="line">$ adb shell pm list packages -s   <span class="comment"># Filter to only show system packages.</span></span><br><span class="line">$ adb shell pm list packages -3   <span class="comment"># Filter to only show third party packages.</span></span><br><span class="line">$ adb shell pm list packages -i   <span class="comment"># See the installer for the packages.</span></span><br><span class="line">$ adb shell pm list packages -u   <span class="comment"># Also include uninstalled packages.</span></span><br><span class="line">$ adb shell pm list packages --user &lt;USER_ID&gt; <span class="comment"># The user space to query.</span></span><br></pre></td></tr></table></figure><p><strong>包路径</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell pm path com.android.phone</span><br><span class="line">package:/system/priv-app/TeleService/TeleService.apk</span><br></pre></td></tr></table></figure><p><strong>清除数据和缓存</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell pm clear com.test.abc</span><br></pre></td></tr></table></figure><h2><span id="jin-cheng-guan-li">进程管理</span><a href="#jin-cheng-guan-li" class="header-anchor"></a></h2><p><strong>启动应用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell 进入 Android</span><br><span class="line">$ am start -n &lt;package-name&gt;/&lt;package-name&gt;.&lt;activity-name&gt;</span><br></pre></td></tr></table></figure><p>一些系统应用打开方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日历</span></span><br><span class="line">$ am start -n com.android.calendar/com.android.calendar.LaunchActivity</span><br><span class="line"><span class="comment"># 闹钟</span></span><br><span class="line">$ am start -n com.android.alarmclock/com.android.alarmclock.AlarmClock</span><br><span class="line"><span class="comment"># 音乐和视频</span></span><br><span class="line">$ am start -n com.android.music/com.android.music.MusicBrowserActivity</span><br><span class="line">$ am start -n com.android.music/com.android.music.VideoBrowserActivity</span><br><span class="line">$ am start -n com.android.music/com.android.music.MediaPlaybackActivity</span><br><span class="line"><span class="comment"># 照相机</span></span><br><span class="line">$ am start -n com.android.camera/com.android.camera.Camera</span><br><span class="line"><span class="comment"># 浏览器</span></span><br><span class="line">$ am start -n com.android.browser/com.android.browser.BrowserActivity</span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">$ am start -a android.intent.action.VIEW -d  http://www.google.cn/</span><br><span class="line"><span class="comment"># 拨打电话</span></span><br><span class="line">$ am start -a android.intent.action.CALL -d tel:10086</span><br></pre></td></tr></table></figure><p>这里有个问题，我们可以通过 <code>pm</code> 命令查到 apk 的包名，但是 <code>activity</code> 就不方便知道了，我们希望只通过包名就能启动应用，从网上查到这个方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ am start -a android.intent.action.MAIN -n &lt;package-name&gt;</span><br></pre></td></tr></table></figure><p>但是这种方式，我在模拟器中只可以打开系统应用，第三方应用会报错，再次查找发现可以使用 <code>monkey</code> 命令来启动应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ monkey -p &lt;package-name&gt; -c android.intent.category.LAUNCHER 1</span><br></pre></td></tr></table></figure><p>经过测试，这种方式是比较方便打开各种应用</p><p><strong>杀掉应用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ am force-stop &lt;package-name&gt;</span><br></pre></td></tr></table></figure><p><strong>杀掉所有后台进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ am <span class="built_in">kill</span>-all</span><br></pre></td></tr></table></figure><h2><span id="geng-duo-ming-ling">更多命令</span><a href="#geng-duo-ming-ling" class="header-anchor"></a></h2><p><strong>推送文件到设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb push test.apk /data</span><br></pre></td></tr></table></figure><p><strong>拉取设备的文件到本地</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb pull /data/test.apk</span><br><span class="line">$ adb pull /data/test.apk ~/Downloads</span><br></pre></td></tr></table></figure><p><strong>查看设备 SSN 号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell getprop | grep ro.boot.serialno</span><br></pre></td></tr></table></figure><p><strong>参考</strong></p><ul><li><a href="http://adbshell.com/commands" target="_blank" rel="noopener">adb</a></li><li><a href="https://blog.csdn.net/u012041204/article/details/53957664" target="_blank" rel="noopener">Android使用ADB启动应用程序</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;adb 是 Android 的远程调试命令，在 Android 打开 USB 调试模式或直接打开 ADB 功能，就可以用 shell 命令来控制系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wxnacy.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Go 自动打开系统默认浏览器</title>
    <link href="http://wxnacy.com/2019/03/04/go-open-brower/"/>
    <id>http://wxnacy.com/2019/03/04/go-open-brower/</id>
    <published>2019-03-04T05:48:03.000Z</published>
    <updated>2019-03-04T05:48:03.181Z</updated>
    
    <content type="html"><![CDATA[<p>因为 Go 可以编译 <code>Windows</code> <code>Darwin</code> <code>Linux</code> 三个平台的二进制文件，如果编写一个 Web 项目，启动后可以自动打开浏览器，那就非常方便了。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>首先看下三个平台打开浏览器的命令</p><p><strong>Darwin</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ open http://baidu.com</span><br></pre></td></tr></table></figure><p><strong>Windows</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ start http://baidu.com</span><br></pre></td></tr></table></figure><p><strong>Linux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xdg-open http://baidu.com</span><br></pre></td></tr></table></figure><p>接下来需要 Go 能区分平台，这里需要 <code>runtime</code> 包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"runtime"</span></span><br><span class="line">platform := runtime.GOOS</span><br><span class="line">// darwin windows linux</span><br></pre></td></tr></table></figure><p>好接下来就可以写代码了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// 打开系统默认浏览器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os/exec"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> commands = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"windows"</span>: <span class="string">"start"</span>,</span><br><span class="line">    <span class="string">"darwin"</span>:  <span class="string">"open"</span>,</span><br><span class="line">    <span class="string">"linux"</span>:   <span class="string">"xdg-open"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(uri <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    run, ok := commands[runtime.GOOS]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"don't know how to open things on %s platform"</span>, runtime.GOOS)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmd := exec.Command(run, uri)</span><br><span class="line">    <span class="keyword">return</span> cmd.Start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Open(<span class="string">"http://baidu.com"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为 Go 可以编译 &lt;code&gt;Windows&lt;/code&gt; &lt;code&gt;Darwin&lt;/code&gt; &lt;code&gt;Linux&lt;/code&gt; 三个平台的二进制文件，如果编写一个 Web 项目，启动后可以自动打开浏览器，那就非常方便了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="http://wxnacy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go Web 框架 iris 简单入门</title>
    <link href="http://wxnacy.com/2019/03/01/go-iris-simple/"/>
    <id>http://wxnacy.com/2019/03/01/go-iris-simple/</id>
    <published>2019-03-01T09:22:15.000Z</published>
    <updated>2019-03-01T09:22:15.925Z</updated>
    
    <content type="html"><![CDATA[<p>作为后端开发，初识一门语言时，选一款合适的 Web 框架是很有必要的。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#xia-zai">下载</a></li><li><a href="#hello-world">Hello World</a></li><li><a href="#ri-zhi-shu-chu">日志输出</a></li><li><a href="#template-shi-yong">template 使用</a></li><li><a href="#geng-duo-de-method">更多的 method</a></li></ul><!-- tocstop --></div><p>经过这篇文章 <a href="https://studygolang.com/articles/11897?fr=sidebar" target="_blank" rel="noopener">6 款最棒的 Go 语言 Web 框架简介</a>的介绍，有理由相信 <a href="https://github.com/kataras/iris" target="_blank" rel="noopener">iris</a> 是目前最优秀的 Web 框架，今天简单了解下这个框架的使用。</p><h2><span id="xia-zai">下载</span><a href="#xia-zai" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u github.com/kataras/iris</span><br></pre></td></tr></table></figure><h2><span id="hello-world">Hello World</span><a href="#hello-world" class="header-anchor"></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/kataras/iris"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app *iris.Application</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app = iris.Default()</span><br><span class="line">    app.Get(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span> &#123;</span><br><span class="line">        ctx.JSON(iris.Map&#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"Hello World"</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// listen and serve on http://0.0.0.0:8080.</span></span><br><span class="line">    app.Run(iris.Addr(<span class="string">":8080"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化和路由配置都很简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">$ http :8080/hello</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 25</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Date: Thu, 28 Feb 2019 07:25:00 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"Hello World"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="ri-zhi-shu-chu">日志输出</span><a href="#ri-zhi-shu-chu" class="header-anchor"></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/kataras/iris"</span></span><br><span class="line">    <span class="string">"github.com/kataras/iris/middleware/logger"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app *iris.Application</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app = iris.Default()</span><br><span class="line">    app.Use(logger.New())</span><br><span class="line">    app.Logger().SetLevel(<span class="string">"debug"</span>)</span><br><span class="line">    app.Get(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span> &#123;</span><br><span class="line">        app.Logger().Debug(<span class="string">"Hello World"</span>)</span><br><span class="line">        app.Logger().Info(<span class="string">"Hello World"</span>)</span><br><span class="line">        app.Logger().Error(<span class="string">"Hello World"</span>)</span><br><span class="line">        ctx.JSON(iris.Map&#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"Hello World"</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// listen and serve on http://0.0.0.0:8080.</span></span><br><span class="line">    app.Run(iris.Addr(<span class="string">":8080"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="template-shi-yong">template 使用</span><a href="#template-shi-yong" class="header-anchor"></a></h2><p>使项目目录结构如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── main.go</span><br><span class="line">├── static</span><br><span class="line">│   └── hello.js</span><br><span class="line">└── templates</span><br><span class="line">    └── index.html</span><br></pre></td></tr></table></figure><p>注册 template 目录和匹配文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.RegisterView(iris.HTML(<span class="string">"./templates"</span>, <span class="string">".html"</span>))</span><br></pre></td></tr></table></figure><p>初始化静态文件目录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.StaticWeb(<span class="string">"static"</span>, <span class="string">"./static"</span>)</span><br></pre></td></tr></table></figure><p>传递 template 变量，并显示页面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.Get(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span> &#123;</span><br><span class="line">    ctx.ViewData(<span class="string">"name"</span>, <span class="string">"wxnacy"</span>)</span><br><span class="line">    ctx.View(<span class="string">"index.html"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">$ http :8080/index</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 129</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Thu, 28 Feb 2019 07:56:57 GMT</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  Hello wxnacy</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">$ http :8080/static/hello.js</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 51</span><br><span class="line">Content-Type: application/javascript; charset=UTF-8</span><br><span class="line">Date: Thu, 28 Feb 2019 07:57:33 GMT</span><br><span class="line">Last-Modified: Thu, Feb 28 2019 07:47:22 GMT</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hello</span></span>()&#123;</span><br><span class="line">  console.log(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整代码地址：<a href="https://github.com/wxnacy/study/tree/master/goland/src/iris_examples/mvc-templates" target="_blank" rel="noopener">https://github.com/wxnacy/study/tree/master/goland/src/iris_examples/mvc-templates</a></p><h2><span id="geng-duo-de-method">更多的 method</span><a href="#geng-duo-de-method" class="header-anchor"></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.Post(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;) -&gt; <span class="keyword">for</span> POST http method.</span><br><span class="line">app.Put(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"PUT"</span> http method.</span><br><span class="line">app.Delete(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"DELETE"</span> http method.</span><br><span class="line">app.Options(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"OPTIONS"</span> http method.</span><br><span class="line">app.Trace(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"TRACE"</span> http method.</span><br><span class="line">app.Head(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"HEAD"</span> http method.</span><br><span class="line">app.Connect(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"CONNECT"</span> http method.</span><br><span class="line">app.Patch(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;)-&gt; <span class="keyword">for</span> <span class="string">"PATCH"</span> http method.</span><br><span class="line">app.Any(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span>&#123;&#125;) <span class="keyword">for</span> all http methods.</span><br></pre></td></tr></table></figure><p><a href="https://github.com/iris-contrib/examples" target="_blank" rel="noopener">更多例子</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为后端开发，初识一门语言时，选一款合适的 Web 框架是很有必要的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="http://wxnacy.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>简单了解非对称加密算法</title>
    <link href="http://wxnacy.com/2019/02/28/asymmetric-encryption/"/>
    <id>http://wxnacy.com/2019/02/28/asymmetric-encryption/</id>
    <published>2019-02-28T02:01:48.000Z</published>
    <updated>2019-02-28T02:01:48.056Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们要讲的是非对称加密算法。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#why">why</a></li><li><a href="#what">what</a></li><li><a href="#how">how</a></li></ul><!-- tocstop --></div><p>课程分三个步骤</p><ul><li>为什么要用到非对称加密算法(why)</li><li>什么是非对称加密算法(what)</li><li>如何用 Python 实现加密算法(how)</li></ul><h2><span id="why">why</span><a href="#why" class="header-anchor"></a></h2><p>非对称加密提供了数据加密和数字签名两个功能。</p><p>而这两个功能分别有更简单的实现方式对称加密和散列运算。</p><p>那为什么还需要非对称加密呢？</p><p>先来看一个例子。</p><p>小明和小红是一对恋人，他们分居上海和北京，路途遥远不便见面，只能通过网络联系，这种方式快捷方便，开始两人并没有觉得不妥。</p><p>有一天两人到了谈婚论嫁的年纪，开始讨论结婚事宜，说到了彩礼的事情。</p><p>小明很有安全意识，他觉得涉及到钱的问题，应该小心翼翼，网络并不安全，如果谈的是 5 万，结果在网络中被人篡改了，变成 10 万怎么办？他想到了使用数字签名的方式，将数据进行 MD5 加密，并将加密过的签名，一起发给小红，并让小红对数据再次使用 MD5 加密，并将自己计算的结果跟小明发过来的进行对比，一致则数据没有被篡改。</p><p>在这个方案下，两人安全的将结婚事宜谈妥，小红很高兴，想对小明说些悄悄话，但是她又不想让网络中其他人听到她说的是什么。她想到了数据加密的方式，她先将要说的话使用 AES 算法做对称加密，然后将加密后密文和加密使用的秘钥发给小明，然后小明使用秘钥对密文进行解密，即可看到小红要说的话。</p><p>然而事情真的像他们想的这么安全吗？</p><p>小明的签名算法必须是公开的，小红才能用相同的算法验证，只要是公开的，别人就可以使用相同的算法，先将明文篡改，再对新明文进行签名再发给小红，这样小红验证到的只是被篡改的数据。</p><p>同样的道理，小红的对称加密算法，想要让小明对其进行解密，必须将加密用的秘钥公开出来。这样小明可以解密，别人也可以解密。</p><p>那怎么解决呢？你会想不公开不就行了吗，小明自己写一个签名算法偷偷告诉小红，小红将加密的秘钥偷偷告诉小明。说起来简单，做起来难，怎么偷偷告诉？小明先坐飞机到北京告诉小红，然后每次发现算法有漏洞，修改算法后在坐飞机到北京？</p><p>没有必要，此时非对称加密可以出场了。</p><h2><span id="what">what</span><a href="#what" class="header-anchor"></a></h2><p>什么是非对称加密？</p><p>对称加密是用相同的秘钥对数据进行加解密，那非对称加密顾名思义就是用不同的秘钥对数据进行加解密。</p><p>非对称加密算法有两个秘钥，公有秘钥和私有秘钥，两个秘钥是一对。每个人都可以生成属于自己的公私钥，公钥可以公布给任何人知道，所以它也叫公开密钥算法，私钥只能自己保留，不能泄露。</p><p>现在我们再来看小明的问题，小明使用非对称加密算法做数字签名，他先使用私钥将明文做签名，然后将明文、签名和公钥一起发给小红，小红可以使用公钥对签名进行验证。此时其他及时拿到了公钥也无济于事，因为<strong><em>签名只能使用私钥</em></strong>。</p><p>而小红的问题也很简单，她可以使用小明的公钥对明文进行加密，再将密文发给小明，小明使用自己的私钥对数据进行解密，即可拿到明文。此时其他人及时拿到公钥和密文也无济于事，因为<strong><em>公钥加密的密文只能用对应的秘钥进行解密</em></strong></p><p>然后小红再生成自己的公私钥，双方互换公钥，各自保留私钥，加密和签名双管齐下，互发消息都可以做到非常安全。</p><p>总结一下</p><p>公钥用来加密，对应秘钥解密<br>私钥用来签名，对应公钥验证</p><h2><span id="how">how</span><a href="#how" class="header-anchor"></a></h2><p>下面我们来看看如何使用 Python 实现加密算法</p><p><strong>生成公私钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C your_email</span><br></pre></td></tr></table></figure><p><strong>安装依赖</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pycrypto</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><ul><li><a href="https://github.com/wxnacy/study/blob/master/python/crypto_demo/rsa_cipher.py" target="_blank" rel="noopener">加解密</a></li><li><a href="https://github.com/wxnacy/study/blob/master/python/crypto_demo/rsa_signature.py" target="_blank" rel="noopener">签名验证</a></li></ul><p><strong>youtube 视频</strong></p><iframe width="560" height="315" src="https://www.youtube.com/embed/OKIfTOEo7P0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><strong>youku 视频</strong></p><iframe height="498" width="510" src="http://player.youku.com/embed/XNDA2Nzg3NTY4MA==" frameborder="0" 'allowfullscreen'=""></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们要讲的是非对称加密算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://wxnacy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux Tab 命令提示时忽略大小写</title>
    <link href="http://wxnacy.com/2019/02/27/linux-caseignore/"/>
    <id>http://wxnacy.com/2019/02/27/linux-caseignore/</id>
    <published>2019-02-27T01:56:39.000Z</published>
    <updated>2019-02-27T02:01:37.183Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 环境如何不装 <code>zsh</code> 等更加智能的 bash 工具，通常在 Tab 键提示命令时都会区分大小写，这样很不方便，我们可以做点简单修改让它忽略大小写。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>默认情况下 <code>~</code> 目录下是没有 <code>.inputrc</code> 文件的，手动创建并赋值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'set completion-ignore-case on'</span> &gt;&gt; .inputrc</span><br></pre></td></tr></table></figure><p>然后退出终端，重新进入，这时命令行已经忽略大小写了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 环境如何不装 &lt;code&gt;zsh&lt;/code&gt; 等更加智能的 bash 工具，通常在 Tab 键提示命令时都会区分大小写，这样很不方便，我们可以做点简单修改让它忽略大小写。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Vim8 内置插件管理方案</title>
    <link href="http://wxnacy.com/2019/02/26/vim8-pack/"/>
    <id>http://wxnacy.com/2019/02/26/vim8-pack/</id>
    <published>2019-02-26T09:42:43.000Z</published>
    <updated>2019-02-26T10:05:43.418Z</updated>
    
    <content type="html"><![CDATA[<p>Vim8，更新到这个版本，Vim 终于有自己的插件管理方案，引入了 <code>packages</code> 的概念。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>如果你对 <a href="/2017/09/20/vim-plugin-pathogen/">pathogen</a> 了解的话，应该会很喜欢这种方案，跟它一样，你只需要将插件扔到指定的目录下，Vim 会自动加载这个插件。</p><p>假如你有插件 <code>nerdtree</code>，现在只需要在放在 <code>~/.vim/pack/vendor/start/</code> 目录下即可。</p><p>Vim8 会自动加载 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/start/</span><br></pre></td></tr></table></figure><p>目录下的插件，换句话说我也可以把它放在 <code>~/.vim/pack/foo/start/</code> 下，<code>*</code> 所代表的目录是任意值。</p><p>而那些我们不想自动加载的插件可以放到 <code>opt</code> 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/opt</span><br></pre></td></tr></table></figure><p>随后在 <code>~/.vimrc</code> 中使用 <code>packadd</code> 来手动加载插件，有应用场景如下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> foo_compiler_version &gt; <span class="number">34</span></span><br><span class="line">    packadd foo_new</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    packadd foo_old</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>我们可以根据某个编译版本来选择使用插件的版本。</p><p>查看文档 <code>:h packages</code> 获取更多信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vim8，更新到这个版本，Vim 终于有自己的插件管理方案，引入了 &lt;code&gt;packages&lt;/code&gt; 的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Mysql insert ... on duplicate key update 的用法及在 SQLAlchemy 中的使用</title>
    <link href="http://wxnacy.com/2019/02/24/mysql-insert-on-duplicate-key-update/"/>
    <id>http://wxnacy.com/2019/02/24/mysql-insert-on-duplicate-key-update/</id>
    <published>2019-02-24T04:09:12.000Z</published>
    <updated>2019-02-24T04:53:03.357Z</updated>
    
    <content type="html"><![CDATA[<p>在项目高并发时，很容易出现数据库插入相同数据的情况，虽然可以使用唯一索引避免插入相同数据，但是不断的程序报错也是我们也避免的。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#yu-fa">语法</a></li><li><a href="#sqlalchemy-zhong-de-shi-yong">SQLAlchemy 中的使用</a></li></ul><!-- tocstop --></div><h2><span id="yu-fa">语法</span><a href="#yu-fa" class="header-anchor"></a></h2><p>使用 <code>insert ... on duplicate key update ..</code> 语法可以避免这种情况，举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists `test`;</span><br><span class="line">create table `test` (</span><br><span class="line">`id` int(11) not null AUTO_INCREMENT,</span><br><span class="line">`name` varchar(32) not null default &apos;&apos;,</span><br><span class="line">`update_ts` timestamp not null default current_timestamp(),</span><br><span class="line">primary key (`id`)</span><br><span class="line">) engine=InnoDB default charset=utf8mb4;</span><br></pre></td></tr></table></figure><p>主键 <code>id</code> 是天然的唯一索引，我们插入重复数据时会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT INTO test (id, name) VALUES (1, &apos;wxnacy&apos;);</span><br><span class="line">&gt; INSERT INTO test (id, name) VALUES (1, &apos;wxnacy&apos;);</span><br><span class="line">Error 1062: Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos;</span><br></pre></td></tr></table></figure><p>查看数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">|------------------------------------</span><br><span class="line">| 1  | wxnacy | 2019-02-24 12:26:58 |</span><br></pre></td></tr></table></figure><p>下面我们来换个语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; insert into test (id, name) values (1, &apos;wxnacy&apos;) on duplicate key update update_ts = current_timestamp();</span><br><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line"></span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">|  1 | wxnacy | 2019-02-24 12:31:49 |</span><br><span class="line">+----+--------+---------------------+</span><br></pre></td></tr></table></figure><p><code>on duplicate key update</code> 前面是正常的插入语句，其后跟着的是当唯一索引冲突时，想要更新的数据。</p><p>再换个使用场景，如果我想让数据库中用户名是唯一的，则可以先建立唯一索引，在使用该语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; alter table test add unique index_name (name);</span><br><span class="line">&gt; insert into test (name) values (&apos;wenn&apos;) on duplicate key update update_ts = current_timestamp();</span><br><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">|  1 | wxnacy | 2019-02-24 12:31:49 |</span><br><span class="line">|  2 | wenn   | 2019-02-24 12:39:25 |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line"></span><br><span class="line">&gt; insert into test (name) values (&apos;wenn&apos;) on duplicate key update update_ts = current_timestamp();</span><br><span class="line">&gt; SELECT * FROM `test`;</span><br><span class="line"></span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">| id | name   | update_ts           |</span><br><span class="line">+----+--------+---------------------+</span><br><span class="line">|  1 | wxnacy | 2019-02-24 12:31:49 |</span><br><span class="line">|  2 | wenn   | 2019-02-24 12:40:15 |</span><br><span class="line">+----+--------+---------------------+</span><br></pre></td></tr></table></figure><p>这样及保证了避免插入重复数据，同时程序也没有报错，我还可以根据 <code>update</code> 的数据来分析问题的根源。</p><h2><span id="sqlalchemy-zhong-de-shi-yong">SQLAlchemy 中的使用</span><a href="#sqlalchemy-zhong-de-shi-yong" class="header-anchor"></a></h2><p>这个功能需要 SQLAlchemy 1.2 版本以上才支持，官方的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.dialects.mysql <span class="keyword">import</span> insert</span><br><span class="line"></span><br><span class="line">insert_stmt = insert(my_table). \</span><br><span class="line">    values(id=<span class="string">'some_id'</span>, data=<span class="string">'some data to insert'</span>)</span><br><span class="line"></span><br><span class="line">on_conflict_stmt = insert_stmt.on_duplicate_key_update(</span><br><span class="line">    data=insert_stmt.inserted.data,</span><br><span class="line">    status=<span class="string">'U'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">conn.execute(on_conflict_stmt)</span><br></pre></td></tr></table></figure><p>析出的 sql 语句为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO my_table (id, data)</span><br><span class="line">VALUES (:id, :data)</span><br><span class="line">ON DUPLICATE KEY UPDATE data=VALUES(data), status=:status_1</span><br></pre></td></tr></table></figure><p>参考资料</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html" target="_blank" rel="noopener">INSERT … ON DUPLICATE KEY UPDATE Syntax</a></li><li><a href="https://docs.sqlalchemy.org/en/latest/changelog/migration_12.html#support-for-insert-on-duplicate-key-update" target="_blank" rel="noopener">Support for INSERT..ON DUPLICATE KEY UPDATE</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目高并发时，很容易出现数据库插入相同数据的情况，虽然可以使用唯一索引避免插入相同数据，但是不断的程序报错也是我们也避免的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://wxnacy.com/tags/mysql/"/>
    
      <category term="sqlalchemy" scheme="http://wxnacy.com/tags/sqlalchemy/"/>
    
  </entry>
  
  <entry>
    <title>Vimscript 判断文件是否存在</title>
    <link href="http://wxnacy.com/2019/02/21/vimscript-file-exists/"/>
    <id>http://wxnacy.com/2019/02/21/vimscript-file-exists/</id>
    <published>2019-02-21T10:28:52.000Z</published>
    <updated>2019-02-26T13:25:50.185Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>~/.vimrc</code> 我希望可以通过判断当前环境是否含有某插件，再加载相应的参数配置，此时可以通过判断文件是否存在来完成。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">filereadable</span>(<span class="string">'test.txt'</span>)    <span class="string">" 判断文件是否存在"</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'file is exists'</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>文件路径可以加上环境变量，用 <code>.</code> 链接</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME . <span class="string">'/.vim/bundle/jedi-vim/Makefile'</span></span><br></pre></td></tr></table></figure><p>或者使用 <code>expand()</code> 函数</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">expand</span>(<span class="string">"$HOME/.vim/bundle/jedi-vim/Makefile"</span>)</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">filereadable</span>(<span class="built_in">expand</span>(<span class="string">"$HOME/.vim/bundle/jedi-vim/Makefile"</span>))    <span class="string">" 判断文件是否存在"</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'jedi-vim is exists'</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;~/.vimrc&lt;/code&gt; 我希望可以通过判断当前环境是否含有某插件，再加载相应的参数配置，此时可以通过判断文件是否存在来完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
</feed>
