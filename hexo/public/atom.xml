<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-05-05T11:48:47.296Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 使用 memory_profiler 分析程序内存占用情况</title>
    <link href="http://wxnacy.com/2019/05/05/python-memory-profiler/"/>
    <id>http://wxnacy.com/2019/05/05/python-memory-profiler/</id>
    <published>2019-05-05T09:18:09.000Z</published>
    <updated>2019-05-05T11:48:47.296Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中可以使用 memory_profiler 包来分析程序的内存占用情况</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#shi-yong">使用</a></li><li><a href="#can-shu-shi-yong">参数使用</a></li><li><a href="#mprof-ming-ling">mprof 命令</a></li></ul><!-- tocstop --></div><p>memory_profiler 可以分析每行代码的内存使用情况，使用起来非常简单。</p><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install memory_profiler</span><br></pre></td></tr></table></figure><h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    c = []</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * (<span class="number">2</span> ** <span class="number">20</span>)</span><br><span class="line">    b = [<span class="number">1</span>] * (<span class="number">2</span> ** <span class="number">20</span>)</span><br><span class="line">    c.extend(a)</span><br><span class="line">    c.extend(b)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    <span class="keyword">del</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test1()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m memory_profiler memory_profiler</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf1.png" alt="1"></p><p>结果如图，每一步的内存变化情况都很清楚</p><ul><li><code>Mem usage</code> 为当前总内存</li><li><code>Increment</code> 为增加的内存</li></ul><p>总结起来使用非常时间</p><ul><li>方法前加上 <code>@profile</code> 主键</li><li>使用 <code>python -m memory_profiler</code> 来运行，不过直接用 <code>python</code> 运行也可以</li></ul><p>通过上面这段代码我们可以发现，<code>del</code> 语句只是将变量删除，并不能减少内存的消耗。</p><h2><span id="can-shu-shi-yong">参数使用</span><a href="#can-shu-shi-yong" class="header-anchor"></a></h2><ul><li><code>precision</code> 显示小数点后的位数</li></ul><p>默认显示的内存单位为 <code>MiB</code>，小数点后显示一位，如果某行代码占用内存比较小，就可能显示不出来，此时可以通过调整小数点后的位数实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@profile(precision=4)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>] * (<span class="number">2</span> ** <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test3()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf3.png" alt="3"></p><ul><li><code>stream</code> 将结果输出到流中</li></ul><p>每次运行都要打印内存情况，势必会影响程序输出效果，我们可以将结果通过流输出到文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile(precision=4, @profile(precision=4, stream=open('/tmp/memory_profiler.log','w+')))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>] * (<span class="number">2</span> ** <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test3()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf4.png" alt="4"></p><h2><span id="mprof-ming-ling">mprof 命令</span><a href="#mprof-ming-ling" class="header-anchor"></a></h2><p>memory_profiler 本身也提供了命令行 <code>mprof</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Usage: mprof &lt;<span class="built_in">command</span>&gt; &lt;options&gt; &lt;arguments&gt;</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line"></span><br><span class="line">    run      运行给定的命令或 python 文件</span><br><span class="line">    rm       删除 mprof 生成的给定文件</span><br><span class="line">    clean    清除当前目录中 mprof 创建的文件</span><br><span class="line">    list     显示带索引的现有配置文件</span><br><span class="line">    plot     可以将 mprof run 的结果生成图片</span><br><span class="line"></span><br><span class="line">Type mprof &lt;<span class="built_in">command</span>&gt; --<span class="built_in">help</span> <span class="keyword">for</span> usage <span class="built_in">help</span> on a specific <span class="built_in">command</span>.</span><br><span class="line">For example, mprof plot --<span class="built_in">help</span> will list all plotting options.</span><br></pre></td></tr></table></figure><p>重点说一下 <code>plot</code> 命令，<code>run</code> 命令可以生成 <code>.dat</code> 文件，<code>plot</code> 可以将该文件生成图片，不过需要 <code>matplotlib</code> 包的加持。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pip install matplotlib</span><br><span class="line">$ mprof run memory_profiler_demo.py</span><br><span class="line">$ mprof list</span><br><span class="line">0 mprofile_20190505182200.dat 18:22:00 05/05/2019</span><br><span class="line">$ mprof plot mprofile_20190505182200.dat</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf5_1260.png" alt="5"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中可以使用 memory_profiler 包来分析程序的内存占用情况&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux time 命令统计脚本耗时</title>
    <link href="http://wxnacy.com/2019/04/29/linux-time/"/>
    <id>http://wxnacy.com/2019/04/29/linux-time/</id>
    <published>2019-04-29T04:10:22.000Z</published>
    <updated>2019-04-29T04:10:22.400Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 中 time 命令可以统计执行脚本的耗时。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>我们以 <a href="https://wxnacy.com/2019/02/01/linux-wc/">wc</a> 命令为例子，统计下计算文件行数时的耗时情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc -l tmd-error.log</span><br><span class="line">655572 tmd-error.log</span><br></pre></td></tr></table></figure><p>只需要在命令前加上 <code>time</code> 即可</p><p><strong>bash环境下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ time wc -l tmd-error.log</span><br><span class="line">  655572 tmd-error.log</span><br><span class="line"></span><br><span class="line">real    0m0.047s</span><br><span class="line">user    0m0.036s</span><br><span class="line">sys     0m0.011s</span><br></pre></td></tr></table></figure><p>得到的结果有三个时间，<code>real</code> 为真实耗时，而 <code>user</code> 和 <code>sys</code> 为用户环境和系统的各自耗时。</p><p><strong>zsh环境下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ time wc -l tmd-error.log</span><br><span class="line">  655572 tmd-error.log</span><br><span class="line">wc -l tmd-error.log  0.04s user 0.01s system 97% cpu 0.047 total</span><br></pre></td></tr></table></figure><p><code>zsh</code> 环境的输出结果不太易读，只需要看最后的 <code>total</code> 值即可</p><p><strong>fish环境下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wxnacy@wxnacydeMacBook-Pro ~/P/t/<span class="built_in">log</span>&gt; time wc -l tmd-error.log</span><br><span class="line">  655572 tmd-error.log</span><br><span class="line">        0.04 real         0.03 user         0.01 sys</span><br></pre></td></tr></table></figure><p>说实话还是 <code>fish</code> 环境的看着最舒服，要不是它不兼容 <code>bash</code> 脚本，我感觉它早就制霸 shell 届了，哼。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Linux 中 time 命令可以统计执行脚本的耗时。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 判断字符串是否为大写及 is 方法延伸</title>
    <link href="http://wxnacy.com/2019/04/28/python-isupper/"/>
    <id>http://wxnacy.com/2019/04/28/python-isupper/</id>
    <published>2019-04-28T13:16:02.000Z</published>
    <updated>2019-04-28T13:16:02.299Z</updated>
    
    <content type="html"><![CDATA[<p>Python 判断字符串是否为大写及延伸</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>以下方法仅判断字符，数字和符号不影响结果</p><p><strong>isupper()</strong> 判断是否都为大写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a!'</span>.isupper()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1A!'</span>.isupper()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>islower()</strong> 判断是否都为小写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1As!'</span>.islower()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1s!'</span>.islower()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>istitle()</strong> 判断所有的单词首字符都是大写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'This Is Upper'</span>.istitle()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'This Is upper1'</span>.istitle()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p><strong>isspace()</strong> 判断所有的字符都是空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'This Is upper1'</span>.isspace()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">' '</span>.isspace()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>isalnum()</strong> 判断所有的字符都是数字或字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a!'</span>.isalnum()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'aa'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'11'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>isalpha()</strong> 判断所有的字符都是字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'11'</span>.isalpha()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a'</span>.isalpha()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'aa'</span>.isalpha()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>isdigit()</strong> 判断所有的字符都是数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'aa'</span>.isdigit()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'11'</span>.isdigit()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a'</span>.isdigit()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>还有两个类似的方法 <strong>isdecimal()</strong> 和 <strong>isnumeric()</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 判断字符串是否为大写及延伸&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>awk 正则表达式中使用参数</title>
    <link href="http://wxnacy.com/2019/04/26/awk-regex-use-var/"/>
    <id>http://wxnacy.com/2019/04/26/awk-regex-use-var/</id>
    <published>2019-04-26T00:08:55.000Z</published>
    <updated>2019-04-26T00:08:55.487Z</updated>
    
    <content type="html"><![CDATA[<p>awk 使用正则表达式过滤文本时可以使用可变参数，我本认为这应该是很普遍的需求，然而网上找了一圈也没看到一个比较全面的教程，不过东拼西凑也总算是满足了需求，今天来总结下。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#ming-ling-xing-chuan-can">命令行传参</a></li><li><a href="#jiao-ben-zhong-chuan-can">脚本中传参</a></li></ul><!-- tocstop --></div><p>首先将当前文件列表导入到一份文本文件 <a href="https://raw.githubusercontent.com/wxnacy/file/master/common/text" target="_blank" rel="noopener">text</a> 中，作为测试使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ll &gt; text</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/awk1_548.png" alt="1"></p><h2><span id="ming-ling-xing-chuan-can">命令行传参</span><a href="#ming-ling-xing-chuan-can" class="header-anchor"></a></h2><p>首先我们打算过滤文件列表的最后修改时间为 <code>10</code> 点的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'/10/ &#123;print $0&#125;'</span> text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff    1052 Mar 13 22:50 awktest</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     100 Mar 25 22:53 b.py</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     121 Mar 14 10:19 test.go</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     106 Mar 13 10:53 test.js</span><br></pre></td></tr></table></figure><p>这样得到的结果并准确，我们应该精确的对第 8 行进行正则匹配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'$8 ~ /10/ &#123;print $0&#125;'</span> text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     121 Mar 14 10:19 test.go</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     106 Mar 13 10:53 test.js</span><br></pre></td></tr></table></figure><p>现在问题来了，我希望对 <code>10</code> 进行参数化，该怎么做呢？</p><p>awk 命令行模式可以直接使用 shell 参数，不过比较麻烦一点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hour=10</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$hour</span></span><br><span class="line">10</span><br><span class="line">$ awk <span class="string">'$8 ~ /'</span><span class="string">"<span class="variable">$hour</span>"</span><span class="string">'/ &#123;print $0&#125;'</span> text</span><br></pre></td></tr></table></figure><p><code>$hour</code> 还需要使用 <code>&#39;&quot;&quot;&#39;</code> 包裹起来才行</p><p>好在 awk 也有办法传递参数，使用 <code>-v</code> 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v hour=10 <span class="string">'$8 ~ hour &#123;print $0&#125;'</span> text</span><br></pre></td></tr></table></figure><p>如果使用参数的话，正则内容就不用 <code>//</code> 包裹了，直接使用参数即可。</p><p>只是这种情况下，如果我们想增加额外的符号，需要使用字符串包裹起来，比如想要查找时间以 <code>18</code> 为结尾的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v hour=18 <span class="string">'$8 ~ hour"$" &#123;print $0&#125;'</span> text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     861 Apr 17 18:18 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>也可以使用 <code>if</code> 条件语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v hour=18 <span class="string">'&#123; if ($8 ~ hour"$") &#123;print $0&#125; &#125;'</span> text</span><br></pre></td></tr></table></figure><p>很明显，命令行中使用 <code>if</code> 条件语句显得很乱，这主要还是要引出脚本化来。</p><h2><span id="jiao-ben-zhong-chuan-can">脚本中传参</span><a href="#jiao-ben-zhong-chuan-can" class="header-anchor"></a></h2><p>我们先将单引号中的条件脚本化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch split.awk</span><br><span class="line">$ chmod +x split.awk</span><br><span class="line">$ vim split.awk</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env awk -f</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$8</span> ~ hour<span class="string">"$"</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./split.awk -v hour=18 text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     861 Apr 17 18:18 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这只是一个很简单的例子，真实的开发中，判断条件往往更加复杂的多，所以使用脚本是很明智的办法。</p><p>最后提一句，使用 <code>match()</code> 可以使脚本的可读性更好一些。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env awk -f</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (match(<span class="variable">$8</span> , hour<span class="string">"$"</span>))&#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://stackoverflow.com/questions/11534173/how-to-use-awk-variables-in-regular-expressions" target="_blank" rel="noopener">How to use awk variables in regular expressions?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;awk 使用正则表达式过滤文本时可以使用可变参数，我本认为这应该是很普遍的需求，然而网上找了一圈也没看到一个比较全面的教程，不过东拼西凑也总算是满足了需求，今天来总结下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
      <category term="awk" scheme="http://wxnacy.com/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy 解决其他连接修改数据后，查询不到的问题</title>
    <link href="http://wxnacy.com/2019/04/25/sqlalchemy-isolation-level/"/>
    <id>http://wxnacy.com/2019/04/25/sqlalchemy-isolation-level/</id>
    <published>2019-04-25T01:35:51.000Z</published>
    <updated>2019-04-25T01:35:51.950Z</updated>
    
    <content type="html"><![CDATA[<p>使用 SQLAlchemy 做数据库的读写分离，创建了主从两个 DB，结果发现使用主 DB 写入的数据，从 DB 无法实时查询，必须要重启服务才可以查到。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>做了各种尝试发现都得不到解决，突然想起以前碰见过类似的问题，但是当时通过其他方式绕了过去，果然不是不报，时候未到。这次必须得正面解决了。</p><p>经过 Google 后发现，这是事务的问题，在多个实例进行链接数据库时，如果不执行 <code>commit</code>，就得不到最新的数据。</p><p>我们可以使用 <code>session.commit()</code> 来单个解决，或者可以在创建引擎时通过调整隔离级别参数来永久解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine = create_engine(<span class="string">'db_url'</span>, isolation_level = <span class="string">'READ COMMITTED'</span>)</span><br></pre></td></tr></table></figure><p><code>isolation_level</code> 的值包含了：</p><ul><li>READ COMMITTED</li><li>READ UNCOMMITTED</li><li>REPEATABLE READ</li><li>SERIALIZABLE</li><li>AUTOCOMMIT</li></ul><p>因为我使用只读，所以 <code>READ COMMITTED</code> 就可以满足要求，如果你是读写公用的 DB，直接使用 <code>AUTOCOMMIT</code> 就无脑解决了。</p><p>如果你使用 <code>flask_sqlalchemy</code>，在 <code>app.config</code> 中加入如下参数即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLALCHEMY_COMMIT_ON_TEARDOWN = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>通过源码可以发现，当该参数设置为 <code>True</code> 时，它会自动进行 <code>commit</code> 操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.teardown_appcontext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shutdown_session</span><span class="params">(response_or_exc)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> app.config[<span class="string">'SQLALCHEMY_COMMIT_ON_TEARDOWN'</span>]:</span><br><span class="line">        <span class="keyword">if</span> response_or_exc <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.session.commit()</span><br><span class="line"></span><br><span class="line">    self.session.remove()</span><br><span class="line">    <span class="keyword">return</span> response_or_exc</span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.sqlalchemy.org/en/13/core/engines.html#engine-creation-api" target="_blank" rel="noopener">Engine Creation API</a></li><li><a href="https://docs.sqlalchemy.org/en/13/dialects/mysql.html#transaction-isolation-level" target="_blank" rel="noopener">Mysql Transaction Isolation Level</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 SQLAlchemy 做数据库的读写分离，创建了主从两个 DB，结果发现使用主 DB 写入的数据，从 DB 无法实时查询，必须要重启服务才可以查到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="sqlalchemy" scheme="http://wxnacy.com/tags/sqlalchemy/"/>
    
  </entry>
  
  <entry>
    <title>Python 如何给屏幕打印信息加上颜色</title>
    <link href="http://wxnacy.com/2019/04/24/python-print-color/"/>
    <id>http://wxnacy.com/2019/04/24/python-print-color/</id>
    <published>2019-04-24T05:31:54.000Z</published>
    <updated>2019-04-24T05:31:54.732Z</updated>
    
    <content type="html"><![CDATA[<p>以前写过 <a href="/2018/09/07/go-fmt-color/">Go 如何给屏幕打印信息加上颜色</a>，想当然的以为 Python 也一样，结果被打脸，他们的配置还是有一些区别的。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#yu-fa">语法</a></li><li><a href="#gong-ju-hua">工具化</a></li></ul><!-- tocstop --></div><h2><span id="yu-fa">语法</span><a href="#yu-fa" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'\033[显示方式;字体色;背景色m文本\033[0m'</span>)</span><br><span class="line"><span class="comment"># 三种设置都可以忽略不写，都不写则为默认输出</span></span><br></pre></td></tr></table></figure><p>配置如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字体 背景 颜色</span></span><br><span class="line"><span class="comment"># ---------------------------------------</span></span><br><span class="line"><span class="comment"># 30  40  黑色</span></span><br><span class="line"><span class="comment"># 31  41  红色</span></span><br><span class="line"><span class="comment"># 32  42  绿色</span></span><br><span class="line"><span class="comment"># 33  43  黄色</span></span><br><span class="line"><span class="comment"># 34  44  蓝色</span></span><br><span class="line"><span class="comment"># 35  45  紫红色</span></span><br><span class="line"><span class="comment"># 36  46  青蓝色</span></span><br><span class="line"><span class="comment"># 37  47  白色</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 显示方式</span></span><br><span class="line"><span class="comment"># -------------------------</span></span><br><span class="line"><span class="comment">#  0  终端默认设置</span></span><br><span class="line"><span class="comment">#  1  高亮显示</span></span><br><span class="line"><span class="comment">#  4  使用下划线</span></span><br><span class="line"><span class="comment">#  5  闪烁</span></span><br><span class="line"><span class="comment">#  7  反白显示</span></span><br><span class="line"><span class="comment">#  8  不可见</span></span><br></pre></td></tr></table></figure><p>举几个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高亮显示，字体紫红色，背景白色</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[1;35;47m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor1.png" alt="1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认显示，字体紫红色，背景白色</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[35;47m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor2.png" alt="2"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认显示，字体紫红色，背景默认</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[35m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor3.png" alt="3"></p><p>往往我们更关注字体颜色，几个字体颜色效果如下，我用的 iTerm2 的深色背景，效果会有点偏差</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/output-color.png" alt="4"></p><p>如果你想看所有组合的颜色，可以查看这篇文章 <a href="https://www.cnblogs.com/journeyonmyway/p/4317108.html" target="_blank" rel="noopener">Go语言在Linux环境下输出彩色字符</a></p><h2><span id="gong-ju-hua">工具化</span><a href="#gong-ju-hua" class="header-anchor"></a></h2><p>这个语法看起来还是很别扭的，平常使用我们可以封装起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    BLACK = <span class="number">30</span></span><br><span class="line">    RED = <span class="number">31</span></span><br><span class="line">    GREEN = <span class="number">32</span></span><br><span class="line">    YELLOW = <span class="number">33</span></span><br><span class="line">    BLUE = <span class="number">34</span></span><br><span class="line">    MAGENTA = <span class="number">35</span></span><br><span class="line">    CYAN = <span class="number">36</span></span><br><span class="line">    WHITE = <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_color</span><span class="params">(text: str, fg: Color = Color.BLACK.value)</span>:</span></span><br><span class="line">    print(<span class="string">f'\033[<span class="subst">&#123;fg&#125;</span>m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印红色文字</span></span><br><span class="line">print_color(<span class="string">'Hello World'</span>, fg = Color.RED.value)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前写过 &lt;a href=&quot;/2018/09/07/go-fmt-color/&quot;&gt;Go 如何给屏幕打印信息加上颜色&lt;/a&gt;，想当然的以为 Python 也一样，结果被打脸，他们的配置还是有一些区别的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Redis get 报错 a key holding the wrong kind of value</title>
    <link href="http://wxnacy.com/2019/04/23/redis-error-wrong-kind/"/>
    <id>http://wxnacy.com/2019/04/23/redis-error-wrong-kind/</id>
    <published>2019-04-23T07:45:17.000Z</published>
    <updated>2019-04-23T07:56:25.497Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现使用 <code>redis-cli</code> 命令来获取数据报错，如下</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p>比较费解，因为线上程序并没有报错，时间紧迫也没有多关注，今天有时间感觉搜索了下。</p><p>这个错误是因为对 <code>key</code> 的 <code>value</code> 使用了错误的操作，比如 <code>lpush</code> 的数据只能使用 <code>lrange</code> 获取数据，使用 <code>get</code> 就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush test_key 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get test_key</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; lrange test_key 0 1</span><br><span class="line">1) <span class="string">"1"</span></span><br></pre></td></tr></table></figure><p>同样的使用 <code>set</code> 报错的数据，在使用 <code>lpush</code> 就会报错。</p><p>因为是很久之前写的代码，已经忘记了是用 <code>lpush</code> 保存的数据，所以在命令行中使用 <code>get</code> 自然报错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现使用 &lt;code&gt;redis-cli&lt;/code&gt; 命令来获取数据报错，如下&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://wxnacy.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Vim 执行 Shell 命令（2）</title>
    <link href="http://wxnacy.com/2019/04/18/vim-in-shell/"/>
    <id>http://wxnacy.com/2019/04/18/vim-in-shell/</id>
    <published>2019-04-18T14:08:20.000Z</published>
    <updated>2019-04-18T14:34:35.327Z</updated>
    
    <content type="html"><![CDATA[<p>前两天我写了在 Vim 中执行 Shell 命令，传送门 <a href="/2019/04/15/vim-run-shell/">Vim 执行 Shell 命令（1）</a></p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#ctrl-z"><code>&lt;ctrl-z&gt;</code></a></li><li><a href="#shell">:shell</a></li></ul><!-- tocstop --></div><p>今天我们来说如何在 Vim 和 Shell 间切换。</p><h2><span id="lt-ctrl-z-gt"><code>&lt;ctrl-z&gt;</code></span><a href="#lt-ctrl-z-gt" class="header-anchor"></a></h2><p>使用 <code>&lt;ctrl-z&gt;</code> 可以将当前 Vim 挂起，然后回到 Shell 模式，可以执行任何命令后，再使用 <code>fg</code> 或者 <code>fg %vim</code> 返回 Vim。</p><p>如果连续挂起多个，可以使用 <code>fg %1</code> 或者 <code>fg %vim filename</code> 回到 Vim。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell5.gif" alt="1"></p><p>这种方式来回切换多少有点不方便，直接使用 command 模式要更方便一点。</p><h2><span id="shell">:shell</span><a href="#shell" class="header-anchor"></a></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">sh</span>[ell]</span><br></pre></td></tr></table></figure><p>输入该命令即可进入 Shell 环境，然后使用 <code>&lt;ctrl-d&gt;</code> 即可返回 Vim。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell6.gif" alt="2"></p><p>这个流程显得顺畅很多，另外我们可以使用映射来做到只用 <code>&lt;ctrl-d&gt;</code> 来回切换。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">noremap</span> <span class="symbol">&lt;c-d&gt;</span> :<span class="keyword">sh</span><span class="symbol">&lt;cr&gt;</span>  <span class="string">" 修改映射"</span></span><br></pre></td></tr></table></figure><p>这样虽然方便，但 <code>&lt;ctrl-d&gt;</code> 本来是向下翻半页，很挺常用的，是否要更换这个映射还有待斟酌。</p><p>因为 <code>:sh</code> 是主动进入 Shell 环境，所以它可以指定命令，比如你想使用 <code>fish</code> 则可以这样</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">shell</span>=/usr/local/bin/fish</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell7.gif" alt="3"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天我写了在 Vim 中执行 Shell 命令，传送门 &lt;a href=&quot;/2019/04/15/vim-run-shell/&quot;&gt;Vim 执行 Shell 命令（1）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Python 获取当前作用域全部参数的内置方法 locals()</title>
    <link href="http://wxnacy.com/2019/04/17/python-locals/"/>
    <id>http://wxnacy.com/2019/04/17/python-locals/</id>
    <published>2019-04-17T10:23:31.000Z</published>
    <updated>2019-04-17T13:38:29.682Z</updated>
    
    <content type="html"><![CDATA[<p>在写程序时，经常会碰见传递过多参数的情况。先看一个例子</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(id, name, age, **kw)</span>:</span></span><br><span class="line">    amount = <span class="number">1</span></span><br><span class="line">    duration = <span class="number">10</span></span><br><span class="line">    func2(id = id, name = name, age = age, amount = amount, **kw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(**kw)</span>:</span></span><br><span class="line">    print(kw)</span><br></pre></td></tr></table></figure><p>在 <code>func1()</code> 给 <code>func2()</code> 传递参数，一个一个的写真的很痛苦，写一次还好，关键是到处都有这种情况。</p><p>可不可以将想要的参数打包直接传递过去呢？</p><p>内置方法 <code>locals()</code> 就可以达到这个效果，它可以实时收集当前作用域的参数，并返回一个字典。</p><p>先在全局范围内看看有哪些参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(locals())</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python locals_demo.py</span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader object at 0x102c75860&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;, <span class="string">'__file__'</span>: <span class="string">'locals_demo.py'</span>, <span class="string">'__cached__'</span>: None&#125;</span><br></pre></td></tr></table></figure><p>可能你到没注意到一个空文件里都有这么多的内置参数。</p><p><code>locals()</code> 收集参数是实时进行的，比如我们定义一个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(locals())</span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    print(locals())</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python locals_demo.py</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader object at 0x1083d5860&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;, <span class="string">'__file__'</span>: <span class="string">'locals_demo.py'</span>, <span class="string">'__cached__'</span>: None&#125;</span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader object at 0x1083d5860&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;, <span class="string">'__file__'</span>: <span class="string">'locals_demo.py'</span>, <span class="string">'__cached__'</span>: None, <span class="string">'name'</span>: <span class="string">'wxnacy'</span>&#125;</span><br></pre></td></tr></table></figure><p>第二次打印的结果中，就多出了刚刚定义的参数 <code>name</code></p><p>在方法中使用也是如此</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(**kw)</span>:</span></span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    print(locals())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    func(url = <span class="string">'https://wxnacy.com'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python locals_demo.py</span><br><span class="line">&#123;<span class="string">'kw'</span>: &#123;<span class="string">'url'</span>: <span class="string">'https://wxnacy.com'</span>&#125;, <span class="string">'name'</span>: <span class="string">'wxnacy'</span>&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>locals()</code> 方法的值是动态变的，所以我们可以先用变量储存起来，并且记得去掉不需要的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(id, age, **kw)</span>:</span></span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    args = locals()</span><br><span class="line">    args.pop(<span class="string">'name'</span>)</span><br><span class="line">    print(args)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(id, age, **kw)</span>:</span></span><br><span class="line">    args = locals()</span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    print(args)</span><br></pre></td></tr></table></figure><p>现在再来回顾下开始的问题，这下解决方式简单了很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(id, name, age, **kw)</span>:</span></span><br><span class="line">    amount = <span class="number">1</span></span><br><span class="line">    args = locals()</span><br><span class="line">    duration = <span class="number">10</span></span><br><span class="line">    func2(**args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(**kw)</span>:</span></span><br><span class="line">    print(kw)</span><br></pre></td></tr></table></figure><p>喔噢，我爱 Python。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写程序时，经常会碰见传递过多参数的情况。先看一个例子&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用 ffmpeg 分离视频流和音频流</title>
    <link href="http://wxnacy.com/2019/04/16/ffmpeg-split-video-audio/"/>
    <id>http://wxnacy.com/2019/04/16/ffmpeg-split-video-audio/</id>
    <published>2019-04-16T14:41:36.000Z</published>
    <updated>2019-04-16T15:19:45.363Z</updated>
    
    <content type="html"><![CDATA[<p>通常情况下，我们提到“视频”会有两个要素，声音和画面。但其实严格意义上说视频中含有<strong>视频流</strong>和<strong>音频流</strong>，如果一个视频只有视频流，那么就只有画面没有声音，反之亦然。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>我有听英语电影原声的习惯，但是总是放视频很不方便，网上的资源又不是太称心如意，就想着自己动手来分离，我首先想到的是 ffmpeg。</p><p>我们先来看看视频中的这两个流</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/ffsplit1_713.png" alt="1"></p><p>执行该命令可以直接查看视频的信息，其中就有刚才的提到的<strong>视频流（Video: h264）</strong>和<strong>音频流（Audio: aac）</strong></p><p>使用参数 <code>-vcodec copy -an</code> 和 <code>-acodec copy -vn</code> 可以分离出视频流和音频流。</p><p><strong>分离视频</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 -vcodec copy -an mav.mp4</span><br></pre></td></tr></table></figure><p>等待转码成功后，观看 <code>mav.mp4</code> 发现已经没有声音了，查看发现只有一个流</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/ffsplit2_667.png" alt="2"></p><p><strong>分离音频</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 -acodec copy -vn m.m4a</span><br></pre></td></tr></table></figure><p>再次查看音频流信息</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/ffsplit3_702.png" alt="3"></p><p>网上很多博客都是直接甩一个类似这样的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 -acodec copy -vn m.mp3</span><br></pre></td></tr></table></figure><p>如果你执行的话，多半会报错，因为查看视频信息，很可能像例子中的音频流一样是 aac 格式的，什么是 aac 格式呢</p><blockquote><p>高级音频编码（英语：Advanced Audio Coding，AAC），出现于1997年，为一种基于MPEG-2的有损数字音频压缩的专利音频编码标准，由Fraunhofer IIS、杜比实验室、AT&amp;T、Sony、Nokia等公司共同开发。2000年，MPEG-4标准在原本的基础上加上了PNS（Perceptual Noise Substitution）等技术，并提供了多种扩展工具。为了区别于传统的MPEG-2 AAC又称为MPEG-4 AAC。其作为MP3的后继者而被设计出来，在相同的比特率之下，AAC相较于MP3通常可以达到更好的声音质量[2]。</p></blockquote><p>关键是下面这句</p><blockquote><p>AAC 被YouTube、iPhone、iPod、 iPad、 任天堂DSi、任天堂3DS、iTunes、DivX、PlayStation 3和多款Nokia 40系列、Sony Ericsson手机采用为默认的音频编码格式，并且被PlayStation Vita、Wii、Sony Walkman MP3系列及随后的Android、BlackBerry等移动操作系统支持。</p></blockquote><p>也就是说，现在很多视频的音频流都将是这个格式，那直接分离 <code>mp3</code> 格式的音频自然会报错。</p><p>那我就是想要 <code>mp3</code> 的音频该怎么办呢？</p><p>再来一次转码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i m.m4a m.mp3</span><br></pre></td></tr></table></figure><p>或者直接将视频转码为 <code>mp3</code> 格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 m.mp3</span><br></pre></td></tr></table></figure><ul><li><a href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E9%9F%B3%E8%A8%8A%E7%B7%A8%E7%A2%BC#%E7%9B%B8%E8%BC%83%E6%96%BCMP3%E7%9A%84%E6%94%B9%E9%80%B2" target="_blank" rel="noopener">高级音频编码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常情况下，我们提到“视频”会有两个要素，声音和画面。但其实严格意义上说视频中含有&lt;strong&gt;视频流&lt;/strong&gt;和&lt;strong&gt;音频流&lt;/strong&gt;，如果一个视频只有视频流，那么就只有画面没有声音，反之亦然。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ffmpeg" scheme="http://wxnacy.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Vim 执行 Shell 命令（1）</title>
    <link href="http://wxnacy.com/2019/04/15/vim-run-shell/"/>
    <id>http://wxnacy.com/2019/04/15/vim-run-shell/</id>
    <published>2019-04-15T13:50:52.000Z</published>
    <updated>2019-04-18T14:36:00.164Z</updated>
    
    <content type="html"><![CDATA[<p>Vim 编写程序时，无须退出 Vim 或者新建 Terminal 窗口即可执行 Shell 命令。</p><a id="more"></a><p>在 Mac 环境开发时，可以使用 Tmux 搭配 Vim，一个窗口编写，一个窗口执行。然而线上环境往往不能安装过于复杂的开发环境，那每次都反复的进入退出很是让人烦躁，其实 Vim 中可以直接运行 Shell 命令。</p><div class="toc"><!-- toc --><ul><li><a href="#zhi-xing">执行</a></li><li><a href="#du-qu">读取</a></li><li><a href="#xie-ru">写入</a></li><li><a href="#ti-huan">替换</a></li></ul><!-- tocstop --></div><h2><span id="zhi-xing">执行</span><a href="#zhi-xing" class="header-anchor"></a></h2><p><strong>语法</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!command</span><br></pre></td></tr></table></figure><p><code>command</code> 可以是任何一个 Shell 命令，回车执行后，会在 Shell 中显示结果，再次回车返回 Vim。先来看个动图</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell1.gif" alt="1"></p><h2><span id="du-qu">读取</span><a href="#du-qu" class="header-anchor"></a></h2><p>该模式下还可以直接把执行结果，读取到 Vim 中，这是很神奇的功能。</p><p><strong>语法</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r !command</span><br></pre></td></tr></table></figure><p>执行该命令后，Shell 命令结果会自动复制到当前行的下面</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell2.gif" alt="2"></p><p>前面输入数字，可以复制到第 N 行的下面，比如第二行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="number">2</span>r !command</span><br></pre></td></tr></table></figure><h2><span id="xie-ru">写入</span><a href="#xie-ru" class="header-anchor"></a></h2><p>能读取，就能写入，使用 <code>w</code> 可以将制定行数的文本通过管道传给想要执行的命令</p><p><strong>语法</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:n1, n2w !command</span><br></pre></td></tr></table></figure><p>比如我们想要将第 7 到 10 行的内容传给 <code>wc</code> 命令，获取行数，单词数和字符数。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="number">7</span>, <span class="number">10</span><span class="keyword">w</span> !wc</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell3.gif" alt="3"></p><h2><span id="ti-huan">替换</span><a href="#ti-huan" class="header-anchor"></a></h2><p>最后要说的是替换，它好像将上边两种命令结合一般，这次直接输入行数范围即可</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:n1, n2 !wc</span><br></pre></td></tr></table></figure><p>还是上面的例子，我们重新执行一次</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell4.gif" alt="4"></p><p>最后提一句 <code>:!!</code> 可以执行上一次执行的命令，没错，就像 Shell 中一样。</p><p>直接在 Vim 中执行 Shell 命令，只是一种方式，我们还可以直接切换到 Shell 模式在执行复杂的操作。</p><p>不过今天先到这里，想要学好 Vim，一次输入太多知识不是个好习惯，还需要大量的练习来巩固它，下一章我们再来探讨怎样切换 Shell 环境。</p><p>传送门 <a href="/2019/04/18/vim-in-shell/">Vim 执行 Shell 命令（2）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vim 编写程序时，无须退出 Vim 或者新建 Terminal 窗口即可执行 Shell 命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>使用 goss 构建 Github 图床</title>
    <link href="http://wxnacy.com/2019/04/14/goss/"/>
    <id>http://wxnacy.com/2019/04/14/goss/</id>
    <published>2019-04-14T11:40:58.000Z</published>
    <updated>2019-04-15T02:47:47.696Z</updated>
    
    <content type="html"><![CDATA[<p>写个人博客也快两年了，在博客里放图片一直是个老大难的问题，微博一类的三方图床不爱用，总觉得不极客，使用 OSS 的话多少跟技术沾些边，要是直接使用 linux 服务器搭建的话，又太麻烦，因为需要处理的事情太多了，从图床的角度来说，稳定性还是很重要的。</p><a id="more"></a><p>抽个空就会想想这个事情，好歹想出来使用 Github 来做图床，但是这就算是跟技术沾边了？我慢慢来说。</p><div class="toc"><!-- toc --><ul><li><a href="#ru-he-shi-yong-github-tu-chuang">如何使用 Github 图床</a></li><li><a href="#shi-yong-goss-gou-jian-tu-chuang">使用 goss 构建图床</a><ul><li><a href="#shi-yong">使用</a></li></ul></li></ul><!-- tocstop --></div><h2><span id="ru-he-shi-yong-github-tu-chuang">如何使用 Github 图床</span><a href="#ru-he-shi-yong-github-tu-chuang" class="header-anchor"></a></h2><p>使用 Github 构建图床是很投机的一件事，和使用微博的方式类似，不过更加自由。</p><p><strong>首先创建一个新的仓库当做图床</strong></p><p>仓库地址为 <a href="https://github.com/wxnacy/image" target="_blank" rel="noopener">https://github.com/wxnacy/image</a></p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/goss1_762.png" alt="goss1"></p><p><strong>然后上传一个图片</strong></p><p>图片的网页地址为 <a href="https://github.com/wxnacy/image/blob/master/blog/mavel5.png" target="_blank" rel="noopener">https://github.com/wxnacy/image/blob/master/blog/mavel5.png</a></p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/goss2_1005.png" alt="goss2"></p><p><strong>找到图片网址</strong></p><p>然后点击右侧的 <code>Download</code>，网页就会跳转到图片的下载地址，也就是图片链接。</p><p>下载地址为 <a href="https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel5.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel5.png</a></p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/goss3_987.png" alt="goss3"></p><p>通过这个规律，我就可以在上传完图片后，根据图片地址规则拼接出我们想要的图片链接。</p><p>然后这个方式并不酷。</p><h2><span id="shi-yong-goss-gou-jian-tu-chuang">使用 goss 构建图床</span><a href="#shi-yong-goss-gou-jian-tu-chuang" class="header-anchor"></a></h2><p>身为一个程序员，用这样的方式进行上传、拼接地址，这个过程一点都不酷。我希望的是更极致，更方便的方式，所以 <a href="https://github.com/wxnacy/goss" target="_blank" rel="noopener">goss</a> 诞生了。</p><p>goss 全称 Github Object Storage System，也就是 Github 版本的 OSS。</p><p>它使用仓库代替 bucket，使用文件 path 代替 key，这样每个仓库都是一个独立的图床。</p><p>goss 自带一套很方便的命令行工具来操作仓库和文件，下面简单的使用几个命令，走一下增删改查的流程。</p><h3><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor"></a></h3><p><strong>安装</strong></p><p>目前仅支持 pip 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install goss              <span class="comment"># 安装</span></span><br><span class="line">$ pip install --upgrade goss    <span class="comment"># 更新</span></span><br></pre></td></tr></table></figure><p><strong>登陆</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli login</span><br></pre></td></tr></table></figure><p>根据命令行提示输入 Github 用户名密码即可，执行一次后会记录在本地，如果想要更换用户再次执行即可。</p><p><strong><em>goss 会在登陆成功后自动获取用户提交信息的 name 和 email，无需像 Git 一样再去手动配置</em></strong></p><p><strong>创建仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli repo test_goss -m post</span><br><span class="line"></span><br><span class="line">[INFO] Create repository</span><br><span class="line">[INFO] Url : https://github.com/wxnacy/test_goss</span><br><span class="line">[INFO] Waiting...</span><br><span class="line">[INFO] Create README.md</span><br><span class="line">[INFO] Url : https://github.com/wxnacy/test_goss/blob/master/README.md</span><br><span class="line">[INFO] Waiting...</span><br><span class="line">Success!</span><br></pre></td></tr></table></figure><p>等待命令行执行成功后，仓库创建成功，如图</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/goss4_1000.png" alt="goss4"></p><p><strong>上传图片</strong></p><p>上传操纵，单独有个命令为 <code>goss</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ goss -r test_goss -p <span class="built_in">test</span>/ goss1.png</span><br><span class="line"></span><br><span class="line">[INFO] Upload file</span><br><span class="line">[INFO] Source   : goss1.png</span><br><span class="line">[INFO] Path     : <span class="built_in">test</span>/goss1.png</span><br><span class="line">[INFO] HtmlUrl  : https://github.com/wxnacy/test_goss/blob/master/<span class="built_in">test</span>/goss1.png</span><br><span class="line">[INFO] DownUrl  : https://raw.githubusercontent.com/wxnacy/test_goss/master/<span class="built_in">test</span>/goss1.png</span><br><span class="line">[INFO] Now you can use it with &lt;Ctrl-v&gt; and <span class="built_in">wait</span> <span class="keyword">for</span> the upload to succeed.</span><br><span class="line">[INFO] Waiting...</span><br><span class="line">Success!</span><br></pre></td></tr></table></figure><p>在日志中会打印出图片的下载地址，然后我们并不需要手动复制，在等待上传的 <code>Waiting...</code> 阶段，我们可以直接使用 <code>&lt;ctrl-v&gt;</code> 来在文本中直接黏贴图片链接，并且继续编写文章，等图片上传完成后，该链接自动生效。</p><p>这也是 goss 最最方便的地方，只需要执行一条命令，剩下的不需要再去管。</p><p>参数部分</p><ul><li><code>-r</code> 仓库名称，如果不想每次手动输入，可以使用 <code>goss-cli config repo.name &lt;name&gt;</code> 来进行配置</li><li><code>-p</code> 文件重命名，如果以 <code>/</code> 结尾，代表以原文件名上传到该目录中</li></ul><p><strong>查看文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli file <span class="built_in">test</span>/goss1.png -r test_goss</span><br><span class="line"></span><br><span class="line">[INFO] Query file</span><br><span class="line">[INFO] Owner    : wxnacy</span><br><span class="line">[INFO] Repo     : test_goss</span><br><span class="line">[INFO] Path     : <span class="built_in">test</span>/goss1.png</span><br><span class="line">[INFO] Waiting...</span><br><span class="line">Path    : <span class="built_in">test</span>/goss1.png</span><br><span class="line">Type    : file</span><br><span class="line">Size    : 183122</span><br><span class="line">Sha     : dad2a5a0cdfd8fe0b979d3345f72bdcb98b0ecb6</span><br><span class="line">HtmlUrl : https://github.com/wxnacy/test_goss/blob/master/<span class="built_in">test</span>/goss1.png</span><br><span class="line">DownUrl : https://raw.githubusercontent.com/wxnacy/test_goss/master/<span class="built_in">test</span>/goss1.png</span><br><span class="line">[INFO] Now you can use it with &lt;Ctrl-v&gt; and <span class="built_in">wait</span> <span class="keyword">for</span> the upload to succeed.</span><br><span class="line">More details see : https://api.github.com/repos/wxnacy/test_goss/contents/<span class="built_in">test</span>/goss1.png?ref=master</span><br><span class="line">Success!</span><br></pre></td></tr></table></figure><p><strong>删除文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli file <span class="built_in">test</span>/goss1.png -r test_goss -m delete</span><br></pre></td></tr></table></figure><p>先你应该发现了，命令中的正删改查的方式来源于 RESTFul 风格。</p><p><code>--method/-m</code> 参数</p><ul><li><code>post</code> 新建</li><li><code>get</code> 查看，默认</li><li><code>delete</code> 删除</li></ul><p><strong>删除仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli repo test_goss -m delete</span><br></pre></td></tr></table></figure><p>现在这个命令应该慎用，因为这是彻彻底底的删除，除非你真的想删除一些老项目，否则最好不要用这个命令。</p><p>今天只是简单介绍下使用 goss 来构建图床，goss 本身会有很多功能，我也会不断的进行更新，你可以使用帮助命令来获取更多的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage: goss-cli [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">  Github Object Storage System</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -v, --version  Show the version</span><br><span class="line">  -d, --debug    Run <span class="keyword">in</span> debug</span><br><span class="line">  --<span class="built_in">help</span>         Show this message and <span class="built_in">exit</span>.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  config  Get/Create/Update goss config</span><br><span class="line">  file    Get/Delete/Download your file If you want to upload file.</span><br><span class="line">  login   Log <span class="keyword">in</span> to the github account</span><br><span class="line">  repo    Get/Create your repositorys</span><br></pre></td></tr></table></figure><p>子命令也可以查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli file --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage: goss-cli file [OPTIONS] [PATH]</span><br><span class="line"></span><br><span class="line">  Get/Delete/Download your file</span><br><span class="line"></span><br><span class="line">  If you want to upload file. Please use <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line">      goss &lt;filepath&gt; --repo=&lt;repository-name&gt;</span><br><span class="line"></span><br><span class="line">  More usage see : goss --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -m, --method TEXT  GET/POST/PUT/DELETE <span class="keyword">for</span> repository. Default is GET</span><br><span class="line">  -o, --orga TEXT    If want create organization repository. Is required</span><br><span class="line">  -D, --download     Download file</span><br><span class="line">  -y, --yes          All questions answered yes</span><br><span class="line">  -O, --output TEXT  Download name. Default is file name</span><br><span class="line">  -r, --repo TEXT    Repository name  [required]</span><br><span class="line">  --<span class="built_in">help</span>             Show this message and <span class="built_in">exit</span>.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写个人博客也快两年了，在博客里放图片一直是个老大难的问题，微博一类的三方图床不爱用，总觉得不极客，使用 OSS 的话多少跟技术沾些边，要是直接使用 linux 服务器搭建的话，又太麻烦，因为需要处理的事情太多了，从图床的角度来说，稳定性还是很重要的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://wxnacy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux tar 打包命令</title>
    <link href="http://wxnacy.com/2019/04/13/linux-tar/"/>
    <id>http://wxnacy.com/2019/04/13/linux-tar/</id>
    <published>2019-04-13T01:52:28.000Z</published>
    <updated>2019-04-14T02:50:03.915Z</updated>
    
    <content type="html"><![CDATA[<p>在 Github 打标签的时候，它会自动归档两种压缩格式的文件 <code>.zip</code> 和 <code>.tar.gz</code>，如图</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/tar_944.png" alt="tar"></p><p><code>zip</code> 格式的压缩和解压可以参看我这篇文章 <a href="/2018/09/19/zip-unzip/">Linux zip 和 unzip 命令</a></p><p>今天我主要来说一下 <code>tar</code> 打包命令。</p><div class="toc"><!-- toc --><ul><li><a href="#da-bao-jie-bao">打包解包</a></li><li><a href="#ya-suo-jie-ya-gz-ge-shi">压缩解压 .gz 格式</a></li><li><a href="#ya-suo-jie-ya-bz2-ge-shi">压缩解压 .bz2 格式</a></li><li><a href="#geng-duo-yu-fa">更多语法</a></li></ul><!-- tocstop --></div><p>首先要强调的是 <code>tar</code> 是打包命令，本身不压缩，需要调用 <code>gzip</code> 压缩命令才可以生成 <code>.gz</code> 后缀的压缩文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tar cvf pm2.log.tar pm2.log       <span class="comment"># 打包</span></span><br><span class="line">$ tar zcvf pm2.log.tar.gz pm2.log   <span class="comment"># 打包，并压缩</span></span><br><span class="line">$ zip pm2.zip pm2.log               <span class="comment"># 使用 zip 压缩</span></span><br><span class="line">$ ll</span><br><span class="line">-rw-r--r--    1 wxnacy  staff  259615701 Apr 13 06:37 pm2.log</span><br><span class="line">-rw-r--r--    1 wxnacy  staff  259617280 Apr 13 09:47 pm2.log.tar</span><br><span class="line">-rw-r--r--    1 wxnacy  staff    7746015 Apr 13 09:48 pm2.log.tar.gz</span><br><span class="line">-rw-r--r--    1 wxnacy  staff    7763656 Apr 13 09:51 pm2.zip</span><br></pre></td></tr></table></figure><p>从结果来看，只是打包命令的话，不但不压缩，本身比原文件还要大一点，调用压缩命令后，压缩比很明显，并且比 <code>zip</code> 的压缩比要高，所以在文件压缩时，我们可以优先使用 <code>tar</code> 打包并压缩。</p><h2><span id="da-bao-jie-bao">打包解包</span><a href="#da-bao-jie-bao" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar cvf &lt;filename&gt;.tar &lt;filename|dirname&gt;     <span class="comment"># 打包</span></span><br><span class="line">$ tar xvf &lt;filename&gt;.tar                        <span class="comment"># 解包</span></span><br></pre></td></tr></table></figure><h2><span id="ya-suo-jie-ya-gz-ge-shi">压缩解压 .gz 格式</span><a href="#ya-suo-jie-ya-gz-ge-shi" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar zcvf &lt;filename&gt;.tar.gz &lt;filename|dirname&gt;     <span class="comment"># 压缩</span></span><br><span class="line">$ tar zxvf &lt;filename&gt;.tar.gz                        <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><h2><span id="ya-suo-jie-ya-bz2-ge-shi">压缩解压 .bz2 格式</span><a href="#ya-suo-jie-ya-bz2-ge-shi" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar jcvf &lt;filename&gt;.tar.bz2 &lt;filename|dirname&gt;     <span class="comment"># 压缩</span></span><br><span class="line">$ tar jxvf &lt;filename&gt;.tar.bz2                        <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><h2><span id="geng-duo-yu-fa">更多语法</span><a href="#geng-duo-yu-fa" class="header-anchor"></a></h2><p>必要参数有如下：</p><ul><li><code>-A</code> 新增压缩文件到已存在的压缩</li><li><code>-B</code> 设置区块大小</li><li><code>-c</code> 建立新的压缩文件</li><li><code>-d</code> 记录文件的差别</li><li><code>-r</code> 添加文件到已经压缩的文件</li><li><code>-u</code> 添加改变了和现有的文件到已经存在的压缩文件</li><li><code>-x</code> 从压缩的文件中提取文件</li><li><code>-t</code> 显示压缩文件的内容</li><li><code>-z</code> 支持gzip解压文件</li><li><code>-j</code> 支持bzip2解压文件</li><li><code>-Z</code> 支持compress解压文件</li><li><code>-v</code> 显示操作过程</li><li><code>-l</code> 文件系统边界设置</li><li><code>-k</code> 保留原有文件不覆盖</li><li><code>-m</code> 保留文件不被覆盖</li><li><code>-W</code> 确认压缩文件的正确性</li></ul><p>可选参数如下：</p><ul><li><code>-b</code> 设置区块数目</li><li><code>-C</code> 切换到指定目录</li><li><code>-f</code> 指定压缩文件</li><li><code>--help</code> 显示帮助信息</li><li><code>--version</code> 显示版本信息</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Github 打标签的时候，它会自动归档两种压缩格式的文件 &lt;code&gt;.zip&lt;/code&gt; 和 &lt;code&gt;.tar.gz&lt;/code&gt;，如图&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 如何打印不换行进度条</title>
    <link href="http://wxnacy.com/2019/04/12/python-single-line-progress/"/>
    <id>http://wxnacy.com/2019/04/12/python-single-line-progress/</id>
    <published>2019-04-12T14:36:10.000Z</published>
    <updated>2019-04-12T14:48:11.317Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中打印不换行进度条，可以说是简单透顶，使用内置方法 <code>print</code> 直接打印即可</p><a id="more"></a><p>先看下效果</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/python_progress.gif" alt="image"></p><p>大部分时间我们使用 <code>print</code> 是不带多与参数的，但是它有个带有默认值的参数 <code>end</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">''</span>, end=<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p>默认情况下 <code>end=&#39;\n&#39;</code>，表示打印完毕后进行换行。</p><p><code>\r</code> 则表示将光标移动到行首</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">''</span>, end=<span class="string">'\r'</span>)     <span class="comment"># 简而言之，这样就可以起到不换行的效果</span></span><br></pre></td></tr></table></figure><p>完整代码请见 <a href="https://github.com/wxnacy/study/blob/master/python/simple/single_line_progress.py" target="_blank" rel="noopener">single_line_progress.py</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中打印不换行进度条，可以说是简单透顶，使用内置方法 &lt;code&gt;print&lt;/code&gt; 直接打印即可&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 操作 ini 配置文件</title>
    <link href="http://wxnacy.com/2019/04/11/python-configparser/"/>
    <id>http://wxnacy.com/2019/04/11/python-configparser/</id>
    <published>2019-04-11T03:25:49.000Z</published>
    <updated>2019-04-11T03:25:49.336Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中使用 <code>configparser</code> 模块来操作 ini 文件。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>假如想要生成 <code>example.ini</code> 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ServerAliveInterval = 45</span><br><span class="line">Compression = yes</span><br><span class="line">CompressionLevel = 9</span><br><span class="line">ForwardX11 = yes</span><br><span class="line"></span><br><span class="line">[bitbucket.org]</span><br><span class="line">User = hg</span><br><span class="line"></span><br><span class="line">[topsecret.server.com]</span><br><span class="line">Port = 50022</span><br><span class="line">ForwardX11 = no</span><br></pre></td></tr></table></figure><p><strong>写入操作</strong></p><p><code>configparser.ConfigParser()</code> 方法生成实例，配置和读取内容都可以按照 <code>dict</code> 的方式进行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> configparser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config = configparser.ConfigParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'DEFAULT'</span>] = &#123;<span class="string">'ServerAliveInterval'</span>: <span class="string">'45'</span>,</span><br><span class="line"><span class="meta">... </span>                     <span class="string">'Compression'</span>: <span class="string">'yes'</span>,</span><br><span class="line"><span class="meta">... </span>                     <span class="string">'CompressionLevel'</span>: <span class="string">'9'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>] = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>][<span class="string">'User'</span>] = <span class="string">'hg'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'topsecret.server.com'</span>] = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret = config[<span class="string">'topsecret.server.com'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'Port'</span>] = <span class="string">'50022'</span>     <span class="comment"># mutates the parser</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'ForwardX11'</span>] = <span class="string">'no'</span>  <span class="comment"># same here</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'DEFAULT'</span>][<span class="string">'ForwardX11'</span>] = <span class="string">'yes'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'example.ini'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> configfile:</span><br><span class="line"><span class="meta">... </span>  config.write(configfile)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>读取操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>config = configparser.ConfigParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.sections()</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.read(<span class="string">'example.ini'</span>)</span><br><span class="line">[<span class="string">'example.ini'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.sections()</span><br><span class="line">[<span class="string">'bitbucket.org'</span>, <span class="string">'topsecret.server.com'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'bitbucket.org'</span> <span class="keyword">in</span> config</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'bytebong.com'</span> <span class="keyword">in</span> config</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>][<span class="string">'User'</span>]</span><br><span class="line"><span class="string">'hg'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'DEFAULT'</span>][<span class="string">'Compression'</span>]</span><br><span class="line"><span class="string">'yes'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret = config[<span class="string">'topsecret.server.com'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'ForwardX11'</span>]</span><br><span class="line"><span class="string">'no'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'Port'</span>]</span><br><span class="line"><span class="string">'50022'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> config[<span class="string">'bitbucket.org'</span>]:</span><br><span class="line"><span class="meta">... </span>    print(key)</span><br><span class="line">user</span><br><span class="line">compressionlevel</span><br><span class="line">serveraliveinterval</span><br><span class="line">compression</span><br><span class="line">forwardx11</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>][<span class="string">'ForwardX11'</span>]</span><br><span class="line"><span class="string">'yes'</span></span><br></pre></td></tr></table></figure><p><strong>修改操作</strong></p><p>因为此处配置的写入是覆盖模式，所以如果想要修改文件，需要判断下文件是否存在，存在的话，先加载文件内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">config</span><span class="params">(filepath, section, **data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    filepath: 配置文件地址</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    conf = configparser.ConfigParser()</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(filepath):</span><br><span class="line">        conf.read(filepath)</span><br><span class="line"></span><br><span class="line">    conf[section] = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        conf.write(f)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.python.org/3/library/configparser.html" target="_blank" rel="noopener">configparser</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中使用 &lt;code&gt;configparser&lt;/code&gt; 模块来操作 ini 文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 如何创建文件</title>
    <link href="http://wxnacy.com/2019/04/09/python-create-file/"/>
    <id>http://wxnacy.com/2019/04/09/python-create-file/</id>
    <published>2019-04-09T10:02:33.000Z</published>
    <updated>2019-04-10T10:03:15.091Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中可以使用 <code>open()</code> 内置方法来创建和打开文件。</p><a id="more"></a><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(file, [mode])</span><br></pre></td></tr></table></figure><p>Mode:</p><ul><li><code>x</code> 创建文件，如果文件已经存在会报错。</li><li><code>w</code> 创建可写文件，写入内容覆盖文件。</li><li><code>r</code> 获取可读文件，默认模式。</li><li><code>a</code> 打开一个可追加文件，广告默认在文尾。</li><li><code>t</code> 打开一个 text 模式，默认模式</li><li><code>b</code> 打开一个二进制模式</li></ul><p><strong>创建文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test'</span>, <span class="string">'x'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test'</span>, <span class="string">'x'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    f = open(<span class="string">'/tmp/test'</span>, <span class="string">'x'</span>)</span><br><span class="line">FileExistsError: [Errno <span class="number">17</span>] File exists: <span class="string">'/tmp/test'</span></span><br></pre></td></tr></table></figure><p><strong>创建可写文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hw'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p><strong>创建可追加文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hw'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">'hwhw'</span></span><br></pre></td></tr></table></figure><p><strong>获取可读文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">'hwhw'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'rb'</span>)    <span class="comment"># 以二进制打开</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b'hwhw'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.guru99.com/reading-and-writing-files-in-python.htm" target="_blank" rel="noopener">Python File Handling: Create, Open, Append, Read, Write</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中可以使用 &lt;code&gt;open()&lt;/code&gt; 内置方法来创建和打开文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Mac 系统中使用 ffmpeg 给视频添加文字水印</title>
    <link href="http://wxnacy.com/2019/04/08/ffmpeg-drawtext/"/>
    <id>http://wxnacy.com/2019/04/08/ffmpeg-drawtext/</id>
    <published>2019-04-08T06:16:42.000Z</published>
    <updated>2019-04-08T06:16:42.408Z</updated>
    
    <content type="html"><![CDATA[<p>最近有给视频加文字水印的需求，第一个想到的肯定是使用 ffmpeg，搜索了下发现网上的博客多是从别人那复制过来的，直接使用多是报错，经过摸索后，终于搞清楚了简单用法，今天简单总结下。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#ying-wen-shui-yin">英文水印</a></li><li><a href="#zhong-wen-shui-yin">中文水印</a></li></ul><!-- tocstop --></div><p>先来看个例子，我希望在如下的视频右侧加上文字水印，如下</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel33.png" alt="mavel3"></p><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><p>首先需要安装最新版本的 ffmpeg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install ffmpeg</span><br></pre></td></tr></table></figure><h2><span id="ying-wen-shui-yin">英文水印</span><a href="#ying-wen-shui-yin" class="header-anchor"></a></h2><p>运行下面的命令，即可达到上图效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -y -i mavel4.mp4 -vf <span class="string">"drawtext=text='Avengers\: Endgame':x=700:y=200:fontsize=24:fontcolor=red"</span> mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>参数含义</p><ul><li><code>-i</code>：需要渲染的视频，<code>mavel4.mp4</code> 为视频源</li><li><code>-vf</code>：后面跟着需要的具体渲染效果，后面的参数需要使用双引号包裹起来</li><li><code>mavel4_drawtext.mp4</code>：就是最后输出的文件名</li><li><code>-y</code>：对一切提示回答 <code>yes</code></li></ul><p><code>-vf</code> 后面的参数比较复杂，我们先将命令行折行美化下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -y -i mavel4.mp4 \</span><br><span class="line">    -vf <span class="string">"drawtext=\</span></span><br><span class="line"><span class="string">        text='Avengers\: Endgame':\</span></span><br><span class="line"><span class="string">        x=700:\</span></span><br><span class="line"><span class="string">        y=200:\</span></span><br><span class="line"><span class="string">        fontsize=24:\</span></span><br><span class="line"><span class="string">        fontcolor=red:\</span></span><br><span class="line"><span class="string">        "</span> \</span><br><span class="line">    mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>现在我们来逐条分析下</p><ul><li><code>drawtext=</code>：代表了此次渲染为添加文字水印，后面跟着具体的属性，属性之间使用 <code>:</code> 分割</li><li><code>text=&#39;Avengers\: Endgame&#39;:</code>：想要渲染的文字内容，如果想要输入 <code>:</code>，需要使用 <code>\</code> 进行转义</li><li><code>x=700:y=200</code>：分别为水印距视频左侧 700 偏移量，距顶部 200 偏移量，默认为 0</li><li><code>fontsize=24:</code>：字体大小，默认为 16</li><li><code>fontcolor=red:</code>：字体颜色红色，默认为黑色</li></ul><h2><span id="zhong-wen-shui-yin">中文水印</span><a href="#zhong-wen-shui-yin" class="header-anchor"></a></h2><p>这是英文的水印，不过我的需求为中文水印，我第一个反应就是乱码问题，先试一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -y -i mavel4.mp4 \</span><br><span class="line">    -vf <span class="string">"drawtext=\</span></span><br><span class="line"><span class="string">        text='复仇者联盟：终局之战':\</span></span><br><span class="line"><span class="string">        x=700:\</span></span><br><span class="line"><span class="string">        y=200:\</span></span><br><span class="line"><span class="string">        fontsize=24:\</span></span><br><span class="line"><span class="string">        fontcolor=red:\</span></span><br><span class="line"><span class="string">        "</span> \</span><br><span class="line">    mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>果然，都是方块</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel4.png" alt="mavel4"></p><p>这是因为默认的字体文件并不支持中文，此时我们需要使用 <code>fontfile</code> 属性来制定字体文件。</p><p>网上很多博客都直接使用 <code>fontfile=PingFang.ttc:</code> 来指定文件，这多少有点误人子弟，此处应该使用字体文件的<strong><em>绝对地址</em></strong>。</p><p>如何获取 Mac 电脑中字体文件的绝对地址呢，请看我的的这篇文章 <a href="/2019/04/03/mac-fonts-path/">Mac 电脑查看字体文件位置</a></p><p>我选择了苹方字体，绝对地址为 <code>/System/Library/Fonts/PingFang.ttc</code>，完整命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -y -i mavel4.mp4 \</span><br><span class="line">    -vf <span class="string">"drawtext=\</span></span><br><span class="line"><span class="string">        fontfile=/System/Library/Fonts/PingFang.ttc:\</span></span><br><span class="line"><span class="string">        text='复仇者联盟：终局之战':\</span></span><br><span class="line"><span class="string">        x=700:\</span></span><br><span class="line"><span class="string">        y=200:\</span></span><br><span class="line"><span class="string">        fontsize=24:\</span></span><br><span class="line"><span class="string">        fontcolor=red:\</span></span><br><span class="line"><span class="string">        "</span> \</span><br><span class="line">    mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>最终渲染效果</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel5.png" alt="mavel5"></p><p>文字水印还有很多参数，大家可以根据自己的需求进行选择，文档地址：<a href="https://ffmpeg.org/ffmpeg-filters.html#drawtext-1" target="_blank" rel="noopener">https://ffmpeg.org/ffmpeg-filters.html#drawtext-1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有给视频加文字水印的需求，第一个想到的肯定是使用 ffmpeg，搜索了下发现网上的博客多是从别人那复制过来的，直接使用多是报错，经过摸索后，终于搞清楚了简单用法，今天简单总结下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ffmpeg" scheme="http://wxnacy.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Python 复制文件的两种方式</title>
    <link href="http://wxnacy.com/2019/04/07/python-copy-command/"/>
    <id>http://wxnacy.com/2019/04/07/python-copy-command/</id>
    <published>2019-04-07T10:48:45.000Z</published>
    <updated>2019-04-07T10:48:45.188Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中实现文件复制，大概分为两种方式<strong>复制函数</strong>和<strong>调用 shell</strong></p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#han-shu-fu-zhi">函数复制</a></li><li><a href="#diao-yong-shell">调用 shell</a></li><li><a href="#xiao-lu-dui-bi">效率对比</a></li></ul><!-- tocstop --></div><h2><span id="han-shu-fu-zhi">函数复制</span><a href="#han-shu-fu-zhi" class="header-anchor"></a></h2><p><code>shutil</code> 模块中有几个可以实现复制的方法</p><p>其实 <code>copy()</code> 方法是最常用到的，它相当于 <code>cp -P</code> 命令，可以复制文件的内容和权限。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># shutil.copy(源文件, 目标文件) 目标文件可以是目录</span></span><br><span class="line">shutil.copy(<span class="string">'test.sh'</span>, <span class="string">'test_copy.sh'</span>)</span><br><span class="line">shutil.copy(<span class="string">'test.sh'</span>, <span class="string">'/tmp'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x  1 wxnacy  wheel     90 Apr  6 19:05 test.sh</span><br><span class="line">-rwxr-xr-x  1 wxnacy  wheel     90 Apr  6 19:09 test_copy.sh</span><br></pre></td></tr></table></figure><p><code>copy()</code> 方法中调用了 <code>copyfile()</code> <code>copymode()</code> 两个方法。</p><ul><li><code>copyfile()</code> 负责复制文件内容，但是目标文件不能是目录，并且必须可以写入</li><li><code>copymode()</code> 负责复制文件权限</li></ul><p><code>copyfile()</code> 方法中又调用了低级方法 <code>copyfileobj()</code></p><p><code>copyfileobj()</code> 方法可以假定了一个可选参数（缓冲区大小），你可以用来设置缓冲区长度。这是复制过程中保存在内存中的字节数。系统使用的默认大小是 16 KB。</p><p>还有个 <code>copy2()</code> 方法，它类似 <code>copy()</code>，但是它可以在复制数据时获取元数据中添加的访问和修改时间。</p><p>几个方法就功能而言 <code>copy2() &gt; copy() &gt; copyfile()</code>，相对应的功能和耗时是成正比的，所以我建议一般情况下可以使用 <code>copy()</code> 方法，如果大批量复制操作，并且没有特殊权限，比如图片，那么还是使用 <code>copyfile()</code> 更好一点。</p><h2><span id="diao-yong-shell">调用 shell</span><a href="#diao-yong-shell" class="header-anchor"></a></h2><p>还有一个万能的方式是直接调用 shell 命令。</p><p>现在使用 <code>subprocess</code> 模块代替其他调用 shell 的模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"></span><br><span class="line">cmds = shlex.split(<span class="string">"cp test.sh test_popen.sh"</span>)</span><br><span class="line">p = subprocess.Popen(cmds)</span><br><span class="line">p.communicate()</span><br></pre></td></tr></table></figure><p><code>Popen()</code> 方法的第一个参数为执行的命令，在 Unix 系统中，如果该参数为字符串，那它只能是一个可执行文件，如果想要传参，则必须以数组的形式传入，<code>shlex.split()</code> 方法可以将复杂的命令转换为数组的形式。</p><p>在 Windows 系统中可以使用字符串传入命令行，并且需要使用 <code>copy source_file target_file</code> 命令。</p><h2><span id="xiao-lu-dui-bi">效率对比</span><a href="#xiao-lu-dui-bi" class="header-anchor"></a></h2><p>最后对比下他们的速度，执行 100 次时间如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">copy_file time    0.022215532000000003</span><br><span class="line">copy time         0.059561121999999994</span><br><span class="line">copy2 time        0.07728823600000001</span><br><span class="line">popen time        0.37018151000000005</span><br></pre></td></tr></table></figure><p>大概是 <code>subprocess</code> 模块会生成子进程的原因，速度慢了很多，在这种情况下，复制操作优选依然是 <code>copy()</code> <code>copyfile()</code> 方法。</p><ul><li><a href="https://www.techbeamers.com/python-copy-file/" target="_blank" rel="noopener">How to Copy a File in Python – 9 Different Ways to do It!</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中实现文件复制，大概分为两种方式&lt;strong&gt;复制函数&lt;/strong&gt;和&lt;strong&gt;调用 shell&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 操作剪切板</title>
    <link href="http://wxnacy.com/2019/04/06/python-clipboard/"/>
    <id>http://wxnacy.com/2019/04/06/python-clipboard/</id>
    <published>2019-04-06T09:59:15.000Z</published>
    <updated>2019-04-06T09:59:15.248Z</updated>
    
    <content type="html"><![CDATA[<p>Python 操作剪切板，需要调用系统的 C 动态库，或者使用自带的命令行。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#shi-yong-pbcopy-he-pbpaste">使用 pbcopy 和 pbpaste</a></li><li><a href="#shi-yong-pyperclip-mo-kuai">使用 pyperclip 模块</a></li></ul><!-- tocstop --></div><p>Windows 系统可以动态调用 <code>ctypes</code> 库，具体操作步骤可以看看这篇文章：<a href="https://www.jianshu.com/p/430f4af2cb06" target="_blank" rel="noopener">https://www.jianshu.com/p/430f4af2cb06</a></p><p>下面我们主要来说下 Mac 系统的操作方式。</p><h2><span id="shi-yong-pbcopy-he-pbpaste">使用 pbcopy 和 pbpaste</span><a href="#shi-yong-pbcopy-he-pbpaste" class="header-anchor"></a></h2><p>在 Mac 系统中可以使用 <code>pbcopy</code> 和 <code>pbpaste</code> 来实现复制粘贴操作，这两个命令都是系统自带的。</p><p><code>pbcopy</code> 接收管道输入的文字，并复制到剪切板。<code>pbpaste</code> 直接输出剪切板的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'我爱你中国'</span> | pbcopy</span><br><span class="line">$ pbpaste</span><br><span class="line">我爱你中国</span><br></pre></td></tr></table></figure><p>使用起来还是很方便的，接下来是 Python 中如何调用。</p><p>使用 <code>subprocess</code> 模块下的 <code>Popen</code> 方法，可以很方便的操作管道的输入输出信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 在 Mac 系统中使用剪切板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_clipboard</span><span class="params">(data: str)</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">'pbcopy'</span>], stdin=subprocess.PIPE)</span><br><span class="line">    p.stdin.write(data.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    p.stdin.close()</span><br><span class="line">    p.communicate()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_from_clipboard</span><span class="params">()</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">'pbpaste'</span>], stdout=subprocess.PIPE)</span><br><span class="line">    p.wait()</span><br><span class="line">    byte_data = p.stdout.read()</span><br><span class="line">    p.stdout.close()</span><br><span class="line">    <span class="keyword">return</span> byte_data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    set_clipboard(<span class="string">'我爱你中国'</span>)</span><br><span class="line">    print(get_from_clipboard())</span><br><span class="line"></span><br><span class="line"><span class="comment"># python clipboard.py</span></span><br><span class="line"><span class="comment"># 我爱你中国</span></span><br></pre></td></tr></table></figure><h2><span id="shi-yong-pyperclip-mo-kuai">使用 pyperclip 模块</span><a href="#shi-yong-pyperclip-mo-kuai" class="header-anchor"></a></h2><p>如果你的系统需要适应各个平台，并且需要比较高的稳定性，那还是直接使用第三方模块 <a href="https://github.com/asweigart/pyperclip" target="_blank" rel="noopener">pyperclip</a> 比较方便。</p><p>它的源码地址为：<a href="https://github.com/asweigart/pyperclip/blob/master/src/pyperclip/__init__.py" target="_blank" rel="noopener">https://github.com/asweigart/pyperclip/blob/master/src/pyperclip/__init__.py</a></p><p>其实他就是整合了上述的方法，只是应该了这么多人的使用，已经非常稳定，使用方法也更简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pyperclip</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pyperclip.copy(<span class="string">'The text to be copied to the clipboard.'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pyperclip.paste()</span><br><span class="line"><span class="string">'The text to be copied to the clipboard.'</span></span><br></pre></td></tr></table></figure><p><code>Windows</code> 和 <code>Mac</code> 平台可以直接使用。</p><p><code>Linux</code> 需要 <code>xclip</code> <code>xsel</code> <code>gtk</code> <code>PyQt4</code> 依赖包，可以根据平台通过 <code>apt</code> 或 <code>yum</code> 进行安装。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 操作剪切板，需要调用系统的 C 动态库，或者使用自带的命令行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Expect 设置变量和读取环境变量</title>
    <link href="http://wxnacy.com/2019/04/05/expect-variables/"/>
    <id>http://wxnacy.com/2019/04/05/expect-variables/</id>
    <published>2019-04-05T12:34:00.000Z</published>
    <updated>2019-04-05T12:34:00.928Z</updated>
    
    <content type="html"><![CDATA[<p>Expect 中设置变量跟 Bash 稍有不同</p><a id="more"></a><p><strong>Bash</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=wxnacy</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span>  <span class="comment"># wxnacy</span></span><br></pre></td></tr></table></figure><p><strong>Expect</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name wxnacy</span><br><span class="line">puts <span class="variable">$name</span>  <span class="comment"># wxnacy</span></span><br></pre></td></tr></table></figure><p>边境变量也是如此</p><p><strong>Bash</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span>      <span class="comment"># /Users/wxnacy</span></span><br></pre></td></tr></table></figure><p><strong>Expect</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="variable">$env</span>(HOME) <span class="comment"># /Users/wxnacy</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Expect 中设置变量跟 Bash 稍有不同&lt;/p&gt;
    
    </summary>
    
    
      <category term="expect" scheme="http://wxnacy.com/tags/expect/"/>
    
  </entry>
  
</feed>
