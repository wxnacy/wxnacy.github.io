<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-06-07T21:48:00.191Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 查看文件的几种方式</title>
    <link href="http://wxnacy.com/2019/06/08/linux-show-file/"/>
    <id>http://wxnacy.com/2019/06/08/linux-show-file/</id>
    <published>2019-06-07T21:48:00.000Z</published>
    <updated>2019-06-07T21:48:00.191Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 中查看文件是很常见的操作，根据需求不同可以有几个不同的查看方式。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#cat">cat</a></li><li><a href="#head">head</a></li><li><a href="#tail">tail</a></li><li><a href="#less">less</a></li></ul><!-- tocstop --></div><p>首先点击下载一个 demo 文件: <a href="https://raw.githubusercontent.com/wxnacy/file/master/common/nums.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/wxnacy/file/master/common/nums.txt</a></p><h2><span id="cat">cat</span><a href="#cat" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat nums.txt</span><br></pre></td></tr></table></figure><p><code>cat</code> 可以将文本全部打印到屏幕中，但是只适合短小的文件，像这个 600 行的文件，翻看起来会很麻烦，如果你刚好是看最后几行的内容还好，如果想看头几行的内容那就惨了。</p><p><strong>其他参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat -e nums.txt       <span class="comment"># 每行最后添加 $ 符号</span></span><br><span class="line">$ cat -n nums.txt       <span class="comment"># 每行开头带有行号</span></span><br></pre></td></tr></table></figure><h2><span id="head">head</span><a href="#head" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ head nums.txt</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><code>head</code> 可以查看前十行的内容，另外可以传参查看前 n 行的数据，或者前 n 个字节的数据。</p><p><strong>其他参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ head -n 15 nums.txt   <span class="comment"># 前 15 行</span></span><br><span class="line">$ head -c 90 nums.txt   <span class="comment"># 前 90 字节</span></span><br></pre></td></tr></table></figure><h2><span id="tail">tail</span><a href="#tail" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tail nums.txt</span><br><span class="line"></span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br></pre></td></tr></table></figure><p><code>tail</code> 查看末尾 10 行的数据，经常查看日志的同学肯定对它很熟悉，<code>tail -f file</code> 可以等待文件追加并且到屏幕中，动态查看新增日志非常常用。</p><p><strong>其他参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tail -n 15 nums.txt     <span class="comment"># 末尾 15 行的数据</span></span><br><span class="line">tail -c 15 nums.txt     <span class="comment"># 末尾 15 个字节的数据</span></span><br><span class="line">tail -b 1 nums.txt      <span class="comment"># 末尾 1 个 512 字节块的数据</span></span><br><span class="line">tail -q nums.txt n.txt  <span class="comment"># 检查多个文件时，进制打印标头</span></span><br><span class="line">tail -f nums.txt        <span class="comment"># 等待文件追加，并输出到标准输出中</span></span><br><span class="line">tail -r -n 10 nums.txt  <span class="comment"># 将最后 10 行，倒序显示</span></span><br></pre></td></tr></table></figure><h2><span id="less">less</span><a href="#less" class="header-anchor"></a></h2><p>最后是重头戏，<code>less</code> 是 Linux 的正统查看文件的方式，相似的还有 <code>more</code> 命令，虽然都说它不如 <code>less</code>，但是我觉得两者相差无几。</p><p><code>less</code> 可以分页显示文档，翻页的方式与 <code>vim</code> 几乎一致，如果你不了解 <code>vim</code> 的翻页机制，可以看这里 <a href="https://vim.wxnacy.com/#docs/all-key#%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8" target="_blank" rel="noopener">光标移动</a></p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/less1.gif" alt="1"></p><p>它还可以搜索文件，方式也与 <code>vim</code> 一样，输入 <code>/</code> 后输入匹配字符，使用 <code>n</code> 向后查找，使用 <code>N</code> 向前查找</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/less2.gif" alt="2"></p><p>查看多个文件时，使用 <code>:e filename</code> 切换查看文件，或者使用 <code>:n</code> 和 <code>:p</code> 向后或向前查找</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/less3.gif" alt="3"></p><p>既然它跟 <code>vim</code> 有这么多的相似点，那切换到 <code>vim</code> 模式也是很方便的，按下 <code>v</code> 即可</p><p>使用 <code>F</code> 则可以达到 <code>tail -f file</code> 的效果，等待文件的输入，<code>&lt;CTRL-C&gt;</code> 退出。</p><p>最后按下 <code>q</code> 即可退出 <code>less</code> 模式。</p><p><code>less</code> 命令模式非常常见，帮助命令 <code>man</code> 就是完全依照此模式来使用的，使用 <code>man less</code> 查看更多的使用方式。</p><p><strong>其他参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ less -N nums.txt      <span class="comment"># 显示行号</span></span><br><span class="line">$ less -m nums.txt      <span class="comment"># 显示查看的百分比进度</span></span><br><span class="line">$ less -e nums.txt      <span class="comment"># 查看到文档末尾时，自动退出</span></span><br><span class="line">$ less +20 nums.txt     <span class="comment"># 从第 20 行开始查看</span></span><br></pre></td></tr></table></figure><p>其它的命令搭配 <code>less</code> 管道输入模式可以起到很好的效果。</p><p><strong>分页显示当前所有进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | less</span><br></pre></td></tr></table></figure><p><strong>分页显示历史命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">history</span> | less</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 中查看文件是很常见的操作，根据需求不同可以有几个不同的查看方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 二分查找模块 bisect</title>
    <link href="http://wxnacy.com/2019/06/07/python-bisect/"/>
    <id>http://wxnacy.com/2019/06/07/python-bisect/</id>
    <published>2019-06-07T12:50:03.000Z</published>
    <updated>2019-06-07T12:50:03.243Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中 bisect 模块的作用是将一个数字插入到一个排好序的数组中，而不影响数组原来的排序。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>换句话说是找到一个数字在一个排序数组中应该出现的位置，而它采用的是二分查找法。</p><p>既然是二分查找法首先要准备一个排好序的数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>我们希望知道再插入一个 <code>4</code>，应该出现在什么位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bisect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.bisect(a, <span class="number">4</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>bisect()</code> 方法只是返回一个索引不会更改数组，另外还有 <code>bisect_right()</code> 和 <code>bisect_left()</code> 两个方法，<code>bisect_right()</code> 等同于 <code>bisect()</code> 都是从数组右侧开始查找，而 <code>bisect()</code> 是从左侧开始查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.bisect_left(a, <span class="number">4</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果想要直接插入这个数字呢？可以用 <code>insort()</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.insort(a, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>这个方法没有返回值，是在原数组上做的修改，另外也还有 <code>insort_left()</code> 和 <code>insort_right()</code>，他们的作用相信你已经明白了。</p><p>说到这的话，其实标题说 <code>bisect</code> 是二分查找模块有点不准确，因为当数组中没有该数字时，<code>bisect.bisect()</code> 方法也会返回一个有效索引。所以如果我们想把它当做二分查找法的话，还需要做一些判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(nums, n)</span>:</span></span><br><span class="line">    i = bisect.bisect_left(nums, n)</span><br><span class="line">    <span class="keyword">if</span> i &gt;= len(nums):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> nums[i] == n:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>最后要说的是，数组只能是正序，如果是倒序该模块不生效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.insort_left(a, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中 bisect 模块的作用是将一个数字插入到一个排好序的数组中，而不影响数组原来的排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>cURL 如何只返回状态码 status code</title>
    <link href="http://wxnacy.com/2019/06/06/curl-return-code/"/>
    <id>http://wxnacy.com/2019/06/06/curl-return-code/</id>
    <published>2019-06-06T00:15:42.000Z</published>
    <updated>2019-06-06T00:48:28.816Z</updated>
    
    <content type="html"><![CDATA[<p>在写一些 Shell 测试用例时需要检测 url 的状态是否为 <code>200</code>，这时如果能只获取它的状态码是最理想的，cURL 可以很方便的实现。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p><code>-w</code> 可以格式化输出 reponse 的返回结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl -w <span class="string">"%&#123;http_code&#125;"</span> https://baidu.com</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=<span class="string">"white"</span>&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;bfe/1.0.8.18&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">302%</span><br></pre></td></tr></table></figure><p>访问带有跳转性质的网站，我们还需要加上 <code>-L</code> 做进一步跳转，同时为了避免当资源过大请求缓慢的情况，通过 <code>-I</code> 只返回头信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ curl -IL -w <span class="string">"%&#123;http_code&#125;"</span> https://baidu.com</span><br><span class="line"></span><br><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: bfe/1.0.8.18</span><br><span class="line">Date: Thu, 06 Jun 2019 00:25:02 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 161</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://www.baidu.com/</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 277</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Thu, 06 Jun 2019 00:25:05 GMT</span><br><span class="line">Etag: <span class="string">"575e1f60-115"</span></span><br><span class="line">Last-Modified: Mon, 13 Jun 2016 02:50:08 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Server: bfe/1.0.8.18</span><br><span class="line"></span><br><span class="line">200%</span><br></pre></td></tr></table></figure><p>然后隐藏掉打印信息，将打印的结果输出到 <code>/dev/null</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -IL -w <span class="string">"%&#123;http_code&#125;"</span> -o /dev/null https://baidu.com</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0   161    0     0    0     0      0      0 --:--:--  0:00:03 --:--:--     0</span><br><span class="line">  0   277    0     0    0     0      0      0 --:--:--  0:00:03 --:--:--     0</span><br><span class="line">200%</span><br></pre></td></tr></table></figure><p>竟然还有多余信息，继续使用 <code>-s</code> 不显示进度和错误信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sIL -w <span class="string">"%&#123;http_code&#125;"</span> -o /dev/null https://baidu.com</span><br><span class="line">200%</span><br></pre></td></tr></table></figure><p>最后的最后，默认输出是不换行的，也就是会带有一个 <code>%</code> 符号，我们有两种方式去掉它</p><p><strong>输出换行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sIL -w <span class="string">"%&#123;http_code&#125;\n"</span> -o /dev/null https://baidu.com</span><br><span class="line">200</span><br></pre></td></tr></table></figure><p><strong>使用 echo</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(curl -sIL -w <span class="string">"%&#123;http_code&#125;"</span> -o /dev/null https://baidu.com)</span><br><span class="line">200</span><br></pre></td></tr></table></figure><p><code>-w</code> 的一些其它参数，没有注明的可以自行测试下</p><ul><li><code>url_effective</code></li><li><code>http_code</code> 状态码</li><li><code>http_connect</code></li><li><code>time_total</code> 请求总用时</li><li><code>time_namelookup</code> DNS 域名解析的时候，就是把 <a href="https://baidu.com" target="_blank" rel="noopener">https://baidu.com</a> 转换成 ip 地址的过程</li><li><code>time_connect</code> TCP 连接建立的时间，就是三次握手的时间</li><li><code>time_appconnect</code> SSL/SSH 等上层协议建立连接的时间，比如 connect/handshake 的时间</li><li><code>time_redirect</code> 从开始到最后一个请求事务的时间</li><li><code>time_pretransfer</code> 从请求开始到响应开始传输的时间</li><li><code>time_starttransfer</code> 从请求开始到第一个字节将要传输的时间</li><li><code>size_download</code></li><li><code>size_upload</code></li><li><code>size_header</code></li><li><code>size_request</code></li><li><code>speed_download</code></li><li><code>speed_upload</code></li><li><code>content_type</code></li><li><code>num_connects</code></li><li><code>num_redirects</code></li><li><code>ftp_entry_path</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写一些 Shell 测试用例时需要检测 url 的状态是否为 &lt;code&gt;200&lt;/code&gt;，这时如果能只获取它的状态码是最理想的，cURL 可以很方便的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://wxnacy.com/tags/http/"/>
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置有爱心的 404</title>
    <link href="http://wxnacy.com/2019/06/04/lovely-404/"/>
    <id>http://wxnacy.com/2019/06/04/lovely-404/</id>
    <published>2019-06-04T13:39:02.000Z</published>
    <updated>2019-06-04T13:39:02.534Z</updated>
    
    <content type="html"><![CDATA[<p>之前我是不太在乎 404 页面的，一是我基本不会修改网页的地址，搜索过来的时候都能准确访问。二是我默认看我博客的都是技术人员，他们可以很容易的找到首页地址，虽然我的博客可能不会让他们有那么大的动力这么干。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>但是，今天我想配置上 404 的页面，一个有爱心的 404 页面</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/404-2_709.png" alt="1"></p><p>作为一名老父亲，看到这些丢失的孩子，心里是感觉被揪了一下的。如果你也想在自己的站点加一个这样的 404 页面，可以接着看下去。</p><p>这个页面是由益云提供的，这是他们的网址 <a href="https://yibo.iyiyun.com/Home/Index/web404" target="_blank" rel="noopener">https://yibo.iyiyun.com/Home/Index/web404</a></p><p>点击进入后根据自己的需求选择完成后，点击生成代码即可</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/404-3_1285.png" alt="2"></p><p>复制生成的代码，黏贴你自己的 <code>404.html</code> 的 <code>body</code> 标签中即可。</p><p>然后怎么在网站中生效呢？如果你之前配置过，那现在刷新页面就已经生效了。如果像我一样没有配置过，那只要在 Nginx 中做一些小改动即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    error_page 404 404.html;</span><br><span class="line"></span><br><span class="line">    location /404.html &#123;</span><br><span class="line">        # 配置 404.html 的目录</span><br><span class="line">        root   /www/wxnacy.github.io/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你的 <code>server</code> 标签中也做如上配置即可，<code>root</code> 改成你存放 <code>404.html</code> 页面的目录</p><p><strong>重新加载配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -t          <span class="comment"># 测试配置是否通过</span></span><br><span class="line">$ nginx -s reload   <span class="comment"># 重新加载</span></span><br></pre></td></tr></table></figure><p>再次访问网站的 404 页面即可生效。</p><p>需要注意的一点，他默认提供的代码中，给的是 <code>http://</code> 开头的网址，如果你的网站是 <code>https</code> 的话，那会请求失败，所以需要手动改成 <code>https</code>。</p><p>说到公益 404，印象比较深的是微信公众号里的 web 页面，如果网页提供者返回了 404 状态，那微信就会强制显示这个公益的 404 页面，而提供者的页面就会被覆盖。虽然这是件有爱心的事，但做法却有点耍流氓，你也不能强制别人献爱心啊。</p><p>最后呢，希望我的一点小小的举动，可以给身处黑暗中的孩子一点莹莹星火，让他们可以早点找到家的方向。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我是不太在乎 404 页面的，一是我基本不会修改网页的地址，搜索过来的时候都能准确访问。二是我默认看我博客的都是技术人员，他们可以很容易的找到首页地址，虽然我的博客可能不会让他们有那么大的动力这么干。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://wxnacy.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>MkDocs 使用 Markdown 管理项目文档</title>
    <link href="http://wxnacy.com/2019/06/03/mkdocs/"/>
    <id>http://wxnacy.com/2019/06/03/mkdocs/</id>
    <published>2019-06-03T00:54:17.000Z</published>
    <updated>2019-06-03T00:54:18.014Z</updated>
    
    <content type="html"><![CDATA[<p>坚持写博客也两年多了，使用 hexo 的一个很大的问题就是不太方便写系列性的文章，属于比较随性的想起什么写什么，最近发现了 <a href="https://github.com/mkdocs/mkdocs" target="_blank" rel="noopener">mkdocs</a>，同样的使用 Markdown 格式编写文档，写系列文章很合适。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#an-zhuang-shi-yong">安装使用</a></li><li><a href="#pei-zhi">配置</a></li></ul><!-- tocstop --></div><p>它的官网就是用 mkdocs 搭建的。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mkdocs2_1058.png" alt="2"></p><p>如果这个界面不熟悉的话，看下面的截图</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mkdocs1_1102.png" alt="1"></p><p>这是它为著名的 <a href="https://readthedocs.org/" target="_blank" rel="noopener">readthedocs</a> 提供的主题，是不是很亲切。</p><p>mkdocs 使用配置起来都很简单，它是由 Python 编写的，这是让我亲切的另一个原因。</p><h2><span id="an-zhuang-shi-yong">安装使用</span><a href="#an-zhuang-shi-yong" class="header-anchor"></a></h2><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install mkdocs</span><br></pre></td></tr></table></figure><p><strong>生成项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdocs new my-project</span><br><span class="line">$ <span class="built_in">cd</span> my-project</span><br></pre></td></tr></table></figure><p>项目的结构如下</p><p><img src="https://www.mkdocs.org/img/initial-layout.png" alt="3"></p><p><strong>启动服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdocs serve</span><br><span class="line">INFO    -  Building documentation...</span><br><span class="line">INFO    -  Cleaning site directory</span><br><span class="line">[I 160402 15:50:43 server:271] Serving on http://127.0.0.1:8000</span><br><span class="line">[I 160402 15:50:43 handlers:58] Start watching changes</span><br><span class="line">[I 160402 15:50:43 handlers:60] Start detecting changes</span><br></pre></td></tr></table></figure><p>mkdocs 会启动一个端口为 8000 的服务，效果如下</p><p><img src="https://www.mkdocs.org/img/screenshot.png" alt="4"></p><p>网页首页默认打开的是文档 <code>docs/index.md</code>，修改文档内容，网页会自动刷新到最新状态。</p><p><strong>生成静态文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdocs build</span><br></pre></td></tr></table></figure><p>随后根目录下会生成一个 <code>site</code> 文件夹，内容是文档的静态网页，使用 Nginx 代理即可访问。</p><h2><span id="pei-zhi">配置</span><a href="#pei-zhi" class="header-anchor"></a></h2><p>mkdocs 的全部配置都在 <code>mkdocs.yml</code> 中，一个最简单的配置如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site_name:</span> <span class="string">MkLorum</span>      <span class="comment"># 站点名称</span></span><br><span class="line"><span class="attr">nav:</span>                    <span class="comment"># 文档目录</span></span><br><span class="line"><span class="attr">    - Home:</span> <span class="string">index.md</span></span><br><span class="line"><span class="attr">    - About:</span> <span class="string">about.md</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">readthedocs</span>      <span class="comment"># 主题</span></span><br></pre></td></tr></table></figure><p><img src="https://www.mkdocs.org/img/readthedocs.png" alt="5"></p><p>另外还有一些常用配置</p><ul><li><code>repo_url</code> 页面会生成一个链接，指向仓库地址，可以是 <code>GitHub, Bitbucket, GitLab</code> 等</li><li><code>site_description</code> 网站的描述</li><li><code>copyright</code> 版权信息</li><li><code>google_analytics</code> 配置 <code>Google analytics</code> 信息，接收一个数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google_analytics: [&apos;UA-36723568-3&apos;, &apos;mkdocs.org&apos;]</span><br></pre></td></tr></table></figure><ul><li><code>docs_dir</code> 文档的存放目录，默认为 <code>docs</code></li><li><code>site_dir</code> 生成静态网页的存放目录，默认为 <code>site</code></li><li><code>dev_addr</code> 使用 <code>mkdocs serve</code> 时启动的地址和端口号，默认 <code>127.0.0.1:8000</code></li></ul><p>更多的配置详见<a href="https://www.mkdocs.org/user-guide/configuration/" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;坚持写博客也两年多了，使用 hexo 的一个很大的问题就是不太方便写系列性的文章，属于比较随性的想起什么写什么，最近发现了 &lt;a href=&quot;https://github.com/mkdocs/mkdocs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mkdocs&lt;/a&gt;，同样的使用 Markdown 格式编写文档，写系列文章很合适。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
      <category term="工具" scheme="http://wxnacy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>重新学 Java 系列：数组</title>
    <link href="http://wxnacy.com/2019/05/29/java-array/"/>
    <id>http://wxnacy.com/2019/05/29/java-array/</id>
    <published>2019-05-29T01:47:05.000Z</published>
    <updated>2019-05-29T02:36:38.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个是一个系列阅读，关于为什么重新学习，我在文章 <a href="/2018/12/29/java-renew-why/">重新学 Java 系列：新系列、新开始</a>(<a href="https://wxnacy.com/2018/12/29/java-renew-why/">https://wxnacy.com/2018/12/29/java-renew-why/</a>) 中有提到，这个系列是在有 Java 基础的情况下，重新学习讨论一下以前可能忽略掉，或者没理解的知识细节，我想要永远在学习的路上。</p></blockquote><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ding-yi">定义</a></li><li><a href="#bian-li">遍历</a></li><li><a href="#fang-fa">方法</a></li><li><a href="#can-kao">参考</a></li></ul><!-- tocstop --></div><p>已经习惯了 Python 的列表对象，再回来看 Java 的数组和列表很是不适，这种不适已经上升到了生理反应，我为什么要重新学 Java？我是谁？我在哪？</p><p>Java 中数组是用来存储<strong><em>固定大小</em></strong>的<strong><em>同类型</em></strong>元素。</p><h2><span id="sheng-ming">声明</span><a href="#sheng-ming" class="header-anchor"></a></h2><p><code>int</code> 类型数组有两种声明方式 <code>int[] varName</code> 或者 <code>int varName[]</code>，一般建议使用第一种声明方式。后者来源于 <code>c/c++</code>，是为了让 <code>c/c++</code> 程序员快速理解 Java。</p><h2><span id="ding-yi">定义</span><a href="#ding-yi" class="header-anchor"></a></h2><p>有三种定义方式</p><p><strong>静态初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>静态初始化简化方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>静态初始化不能指定元素个数，或者说初始化后元素个数已经固定了，不需要指定。</p><p><strong>动态初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>动态初始化后，数组每个元素会赋值当前类型的默认值，分别如下所以：</p><table><thead><tr><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>整数类型（byte、short、int、long）</td><td>0</td></tr><tr><td>浮点类型（float、double）</td><td>0.0</td></tr><tr><td>字符类型（char）</td><td>‘\u0000’</td></tr><tr><td>布尔类型（boolean）</td><td>false</td></tr><tr><td>引用类型（类、接口、数组）</td><td>null</td></tr></tbody></table><h2><span id="bian-li">遍历</span><a href="#bian-li" class="header-anchor"></a></h2><p>两种方式 <code>for</code> 和 <code>forEach</code></p><p><strong>for</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>forEach</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> n: nums ) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="fang-fa">方法</span><a href="#fang-fa" class="header-anchor"></a></h2><p>数组本身不提供方法，只有一个变量 <code>length</code> 用来获取数组的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = nums.length</span><br></pre></td></tr></table></figure><p>记得当年刚开始学习 Java 时，总是跟列表的 <code>size()</code> 方法搞混，不知道什么时候用 <code>length</code>，什么时候用 <code>size()</code>。现在看来只需要记住，数组的大小是不可变的，所以使用变量 <code>length</code> 即可获取数组大小。而列表是可变的，所以需要使用方法 <code>size()</code> 动态获取大小。</p><p><code>java.util.Arrays</code> 类提供了操作数组的方法，都是静态方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public static void sort(Object[] a)</td><td>排序数组，升序</td></tr><tr><td>public static int binarySearch(Object[] a, Object key)</td><td>使用二分搜索来搜索给定元素，数组需要先排序，返回索引</td></tr><tr><td>public static boolean equals(Object[] a, Object[] a2)</td><td>比较数组是否相同，返回 boolean 类型</td></tr><tr><td>public static void fill(Object[] a, Object val)</td><td>给数组的所有元素指定某个值</td></tr></tbody></table><h2><span id="can-kao">参考</span><a href="#can-kao" class="header-anchor"></a></h2><ul><li><a href="https://www.runoob.com/java/java-array.html" target="_blank" rel="noopener">Java 数组</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个是一个系列阅读，关于为什么重新学习，我在文章 &lt;a href=&quot;/2018/12/29/java-renew-why/&quot;&gt;重新学 Java 系列：新系列、新开始&lt;/a&gt;(&lt;a href=&quot;https://wxnacy.com/2018/12/29/java-renew-why/&quot;&gt;https://wxnacy.com/2018/12/29/java-renew-why/&lt;/a&gt;) 中有提到，这个系列是在有 Java 基础的情况下，重新学习讨论一下以前可能忽略掉，或者没理解的知识细节，我想要永远在学习的路上。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://wxnacy.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>异或运算及应用</title>
    <link href="http://wxnacy.com/2019/05/28/what-is-xor/"/>
    <id>http://wxnacy.com/2019/05/28/what-is-xor/</id>
    <published>2019-05-28T06:04:30.000Z</published>
    <updated>2019-05-28T06:21:41.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>异或，英文为exclusive OR，缩写成xor，异或是一个数学运算符。它应用于逻辑运算</p></blockquote><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>异或也叫半加运算，其运算法则相当于不带进位的二进制加法，它的运算规则为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制的比较位相同则结果返回 0，不同则为 1</span><br></pre></td></tr></table></figure><p>运算符有几种表示方式</p><table><thead><tr><th>名称</th><th>符号</th></tr></thead><tbody><tr><td>数学符号</td><td>⊕</td></tr><tr><td>英文简称</td><td>xor</td></tr><tr><td>程序符号</td><td>^</td></tr></tbody></table><p><strong>运算推导</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 ^ 8 = 2</span><br></pre></td></tr></table></figure><p>单看这个表达式比较费解，我们转成二进制来看下</p><table><thead><tr><th>-</th><th>相同</th><th>不同</th><th>相同</th></tr></thead><tbody><tr><td>5</td><td>1</td><td>0</td><td>1</td></tr><tr><td>8</td><td>1</td><td>1</td><td>1</td></tr><tr><td>5 ^ 8</td><td>0</td><td>1</td><td>0</td></tr><tr><td>2</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>异或在开发中的应用可以参看一道算法题 <a href="/leetcode/problems/136-single-number/">只出现一次的数字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;异或，英文为exclusive OR，缩写成xor，异或是一个数学运算符。它应用于逻辑运算&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://wxnacy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python list 对象一些方法的时间复杂度</title>
    <link href="http://wxnacy.com/2019/05/27/python-list-time-complexity/"/>
    <id>http://wxnacy.com/2019/05/27/python-list-time-complexity/</id>
    <published>2019-05-27T09:07:51.000Z</published>
    <updated>2019-05-27T09:36:33.810Z</updated>
    
    <content type="html"><![CDATA[<p>列举下 Python list 对象常用方法的时间复杂度</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><table><thead><tr><th>方法</th><th>时间复杂度</th></tr></thead><tbody><tr><td>list[i]</td><td>O(1)</td></tr><tr><td>list[i] = 1</td><td>O(1)</td></tr><tr><td>list[i:j]</td><td>O(k)  k = j - i</td></tr><tr><td>list[i:k] = list()</td><td>O(n + k)</td></tr><tr><td>list.index(item)</td><td>O(n)</td></tr><tr><td>list.append(item)</td><td>O(1)</td></tr><tr><td>list.insert(i, item)</td><td>O(n)</td></tr><tr><td>list.pop()</td><td>O(1)</td></tr><tr><td>list.pop(i)</td><td>O(n) 假如推出的是第一个元素，那么数组所有的元素都要重新计算坐标</td></tr><tr><td>del list[i]</td><td>O(n)</td></tr><tr><td>item in list</td><td>O(n)</td></tr><tr><td>list.reverse()</td><td>O(n)</td></tr><tr><td>list.sort()</td><td>O(n logn)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列举下 Python list 对象常用方法的时间复杂度&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 跳转其他页面</title>
    <link href="http://wxnacy.com/2019/05/25/js-href/"/>
    <id>http://wxnacy.com/2019/05/25/js-href/</id>
    <published>2019-05-25T01:49:45.000Z</published>
    <updated>2019-05-25T01:51:51.228Z</updated>
    
    <content type="html"><![CDATA[<p>几种常见的页面跳转方式</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span> type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       window.location.href=<span class="string">"login.jsp?backurl="</span>+window.location.href;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</span><br><span class="line">    alert(<span class="string">"返回"</span>);</span><br><span class="line">    window.history.back(-<span class="number">1</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</span><br><span class="line">    window.navigate(<span class="string">"top.jsp"</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"JavaScript"</span>&gt;</span><br><span class="line">    self.location=’top.htm’;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</span><br><span class="line">    alert(<span class="string">"非法访问！"</span>);</span><br><span class="line">    top.location=’xx.jsp’;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种常见的页面跳转方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://wxnacy.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Git blame 查看代码是谁写的</title>
    <link href="http://wxnacy.com/2019/05/21/git-blame/"/>
    <id>http://wxnacy.com/2019/05/21/git-blame/</id>
    <published>2019-05-21T10:30:27.000Z</published>
    <updated>2019-05-21T10:30:27.125Z</updated>
    
    <content type="html"><![CDATA[<p><code>git blame</code> 命令可以查看每行代码的提交详情，包括提交人、时间等信息，成熟的编辑器如 Sublime、Jetbrains 等都集成了这个功能，使用起来非常简单，今天我们来关注下这个命令本身，毕竟在服务器上我们可不能安装这些编辑器。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame1_874.png" alt="1"></p><p>得到的结果，每列分别为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提交 sha1   用户名 提交时间                    行数    代码</span><br><span class="line">...</span><br><span class="line">39a22489    (wxnacy 2018-07-26 19:01:55 +0800  6)      def filter(<span class="built_in">source</span>: dict, *args, **kwargs):</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这是最简单的语法，我们查看文件的每一行代码的最后提交详情，不过这通常不是我们的目的，一般只需要看某一行或某个范围行，这时可以使用 <code>-L</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L &lt;start&gt;[,&lt;end&gt;]</span><br></pre></td></tr></table></figure><p><strong>查看第 10 行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,10</span><br></pre></td></tr></table></figure><p><strong>查看第 10 行及以后</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10</span><br></pre></td></tr></table></figure><p><strong>查看第 10 到 20 行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,20</span><br></pre></td></tr></table></figure><p><code>end</code> 也可以加上正负符号，比如</p><p><strong>查看 10 行以后 5 行的数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,+5</span><br></pre></td></tr></table></figure><p><strong>查看 10 行以前 5 行的数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,-5</span><br></pre></td></tr></table></figure><p><code>start</code> 和 <code>end</code> 又不止于数字，它还可以是个正则表达式，如果 <code>start</code> 为正则表达式，则会匹配到 <code>end</code> 行，如果 <code>end</code> 为正则表达式，则从 <code>start</code> 行开始匹配，到匹配行截止，如果 <code>start</code> 或者 <code>end</code> 其中之一有值，则从匹配行开始显示全部内容。</p><p><strong>查看正则匹配到 20 行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L /filter/,20</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame2_872.png" alt="2"></p><p><strong>查看 3 行到正则匹配行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 3,/filter/</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame3.png" alt="3"></p><p><code>-L</code> 参数的功能还不止这些，有个更智能的方式是直接通过函数名来查看一个区域块的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L:&lt;func_name&gt;</span><br></pre></td></tr></table></figure><p>这是很方便的能力，不过只能识别文件最外层的方法名和类名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L:filter</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame4.png" alt="4"></p><p>完整参数列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">usage: git blame [&lt;options&gt;] [&lt;rev-opts&gt;] [&lt;rev&gt;] [--] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">    &lt;rev-opts&gt; are documented <span class="keyword">in</span> git-rev-list(1)</span><br><span class="line"></span><br><span class="line">    --incremental         Show blame entries as we find them, incrementally</span><br><span class="line">    -b                    Show blank SHA-1 <span class="keyword">for</span> boundary commits (Default: off)</span><br><span class="line">    --root                Do not treat root commits as boundaries (Default: off)</span><br><span class="line">    --show-stats          Show work cost statistics</span><br><span class="line">    --progress            Force progress reporting</span><br><span class="line">    --score-debug         Show output score <span class="keyword">for</span> blame entries</span><br><span class="line">    -f, --show-name       Show original filename (Default: auto)</span><br><span class="line">    -n, --show-number     Show original linenumber (Default: off)</span><br><span class="line">    -p, --porcelain       Show <span class="keyword">in</span> a format designed <span class="keyword">for</span> machine consumption</span><br><span class="line">    --line-porcelain      Show porcelain format with per-line commit information</span><br><span class="line">    -c                    Use the same output mode as git-annotate (Default: off)</span><br><span class="line">    -t                    提交时间显示为时间戳，默认关闭</span><br><span class="line">    -l                    显示完整的 commit sha1，默认关闭</span><br><span class="line">    -s                    Suppress author name and timestamp (Default: off)</span><br><span class="line">    -e, --show-email      显示提交用户的邮箱，默认关闭</span><br><span class="line">    -w                    Ignore whitespace differences</span><br><span class="line">    --indent-heuristic    Use an experimental heuristic to improve diffs</span><br><span class="line">    --minimal             Spend extra cycles to find better match</span><br><span class="line">    -S &lt;file&gt;             Use revisions from &lt;file&gt; instead of calling git-rev-list</span><br><span class="line">    --contents &lt;file&gt;     Use &lt;file&gt;<span class="string">'s contents as the final image</span></span><br><span class="line"><span class="string">    -C[&lt;score&gt;]           Find line copies within and across files</span></span><br><span class="line"><span class="string">    -M[&lt;score&gt;]           Find line movements within and across files</span></span><br><span class="line"><span class="string">    -L &lt;n,m&gt;              Process only line range n,m, counting from 1</span></span><br><span class="line"><span class="string">    --abbrev[=&lt;n&gt;]        use &lt;n&gt; digits to display SHA-1s</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://git-scm.com/docs/git-blame" target="_blank" rel="noopener">git-blame</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;git blame&lt;/code&gt; 命令可以查看每行代码的提交详情，包括提交人、时间等信息，成熟的编辑器如 Sublime、Jetbrains 等都集成了这个功能，使用起来非常简单，今天我们来关注下这个命令本身，毕竟在服务器上我们可不能安装这些编辑器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://wxnacy.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>PySpider 安装的坑：不支持 3.7 版本</title>
    <link href="http://wxnacy.com/2019/05/20/pyspider-install-error-with-3-7/"/>
    <id>http://wxnacy.com/2019/05/20/pyspider-install-error-with-3-7/</id>
    <published>2019-05-20T10:13:05.000Z</published>
    <updated>2019-05-20T10:13:05.730Z</updated>
    
    <content type="html"><![CDATA[<p>PySpider 安装还真是各种坑啊，所以感觉不能单独记录，收成一个系列吧。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>这次的问题是不兼容 3.7 版本，安装虽然成功，但是运行及报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/bin/pyspider"</span>, line 11, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    load_entry_point(<span class="string">'pyspider==0.3.10'</span>, <span class="string">'console_scripts'</span>, <span class="string">'pyspider'</span>)()</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pkg_resources/__init__.py"</span>, line 487, <span class="keyword">in</span> load_entry_point</span><br><span class="line">    <span class="built_in">return</span> get_distribution(dist).load_entry_point(group, name)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pkg_resources/__init__.py"</span>, line 2728, <span class="keyword">in</span> load_entry_point</span><br><span class="line">    <span class="built_in">return</span> ep.load()</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pkg_resources/__init__.py"</span>, line 2346, <span class="keyword">in</span> load</span><br><span class="line">    <span class="built_in">return</span> self.resolve()</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pkg_resources/__init__.py"</span>, line 2352, <span class="keyword">in</span> resolve</span><br><span class="line">    module = __import__(self.module_name, fromlist=[<span class="string">'__name__'</span>], level=0)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pyspider/run.py"</span>, line 231</span><br><span class="line">    async=True, get_object=False, no_input=False):</span><br><span class="line">        ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>一看到这个错误心里就有一种不祥的预感，妥妥的代码出错了啊，咋它就这么多事呢？</p><p>这个错误的原因在于 <code>3.7</code> 版本以上已经把 <code>async</code> 和 <code>await</code> 列为关键字，所以在用 <code>async</code> 当参数名自然会报错，看了下源码，已经将 <code>async</code> 改为了 <code>async_mode</code>，但是最新发行版本 <code>0.3.10</code> 版本已经一年多了，还没有发新版是怎么个意思，作者也觉得 <code>3.7</code> 版本兼容还很大呗，好吧，人家也没说过支持 <code>3.7</code>，你想用就自己折腾呗。</p><p>这时候有两种方式，第一下载最近版本的代码，然后改个版本号自己编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/binux/pyspider</span><br><span class="line">$ <span class="built_in">cd</span> pyspider</span><br><span class="line">$ vim pyspider/__init__.py</span><br><span class="line">__version__ = <span class="string">'0.3.11'</span></span><br><span class="line">$ pip install .</span><br></pre></td></tr></table></figure><p>或者将当前版本的代码修改一下，替换掉 <code>async</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim /Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pyspider/run.py</span><br><span class="line">$ vim /Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pyspider/fetcher/tornado_fetcher.py</span><br><span class="line">$ vim /Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/lib/python3.7/site-packages/pyspider/webui/app.py</span><br></pre></td></tr></table></figure><p>前面那一大坨是本地仓库的位置，打开文件后复制下面的文字然后回车即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/async/async_mode/g</span><br></pre></td></tr></table></figure><p>然后再次运行即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PySpider 安装还真是各种坑啊，所以感觉不能单独记录，收成一个系列吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>PySpider 安装的坑：PyCurl 出错</title>
    <link href="http://wxnacy.com/2019/05/19/install-pycurl-error/"/>
    <id>http://wxnacy.com/2019/05/19/install-pycurl-error/</id>
    <published>2019-05-19T00:01:36.000Z</published>
    <updated>2019-05-19T00:01:36.181Z</updated>
    
    <content type="html"><![CDATA[<p>问题起源在于安装 PySpider 时需要依赖 PyCurl，过程中报错</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collecting pycurl (from pyspider)</span><br><span class="line">  Using cached https://pypi.tuna.tsinghua.edu.cn/packages/e8/e4/0dbb8735407189f00b33d84122b9be52c790c7c3b25286826f4e1bdb7bde/pycurl-7.43.0.2.tar.gz</span><br><span class="line">    ERROR: Complete output from <span class="built_in">command</span> python setup.py egg_info:</span><br><span class="line">    ERROR: Using curl-config (libcurl 7.54.0)</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">      File <span class="string">"&lt;string&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">      File <span class="string">"/private/var/folders/kz/8syfctw919zdt3shr9w5j8v00000gn/T/pip-install-h_pgkvxp/pycurl/setup.py"</span>, line 913, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">        ext = get_extension(sys.argv, split_extension_source=split_extension_source)</span><br><span class="line">      File <span class="string">"/private/var/folders/kz/8syfctw919zdt3shr9w5j8v00000gn/T/pip-install-h_pgkvxp/pycurl/setup.py"</span>, line 582, <span class="keyword">in</span> get_extension</span><br><span class="line">        ext_config = ExtensionConfiguration(argv)</span><br><span class="line">      File <span class="string">"/private/var/folders/kz/8syfctw919zdt3shr9w5j8v00000gn/T/pip-install-h_pgkvxp/pycurl/setup.py"</span>, line 99, <span class="keyword">in</span> __init__</span><br><span class="line">        self.configure()</span><br><span class="line">      File <span class="string">"/private/var/folders/kz/8syfctw919zdt3shr9w5j8v00000gn/T/pip-install-h_pgkvxp/pycurl/setup.py"</span>, line 316, <span class="keyword">in</span> configure_unix</span><br><span class="line">        specify the SSL backend manually.<span class="string">''</span><span class="string">')</span></span><br><span class="line"><span class="string">    __main__.ConfigurationError: Curl is configured to use SSL, but we have not been able to determine which SSL backend it is using. Please see PycURL documentation for how to specify the SSL backend manually.</span></span><br><span class="line"><span class="string">    ----------------------------------------</span></span><br><span class="line"><span class="string">ERROR: Command "python setup.py egg_info" failed with error code 1 in /private/var/folders/kz/8syfctw919zdt3shr9w5j8v00000gn/T/pip-install-h_pgkvxp/pycurl/</span></span><br></pre></td></tr></table></figure><p>出错内容 <code>Curl is configured to use SSL, but we have not been able to determine which SSL backend it is using. Please see PycURL documentation for how to specify the SSL backend manually.</code></p><p>原因在于正确配置配置 SSL，<a href="http://pycurl.io/docs/latest/install.html#easy-install-pip" target="_blank" rel="noopener">官方文档</a>中给出了方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PYCURL_SSL_LIBRARY=[openssl|gnutls|nss]</span><br></pre></td></tr></table></figure><p>openssl 是比较常用的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PYCURL_SSL_LIBRARY=openssl</span><br></pre></td></tr></table></figure><p>如果你的 <code>.bash_profile</code> 文件中没有配置 <code>LDFLAGS</code> 和 <code>CPPFLAGS</code>，那需要在当前环境中进行激活。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> CFLAGS=<span class="string">"-I<span class="variable">$(brew --prefix openssl)</span>/include"</span></span><br><span class="line">$ <span class="built_in">export</span> LDFLAGS=<span class="string">"-L<span class="variable">$(brew --prefix openssl)</span>/lib"</span></span><br></pre></td></tr></table></figure><p><code>$(brew --prefix openssl)</code> 是为了获取 openssl 的安装目录，这是在使用 HomeBrew 安装的前提下，如果不是的话可以使用 <code>find</code> 命令进行查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo find /usr -iname ssl.h</span><br></pre></td></tr></table></figure><ul><li><a href="https://stackoverflow.com/questions/51019622/curl-is-configured-to-use-ssl-but-we-have-not-been-able-to-determine-which-ssl" target="_blank" rel="noopener">Curl is configured to use SSL, but we have not been able to determine which SSL backend it is using</a></li><li><a href="https://www.jianshu.com/p/61fd0c16aef4" target="_blank" rel="noopener">Mac下安装pycurl填坑记录</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题起源在于安装 PySpider 时需要依赖 PyCurl，过程中报错&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Vim 执行 Shell 命令（3）</title>
    <link href="http://wxnacy.com/2019/05/17/vim-open-terminal/"/>
    <id>http://wxnacy.com/2019/05/17/vim-open-terminal/</id>
    <published>2019-05-17T09:40:56.000Z</published>
    <updated>2019-05-18T02:35:54.696Z</updated>
    
    <content type="html"><![CDATA[<p>上个月写了两篇 Vim 中使用 Shell 的文章，<a href="/2019/04/15/vim-run-shell/">Vim 执行 Shell 命令（1）</a> 和 <a href="/2019/04/18/vim-in-shell/">Vim 执行 Shell 命令（2）</a>，在 <a href="https://github.com/wxnacy/wxnacy.github.io/issues/1" target="_blank" rel="noopener">typebrook</a> 的提醒下发现还有 <code>:terminal</code> 可以实现，并且用了下发现还很好用。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell8.gif" alt="1"></p><p>像预览中展示的这样，<code>:terminal</code> 可以切分出一个 terminal 来运行 shell 命令，这样的方式比前面的介绍的两种方式要更好，它类似 tmux 的多窗口操作，你也可以一边编写代码，一边执行命令。</p><p>打开命令如下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 打开 terminal，水平分屏"</span></span><br><span class="line">:terminal</span><br><span class="line">:term</span><br><span class="line">:ter</span><br><span class="line"></span><br><span class="line"><span class="string">" 打开 terminal，垂直分屏"</span></span><br><span class="line">:<span class="keyword">vertical</span> terminal</span><br><span class="line">:<span class="keyword">vert</span> ter</span><br></pre></td></tr></table></figure><p>关闭 terminal 可以直接输入 <code>exit</code> 然后回车，也可以直接使用 <code>&lt;CTRL-D&gt;</code>，我更喜欢使用后者。</p><p>打开 terminal 后，可以使用 <code>CTRL-W</code> 前缀键来进行窗口操作，正常使用 <code>&lt;CTRL-W&gt;n</code> 打开窗口后，怎么操作，terminal 就可以怎么操作，比如在垂直打开 terminal 后，使用 <code>&lt;CTRL-W&gt;h</code> 和 <code>&lt;CTRL-W&gt;l</code> 可以将光标在两个窗口中切换</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell9.gif" alt="2"></p><p>打开 terminal 后，左下角显示的 <code>TERMINAL</code> 字样，此时我们无法直接对该窗口下的内容进行保存操作，因为它处于 <code>buftype</code> 下，我们可以使用另存为的方式将执行结果保存起来，比如 <code>&lt;CTRL-W&gt;:w newfile</code>，不过这时候有个问题，它会将 shell 环境下所有的显示内容都保存到文件中，包括你的输入命令和一些无关的显示文字。</p><p>这时候我们可以在打开 terminal 时，在命令后面跟上想要使用的 shell 命令，这时会将执行结果保存在缓存文件中并在 terminal 中打开。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">vert</span> ter <span class="keyword">ls</span> -<span class="keyword">l</span></span><br></pre></td></tr></table></figure><p>该窗口仍然是缓存状态，所以不能直接保存，使用 <code>:w newfile</code> 另存为新文件即可，此时窗口左下角显示的是 <code>NORMAL</code>，我们不能再用 <code>&lt;CTRL-D&gt;</code> 关闭窗口了，只能使用 <code>:q</code> 来关闭。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell10.gif" alt="3"></p><p>我介绍的三种方式都各有应用场景，综合来说 <code>:terminal</code> 是我在没有 tmux 情况的首选。</p><p>以上只是很简单的使用，也是比较常用的，它在 Vim 中是个大栏目，很多复杂的编辑器操作都可以通过它来完成，你可以阅读文档 <code>:h terminal</code> 来了解这些</p><p>不管你用了 Vim 多久，你总是会发现更多你不了解的功能，又学到了新东西，开心😊</p><ul><li><a href="https://vimhelp.org/terminal.txt.html#terminal.txt" target="_blank" rel="noopener">terminal.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上个月写了两篇 Vim 中使用 Shell 的文章，&lt;a href=&quot;/2019/04/15/vim-run-shell/&quot;&gt;Vim 执行 Shell 命令（1）&lt;/a&gt; 和 &lt;a href=&quot;/2019/04/18/vim-in-shell/&quot;&gt;Vim 执行 Shell 命令（2）&lt;/a&gt;，在 &lt;a href=&quot;https://github.com/wxnacy/wxnacy.github.io/issues/1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;typebrook&lt;/a&gt; 的提醒下发现还有 &lt;code&gt;:terminal&lt;/code&gt; 可以实现，并且用了下发现还很好用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Python 在 Mac 系统中从剪切板中获取图片</title>
    <link href="http://wxnacy.com/2019/05/13/python-get-image-from-clipboard-on-mac/"/>
    <id>http://wxnacy.com/2019/05/13/python-get-image-from-clipboard-on-mac/</id>
    <published>2019-05-13T07:46:09.000Z</published>
    <updated>2019-05-14T08:48:32.515Z</updated>
    
    <content type="html"><![CDATA[<p>最近想给 <a href="https://github.com/wxnacy/goss" target="_blank" rel="noopener">goss</a> 加点料，就是省去截完图后，保存本地图片的步骤，而是直接从剪切板里获取图片并上传 Github，这样，如何从剪切板中获取图片就成了关键。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#huo-qu-bing-bao-cun-ben-di">获取并保存本地</a></li><li><a href="#huo-qu-bing-xie-ru-dao-liu">获取并写入到流</a></li></ul><!-- tocstop --></div><p>本来想着直接使用 <code>pbcopy</code> 和 <code>pbpaste</code> 命令组合，不过可惜的是它们只能适用于文本。</p><p>此时我们需要借助三方包 <a href="https://pillow.readthedocs.io/en/stable/" target="_blank" rel="noopener">Pillow</a></p><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pillow</span><br></pre></td></tr></table></figure><h2><span id="huo-qu-bing-bao-cun-ben-di">获取并保存本地</span><a href="#huo-qu-bing-bao-cun-ben-di" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = ImageGrab.grabclipboard()</span><br><span class="line"><span class="keyword">if</span> isinstance(img, Image.Image):</span><br><span class="line">    img.save(<span class="string">'test.png'</span>, <span class="string">'png'</span>)</span><br></pre></td></tr></table></figure><p>截图并保存剪切板后，<code>grabclipboard()</code> 方法可以获取剪切板中的图片，为了防止出错，我们还要判断取出的数据是否 <code>Image.Image</code> 图片类型，随后调用 <code>save()</code> 方法保存本地即可。</p><h2><span id="huo-qu-bing-xie-ru-dao-liu">获取并写入到流</span><a href="#huo-qu-bing-xie-ru-dao-liu" class="header-anchor"></a></h2><p>不过我希望的不是保存到本地，而是直接写入到流中，再进行二次操作，此时需要借助 io 包，将图片保存到 io 流中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">img = ImageGrab.grabclipboard()</span><br><span class="line">img_bytes = io.BytesIO()</span><br><span class="line"><span class="keyword">if</span> isinstance(img, Image.Image):</span><br><span class="line">    <span class="comment">#  img.save('test.png', 'png')</span></span><br><span class="line">    img.save(img_bytes, <span class="string">'png'</span>)</span><br><span class="line">    print(img_bytes.getvalue())</span><br></pre></td></tr></table></figure><p>能拿到字节流就可以对其操作，在转换为其它格式，比如 base64，具体方法可以参考 <a href="https://www.devdungeon.com/content/grab-image-clipboard-python-pillow#convert_bytes_to_html_base64_img_tag" target="_blank" rel="noopener">Convert bytes to base64 HTML img tag</a></p><ul><li><a href="https://stackoverflow.com/questions/35254655/how-to-copy-a-image-from-clipboard-in-python?rq=1" target="_blank" rel="noopener">How to copy a image from clipboard in Python?</a></li><li><a href="https://www.devdungeon.com/content/grab-image-clipboard-python-pillow" target="_blank" rel="noopener">Grab Image from Clipboard in Python with Pillow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想给 &lt;a href=&quot;https://github.com/wxnacy/goss&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;goss&lt;/a&gt; 加点料，就是省去截完图后，保存本地图片的步骤，而是直接从剪切板里获取图片并上传 Github，这样，如何从剪切板中获取图片就成了关键。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 memory_profiler 分析程序内存占用情况</title>
    <link href="http://wxnacy.com/2019/05/05/python-memory-profiler/"/>
    <id>http://wxnacy.com/2019/05/05/python-memory-profiler/</id>
    <published>2019-05-05T09:18:09.000Z</published>
    <updated>2019-05-05T11:48:47.296Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中可以使用 memory_profiler 包来分析程序的内存占用情况</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#shi-yong">使用</a></li><li><a href="#can-shu-shi-yong">参数使用</a></li><li><a href="#mprof-ming-ling">mprof 命令</a></li></ul><!-- tocstop --></div><p>memory_profiler 可以分析每行代码的内存使用情况，使用起来非常简单。</p><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install memory_profiler</span><br></pre></td></tr></table></figure><h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    c = []</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * (<span class="number">2</span> ** <span class="number">20</span>)</span><br><span class="line">    b = [<span class="number">1</span>] * (<span class="number">2</span> ** <span class="number">20</span>)</span><br><span class="line">    c.extend(a)</span><br><span class="line">    c.extend(b)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    <span class="keyword">del</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test1()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m memory_profiler memory_profiler</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf1.png" alt="1"></p><p>结果如图，每一步的内存变化情况都很清楚</p><ul><li><code>Mem usage</code> 为当前总内存</li><li><code>Increment</code> 为增加的内存</li></ul><p>总结起来使用非常时间</p><ul><li>方法前加上 <code>@profile</code> 主键</li><li>使用 <code>python -m memory_profiler</code> 来运行，不过直接用 <code>python</code> 运行也可以</li></ul><p>通过上面这段代码我们可以发现，<code>del</code> 语句只是将变量删除，并不能减少内存的消耗。</p><h2><span id="can-shu-shi-yong">参数使用</span><a href="#can-shu-shi-yong" class="header-anchor"></a></h2><ul><li><code>precision</code> 显示小数点后的位数</li></ul><p>默认显示的内存单位为 <code>MiB</code>，小数点后显示一位，如果某行代码占用内存比较小，就可能显示不出来，此时可以通过调整小数点后的位数实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@profile(precision=4)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>] * (<span class="number">2</span> ** <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test3()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf3.png" alt="3"></p><ul><li><code>stream</code> 将结果输出到流中</li></ul><p>每次运行都要打印内存情况，势必会影响程序输出效果，我们可以将结果通过流输出到文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile(precision=4, @profile(precision=4, stream=open('/tmp/memory_profiler.log','w+')))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>] * (<span class="number">2</span> ** <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test3()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf4.png" alt="4"></p><h2><span id="mprof-ming-ling">mprof 命令</span><a href="#mprof-ming-ling" class="header-anchor"></a></h2><p>memory_profiler 本身也提供了命令行 <code>mprof</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Usage: mprof &lt;<span class="built_in">command</span>&gt; &lt;options&gt; &lt;arguments&gt;</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line"></span><br><span class="line">    run      运行给定的命令或 python 文件</span><br><span class="line">    rm       删除 mprof 生成的给定文件</span><br><span class="line">    clean    清除当前目录中 mprof 创建的文件</span><br><span class="line">    list     显示带索引的现有配置文件</span><br><span class="line">    plot     可以将 mprof run 的结果生成图片</span><br><span class="line"></span><br><span class="line">Type mprof &lt;<span class="built_in">command</span>&gt; --<span class="built_in">help</span> <span class="keyword">for</span> usage <span class="built_in">help</span> on a specific <span class="built_in">command</span>.</span><br><span class="line">For example, mprof plot --<span class="built_in">help</span> will list all plotting options.</span><br></pre></td></tr></table></figure><p>重点说一下 <code>plot</code> 命令，<code>run</code> 命令可以生成 <code>.dat</code> 文件，<code>plot</code> 可以将该文件生成图片，不过需要 <code>matplotlib</code> 包的加持。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pip install matplotlib</span><br><span class="line">$ mprof run memory_profiler_demo.py</span><br><span class="line">$ mprof list</span><br><span class="line">0 mprofile_20190505182200.dat 18:22:00 05/05/2019</span><br><span class="line">$ mprof plot mprofile_20190505182200.dat</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pmf5_1260.png" alt="5"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中可以使用 memory_profiler 包来分析程序的内存占用情况&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux time 命令统计脚本耗时</title>
    <link href="http://wxnacy.com/2019/04/29/linux-time/"/>
    <id>http://wxnacy.com/2019/04/29/linux-time/</id>
    <published>2019-04-29T04:10:22.000Z</published>
    <updated>2019-04-29T04:10:22.400Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 中 time 命令可以统计执行脚本的耗时。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>我们以 <a href="https://wxnacy.com/2019/02/01/linux-wc/">wc</a> 命令为例子，统计下计算文件行数时的耗时情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc -l tmd-error.log</span><br><span class="line">655572 tmd-error.log</span><br></pre></td></tr></table></figure><p>只需要在命令前加上 <code>time</code> 即可</p><p><strong>bash环境下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ time wc -l tmd-error.log</span><br><span class="line">  655572 tmd-error.log</span><br><span class="line"></span><br><span class="line">real    0m0.047s</span><br><span class="line">user    0m0.036s</span><br><span class="line">sys     0m0.011s</span><br></pre></td></tr></table></figure><p>得到的结果有三个时间，<code>real</code> 为真实耗时，而 <code>user</code> 和 <code>sys</code> 为用户环境和系统的各自耗时。</p><p><strong>zsh环境下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ time wc -l tmd-error.log</span><br><span class="line">  655572 tmd-error.log</span><br><span class="line">wc -l tmd-error.log  0.04s user 0.01s system 97% cpu 0.047 total</span><br></pre></td></tr></table></figure><p><code>zsh</code> 环境的输出结果不太易读，只需要看最后的 <code>total</code> 值即可</p><p><strong>fish环境下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wxnacy@wxnacydeMacBook-Pro ~/P/t/<span class="built_in">log</span>&gt; time wc -l tmd-error.log</span><br><span class="line">  655572 tmd-error.log</span><br><span class="line">        0.04 real         0.03 user         0.01 sys</span><br></pre></td></tr></table></figure><p>说实话还是 <code>fish</code> 环境的看着最舒服，要不是它不兼容 <code>bash</code> 脚本，我感觉它早就制霸 shell 届了，哼。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Linux 中 time 命令可以统计执行脚本的耗时。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 判断字符串是否为大写及 is 方法延伸</title>
    <link href="http://wxnacy.com/2019/04/28/python-isupper/"/>
    <id>http://wxnacy.com/2019/04/28/python-isupper/</id>
    <published>2019-04-28T13:16:02.000Z</published>
    <updated>2019-04-28T13:16:02.299Z</updated>
    
    <content type="html"><![CDATA[<p>Python 判断字符串是否为大写及延伸</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>以下方法仅判断字符，数字和符号不影响结果</p><p><strong>isupper()</strong> 判断是否都为大写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a!'</span>.isupper()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1A!'</span>.isupper()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>islower()</strong> 判断是否都为小写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1As!'</span>.islower()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1s!'</span>.islower()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>istitle()</strong> 判断所有的单词首字符都是大写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'This Is Upper'</span>.istitle()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'This Is upper1'</span>.istitle()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p><strong>isspace()</strong> 判断所有的字符都是空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'This Is upper1'</span>.isspace()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">' '</span>.isspace()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>isalnum()</strong> 判断所有的字符都是数字或字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a!'</span>.isalnum()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'aa'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'11'</span>.isalnum()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>isalpha()</strong> 判断所有的字符都是字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'11'</span>.isalpha()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a'</span>.isalpha()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'aa'</span>.isalpha()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>isdigit()</strong> 判断所有的字符都是数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'aa'</span>.isdigit()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'11'</span>.isdigit()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1a'</span>.isdigit()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>还有两个类似的方法 <strong>isdecimal()</strong> 和 <strong>isnumeric()</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 判断字符串是否为大写及延伸&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>awk 正则表达式中使用参数</title>
    <link href="http://wxnacy.com/2019/04/26/awk-regex-use-var/"/>
    <id>http://wxnacy.com/2019/04/26/awk-regex-use-var/</id>
    <published>2019-04-26T00:08:55.000Z</published>
    <updated>2019-04-26T00:08:55.487Z</updated>
    
    <content type="html"><![CDATA[<p>awk 使用正则表达式过滤文本时可以使用可变参数，我本认为这应该是很普遍的需求，然而网上找了一圈也没看到一个比较全面的教程，不过东拼西凑也总算是满足了需求，今天来总结下。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#ming-ling-xing-chuan-can">命令行传参</a></li><li><a href="#jiao-ben-zhong-chuan-can">脚本中传参</a></li></ul><!-- tocstop --></div><p>首先将当前文件列表导入到一份文本文件 <a href="https://raw.githubusercontent.com/wxnacy/file/master/common/text" target="_blank" rel="noopener">text</a> 中，作为测试使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ll &gt; text</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/awk1_548.png" alt="1"></p><h2><span id="ming-ling-xing-chuan-can">命令行传参</span><a href="#ming-ling-xing-chuan-can" class="header-anchor"></a></h2><p>首先我们打算过滤文件列表的最后修改时间为 <code>10</code> 点的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'/10/ &#123;print $0&#125;'</span> text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff    1052 Mar 13 22:50 awktest</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     100 Mar 25 22:53 b.py</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     121 Mar 14 10:19 test.go</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     106 Mar 13 10:53 test.js</span><br></pre></td></tr></table></figure><p>这样得到的结果并准确，我们应该精确的对第 8 行进行正则匹配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'$8 ~ /10/ &#123;print $0&#125;'</span> text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     121 Mar 14 10:19 test.go</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     106 Mar 13 10:53 test.js</span><br></pre></td></tr></table></figure><p>现在问题来了，我希望对 <code>10</code> 进行参数化，该怎么做呢？</p><p>awk 命令行模式可以直接使用 shell 参数，不过比较麻烦一点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hour=10</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$hour</span></span><br><span class="line">10</span><br><span class="line">$ awk <span class="string">'$8 ~ /'</span><span class="string">"<span class="variable">$hour</span>"</span><span class="string">'/ &#123;print $0&#125;'</span> text</span><br></pre></td></tr></table></figure><p><code>$hour</code> 还需要使用 <code>&#39;&quot;&quot;&#39;</code> 包裹起来才行</p><p>好在 awk 也有办法传递参数，使用 <code>-v</code> 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v hour=10 <span class="string">'$8 ~ hour &#123;print $0&#125;'</span> text</span><br></pre></td></tr></table></figure><p>如果使用参数的话，正则内容就不用 <code>//</code> 包裹了，直接使用参数即可。</p><p>只是这种情况下，如果我们想增加额外的符号，需要使用字符串包裹起来，比如想要查找时间以 <code>18</code> 为结尾的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v hour=18 <span class="string">'$8 ~ hour"$" &#123;print $0&#125;'</span> text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     861 Apr 17 18:18 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>也可以使用 <code>if</code> 条件语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v hour=18 <span class="string">'&#123; if ($8 ~ hour"$") &#123;print $0&#125; &#125;'</span> text</span><br></pre></td></tr></table></figure><p>很明显，命令行中使用 <code>if</code> 条件语句显得很乱，这主要还是要引出脚本化来。</p><h2><span id="jiao-ben-zhong-chuan-can">脚本中传参</span><a href="#jiao-ben-zhong-chuan-can" class="header-anchor"></a></h2><p>我们先将单引号中的条件脚本化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch split.awk</span><br><span class="line">$ chmod +x split.awk</span><br><span class="line">$ vim split.awk</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env awk -f</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$8</span> ~ hour<span class="string">"$"</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./split.awk -v hour=18 text</span><br><span class="line">-rw-r--r--  1 wxnacy  staff     861 Apr 17 18:18 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这只是一个很简单的例子，真实的开发中，判断条件往往更加复杂的多，所以使用脚本是很明智的办法。</p><p>最后提一句，使用 <code>match()</code> 可以使脚本的可读性更好一些。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env awk -f</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (match(<span class="variable">$8</span> , hour<span class="string">"$"</span>))&#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://stackoverflow.com/questions/11534173/how-to-use-awk-variables-in-regular-expressions" target="_blank" rel="noopener">How to use awk variables in regular expressions?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;awk 使用正则表达式过滤文本时可以使用可变参数，我本认为这应该是很普遍的需求，然而网上找了一圈也没看到一个比较全面的教程，不过东拼西凑也总算是满足了需求，今天来总结下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
      <category term="awk" scheme="http://wxnacy.com/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy 解决其他连接修改数据后，查询不到的问题</title>
    <link href="http://wxnacy.com/2019/04/25/sqlalchemy-isolation-level/"/>
    <id>http://wxnacy.com/2019/04/25/sqlalchemy-isolation-level/</id>
    <published>2019-04-25T01:35:51.000Z</published>
    <updated>2019-04-25T01:35:51.950Z</updated>
    
    <content type="html"><![CDATA[<p>使用 SQLAlchemy 做数据库的读写分离，创建了主从两个 DB，结果发现使用主 DB 写入的数据，从 DB 无法实时查询，必须要重启服务才可以查到。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>做了各种尝试发现都得不到解决，突然想起以前碰见过类似的问题，但是当时通过其他方式绕了过去，果然不是不报，时候未到。这次必须得正面解决了。</p><p>经过 Google 后发现，这是事务的问题，在多个实例进行链接数据库时，如果不执行 <code>commit</code>，就得不到最新的数据。</p><p>我们可以使用 <code>session.commit()</code> 来单个解决，或者可以在创建引擎时通过调整隔离级别参数来永久解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine = create_engine(<span class="string">'db_url'</span>, isolation_level = <span class="string">'READ COMMITTED'</span>)</span><br></pre></td></tr></table></figure><p><code>isolation_level</code> 的值包含了：</p><ul><li>READ COMMITTED</li><li>READ UNCOMMITTED</li><li>REPEATABLE READ</li><li>SERIALIZABLE</li><li>AUTOCOMMIT</li></ul><p>因为我使用只读，所以 <code>READ COMMITTED</code> 就可以满足要求，如果你是读写公用的 DB，直接使用 <code>AUTOCOMMIT</code> 就无脑解决了。</p><p>如果你使用 <code>flask_sqlalchemy</code>，在 <code>app.config</code> 中加入如下参数即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLALCHEMY_COMMIT_ON_TEARDOWN = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>通过源码可以发现，当该参数设置为 <code>True</code> 时，它会自动进行 <code>commit</code> 操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.teardown_appcontext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shutdown_session</span><span class="params">(response_or_exc)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> app.config[<span class="string">'SQLALCHEMY_COMMIT_ON_TEARDOWN'</span>]:</span><br><span class="line">        <span class="keyword">if</span> response_or_exc <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.session.commit()</span><br><span class="line"></span><br><span class="line">    self.session.remove()</span><br><span class="line">    <span class="keyword">return</span> response_or_exc</span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.sqlalchemy.org/en/13/core/engines.html#engine-creation-api" target="_blank" rel="noopener">Engine Creation API</a></li><li><a href="https://docs.sqlalchemy.org/en/13/dialects/mysql.html#transaction-isolation-level" target="_blank" rel="noopener">Mysql Transaction Isolation Level</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 SQLAlchemy 做数据库的读写分离，创建了主从两个 DB，结果发现使用主 DB 写入的数据，从 DB 无法实时查询，必须要重启服务才可以查到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="sqlalchemy" scheme="http://wxnacy.com/tags/sqlalchemy/"/>
    
  </entry>
  
  <entry>
    <title>Python 如何给屏幕打印信息加上颜色</title>
    <link href="http://wxnacy.com/2019/04/24/python-print-color/"/>
    <id>http://wxnacy.com/2019/04/24/python-print-color/</id>
    <published>2019-04-24T05:31:54.000Z</published>
    <updated>2019-04-24T05:31:54.732Z</updated>
    
    <content type="html"><![CDATA[<p>以前写过 <a href="/2018/09/07/go-fmt-color/">Go 如何给屏幕打印信息加上颜色</a>，想当然的以为 Python 也一样，结果被打脸，他们的配置还是有一些区别的。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#yu-fa">语法</a></li><li><a href="#gong-ju-hua">工具化</a></li></ul><!-- tocstop --></div><h2><span id="yu-fa">语法</span><a href="#yu-fa" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'\033[显示方式;字体色;背景色m文本\033[0m'</span>)</span><br><span class="line"><span class="comment"># 三种设置都可以忽略不写，都不写则为默认输出</span></span><br></pre></td></tr></table></figure><p>配置如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字体 背景 颜色</span></span><br><span class="line"><span class="comment"># ---------------------------------------</span></span><br><span class="line"><span class="comment"># 30  40  黑色</span></span><br><span class="line"><span class="comment"># 31  41  红色</span></span><br><span class="line"><span class="comment"># 32  42  绿色</span></span><br><span class="line"><span class="comment"># 33  43  黄色</span></span><br><span class="line"><span class="comment"># 34  44  蓝色</span></span><br><span class="line"><span class="comment"># 35  45  紫红色</span></span><br><span class="line"><span class="comment"># 36  46  青蓝色</span></span><br><span class="line"><span class="comment"># 37  47  白色</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 显示方式</span></span><br><span class="line"><span class="comment"># -------------------------</span></span><br><span class="line"><span class="comment">#  0  终端默认设置</span></span><br><span class="line"><span class="comment">#  1  高亮显示</span></span><br><span class="line"><span class="comment">#  4  使用下划线</span></span><br><span class="line"><span class="comment">#  5  闪烁</span></span><br><span class="line"><span class="comment">#  7  反白显示</span></span><br><span class="line"><span class="comment">#  8  不可见</span></span><br></pre></td></tr></table></figure><p>举几个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高亮显示，字体紫红色，背景白色</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[1;35;47m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor1.png" alt="1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认显示，字体紫红色，背景白色</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[35;47m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor2.png" alt="2"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认显示，字体紫红色，背景默认</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[35m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor3.png" alt="3"></p><p>往往我们更关注字体颜色，几个字体颜色效果如下，我用的 iTerm2 的深色背景，效果会有点偏差</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/output-color.png" alt="4"></p><p>如果你想看所有组合的颜色，可以查看这篇文章 <a href="https://www.cnblogs.com/journeyonmyway/p/4317108.html" target="_blank" rel="noopener">Go语言在Linux环境下输出彩色字符</a></p><h2><span id="gong-ju-hua">工具化</span><a href="#gong-ju-hua" class="header-anchor"></a></h2><p>这个语法看起来还是很别扭的，平常使用我们可以封装起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    BLACK = <span class="number">30</span></span><br><span class="line">    RED = <span class="number">31</span></span><br><span class="line">    GREEN = <span class="number">32</span></span><br><span class="line">    YELLOW = <span class="number">33</span></span><br><span class="line">    BLUE = <span class="number">34</span></span><br><span class="line">    MAGENTA = <span class="number">35</span></span><br><span class="line">    CYAN = <span class="number">36</span></span><br><span class="line">    WHITE = <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_color</span><span class="params">(text: str, fg: Color = Color.BLACK.value)</span>:</span></span><br><span class="line">    print(<span class="string">f'\033[<span class="subst">&#123;fg&#125;</span>m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印红色文字</span></span><br><span class="line">print_color(<span class="string">'Hello World'</span>, fg = Color.RED.value)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前写过 &lt;a href=&quot;/2018/09/07/go-fmt-color/&quot;&gt;Go 如何给屏幕打印信息加上颜色&lt;/a&gt;，想当然的以为 Python 也一样，结果被打脸，他们的配置还是有一些区别的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
</feed>
