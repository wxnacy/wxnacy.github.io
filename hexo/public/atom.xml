<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-08-22T09:40:01.268Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker logs 命令</title>
    <link href="http://wxnacy.com/2019/08/22/docker-logs/"/>
    <id>http://wxnacy.com/2019/08/22/docker-logs/</id>
    <published>2019-08-22T09:40:01.000Z</published>
    <updated>2019-08-22T09:40:01.268Z</updated>
    
    <content type="html"><![CDATA[<p>之前没有留意过 <code>docker logs</code> 的正确用法，总是直接使用 <code>docker logs -f</code> 来实时跟踪日志，但是每次都要全部显示日志后再跟踪，时间一长日志变多就是灾难，看一下帮助文档，学习下正确用法。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Fetch the logs of a container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow <span class="built_in">log</span> output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br><span class="line">      --tail string    Number of lines to show from the end of the logs (default <span class="string">"all"</span>)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br></pre></td></tr></table></figure><p>想要跟 <code>tail -f</code> 命令一样从末尾10条以后开始跟踪，需要使用 <code>--tail</code> 参数，默认就是全部</p><p><strong>从末尾 10 条后开始跟踪</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f --tail 10 &lt;container-id&gt;</span><br></pre></td></tr></table></figure><p>除了行数限制，还可以根据时间戳来获取指定时间前后的是日志</p><p><strong>获取指定时间以后的日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -t --since=<span class="string">"2019-08-20T13:23:37"</span> &lt;container-id&gt;</span><br></pre></td></tr></table></figure><p><strong>获取最后 10 分钟的日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -t --since=10m &lt;container-id&gt;</span><br></pre></td></tr></table></figure><p><strong>获取指定时间范围的日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -t --since=<span class="string">"2019-08-20T13:23:37"</span> --until=<span class="string">"2019-08-21T13:23:37"</span> &lt;container-id&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前没有留意过 &lt;code&gt;docker logs&lt;/code&gt; 的正确用法，总是直接使用 &lt;code&gt;docker logs -f&lt;/code&gt; 来实时跟踪日志，但是每次都要全部显示日志后再跟踪，时间一长日志变多就是灾难，看一下帮助文档，学习下正确用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>pm2 容器使用环境变量</title>
    <link href="http://wxnacy.com/2019/08/21/pm2-env/"/>
    <id>http://wxnacy.com/2019/08/21/pm2-env/</id>
    <published>2019-08-21T01:53:12.000Z</published>
    <updated>2019-08-21T01:53:12.603Z</updated>
    
    <content type="html"><![CDATA[<p>pm2 容器管理进程时，设置环境变量非常简单</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps : [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">"myapp"</span>,</span><br><span class="line">        script: <span class="string">"./app.js"</span>,</span><br><span class="line">        watch: <span class="literal">true</span>,</span><br><span class="line">        env: &#123;</span><br><span class="line">            <span class="string">"PORT"</span>: <span class="number">3000</span>,</span><br><span class="line">            <span class="string">"NODE_ENV"</span>: <span class="string">"development"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        env_production: &#123;</span><br><span class="line">            <span class="string">"PORT"</span>: <span class="number">80</span>,</span><br><span class="line">            <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>env</code> 是 pm2 默认使用的环境变量，使用 <code>env_production</code>  需要运行时指定环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 start ecosystem.config.js --env production</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pm2 容器管理进程时，设置环境变量非常简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://wxnacy.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Python 获取当前文件的模块对象</title>
    <link href="http://wxnacy.com/2019/08/20/python-current-module/"/>
    <id>http://wxnacy.com/2019/08/20/python-current-module/</id>
    <published>2019-08-20T06:26:10.000Z</published>
    <updated>2019-08-20T06:34:54.439Z</updated>
    
    <content type="html"><![CDATA[<p>根据<a href="https://www.python.org/dev/peps/pep-3130/" target="_blank" rel="noopener">官方</a>文档可以得到这样的用法</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">mod = sys.modules[__name__]</span><br></pre></td></tr></table></figure><p>这个特性可以应用在什么场景呢？当模块中的方法有什么共同特性时，我们可以配合 <code>getattr</code> 方法来进行动态调用，而不必编写复杂的判断语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_size</span><span class="params">(size: int)</span>:</span></span><br><span class="line">    <span class="string">'''格式化大小'''</span></span><br><span class="line">    unit = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">'B'</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">'K'</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">'M'</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">'G'</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">'T'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1024</span> ** i &lt;= size &lt; <span class="number">1024</span> ** ( i + <span class="number">1</span> ):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                size = size / <span class="number">1024</span> ** i</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&#123;:0.1f&#125;&#123;&#125;'</span>.format( size, unit[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125;B'</span>.format(size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    module = sys.modules[__name__]</span><br><span class="line">    args = sys.argv[<span class="number">1</span>:]</span><br><span class="line">    func_name = args[<span class="number">0</span>]</span><br><span class="line">    func = getattr(module, func_name)</span><br><span class="line">    res = func(int(args[<span class="number">1</span>]))</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用方法</span></span><br><span class="line">    <span class="comment"># $ python utils.py format_size 1024</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据&lt;a href=&quot;https://www.python.org/dev/peps/pep-3130/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方&lt;/a&gt;文档可以得到这样的用法&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 Pillow 包实现图片叠加</title>
    <link href="http://wxnacy.com/2019/08/15/pillow-overlay/"/>
    <id>http://wxnacy.com/2019/08/15/pillow-overlay/</id>
    <published>2019-08-15T09:39:29.000Z</published>
    <updated>2019-08-15T09:55:25.261Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">Pillow</a> 包实现图片叠加非常简单</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#jian-dan-shi-yong">简单使用</a></li><li><a href="#xiang-mu-zhong-shi-yong">项目中使用</a></li></ul><!-- tocstop --></div><h2><span id="jian-dan-shi-yong">简单使用</span><a href="#jian-dan-shi-yong" class="header-anchor"></a></h2><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install Pillow</span><br></pre></td></tr></table></figure><p><strong>简单实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">big_image =Image.open(<span class="string">'big.jpg'</span>)</span><br><span class="line">small_image=Image.open(<span class="string">'small.jpg'</span>)</span><br><span class="line"><span class="comment"># small_image.thumbnail((400,400))  可以实现压缩</span></span><br><span class="line">big_image.paste(small_image,(<span class="number">157</span>, <span class="number">45</span>))</span><br><span class="line">big_image.show()</span><br></pre></td></tr></table></figure><p><strong>原图</strong></p><p><img src="https://wxnacy.com/images/rss.png" alt="1"><br><img src="https://wxnacy.com/images/mp.jpg" alt="2"></p><p><strong>叠加效果</strong></p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pillow_overlay.png" alt="3"></p><h2><span id="xiang-mu-zhong-shi-yong">项目中使用</span><a href="#xiang-mu-zhong-shi-yong" class="header-anchor"></a></h2><p>在 web 项目中往往我们不会使用本地图片，大多是对网络图片进行处理，再传到线上，所以首先需要能解析网络图片，其次处理后需要拿到图片二进制，再进行上传处理。</p><p>这套逻辑的代码在 <a href="https://github.com/wxnacy/study/blob/master/python/pillow_demo/overlay.py" target="_blank" rel="noopener">https://github.com/wxnacy/study/blob/master/python/pillow_demo/overlay.py</a></p><p>这里复制一份</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 图片叠加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_image</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">'''通过地址获取 image 对象'''</span></span><br><span class="line">    image = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> path.startswith(<span class="string">'http'</span>):</span><br><span class="line">        res = requests.get(path)</span><br><span class="line">        image = Image.open(io.BytesIO(res.content))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        image = Image.open(path)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image2bytes</span><span class="params">(image)</span>:</span></span><br><span class="line">    <span class="string">'''图片转二进制'''</span></span><br><span class="line">    img_bytes = io.BytesIO()</span><br><span class="line">    image.save(img_bytes, image.format)</span><br><span class="line">    <span class="keyword">return</span> img_bytes.getvalue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overlay</span><span class="params">(big_path, small_path, width, height, small_thumbnail=<span class="params">()</span>)</span>:</span></span><br><span class="line">    <span class="string">'''叠加'''</span></span><br><span class="line">    big_image = get_image(big_path)</span><br><span class="line">    small_image = get_image(small_path)</span><br><span class="line">    <span class="keyword">if</span> small_thumbnail:</span><br><span class="line">        small_image.thumbnail(small_thumbnail)</span><br><span class="line">    big_image.paste(small_image,(width, height))</span><br><span class="line">    big_image.show()    <span class="comment"># 显示图片</span></span><br><span class="line">    <span class="comment">#  big_image.save('/Users/wxnacy/Downloads/pillow_overlay.png')  # 保存</span></span><br><span class="line">    <span class="comment"># 或者返回图片的二进制</span></span><br><span class="line">    <span class="keyword">return</span> image2bytes(big_image)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    overlay(<span class="string">'https://wxnacy.com/images/rss.png'</span>,</span><br><span class="line">            <span class="string">'https://wxnacy.com/images/mp.jpg'</span>, <span class="number">157</span>, <span class="number">45</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/python-pillow/Pillow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pillow&lt;/a&gt; 包实现图片叠加非常简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 配置国内仓库</title>
    <link href="http://wxnacy.com/2019/08/12/docker-use-china-mirrors/"/>
    <id>http://wxnacy.com/2019/08/12/docker-use-china-mirrors/</id>
    <published>2019-08-12T13:38:08.000Z</published>
    <updated>2019-08-12T13:38:08.706Z</updated>
    
    <content type="html"><![CDATA[<p>类似这种需要下载包的一般都要配置个国内的仓库源，同时使用默认的国外仓库，真的很慢。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>以阿里云仓库为例，配置方式很简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://4qqg0972.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类似这种需要下载包的一般都要配置个国内的仓库源，同时使用默认的国外仓库，真的很慢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 开始慢查询日志</title>
    <link href="http://wxnacy.com/2019/08/01/mysql-slow-query-log/"/>
    <id>http://wxnacy.com/2019/08/01/mysql-slow-query-log/</id>
    <published>2019-08-01T09:09:32.000Z</published>
    <updated>2019-08-01T09:09:32.556Z</updated>
    
    <content type="html"><![CDATA[<p>项目长期运行过程中，Mysql 慢查询的监控是必不可少的一步日常工作，今天来说下配置过程。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#pei-zhi">配置</a></li><li><a href="#fen-xi-gong-ju">分析工具</a></li></ul><!-- tocstop --></div><h2><span id="pei-zhi">配置</span><a href="#pei-zhi" class="header-anchor"></a></h2><p>先来查看默认慢查询日志开启状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%slow_query_log%&quot;;</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| Variable_name       | Value                                |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                  |</span><br><span class="line">| slow_query_log_file | /var/lib/mysql/1bcb14797cd4-slow.log |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><ul><li><code>slow_query_log</code> 是否开启慢查询日志，默认关闭</li><li><code>slow_query_log_file</code> 慢查询日志的默认位置，系统自动生成的文件名。自定义的日志名最好符合 <code>*-slow.log</code> 格式，后面会讲到原因。</li></ul><p>因为慢查询日志本身比较耗性能，所以默认是关闭的，在需要的时候我们需要手动打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log=1;</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br></pre></td></tr></table></figure><p>该命令可以全局开启该功能，但是如果 Mysql 服务重启则会还原默认值，想要持久化，需要修改配置文件，然后重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 开启慢查询日志</span></span><br><span class="line">slow_query_log=1</span><br><span class="line"><span class="comment"># 设置慢查询日志位置</span></span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow.log</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart mysql</span><br></pre></td></tr></table></figure><p>修改 <code>slow_query_log_file</code> 时需要注意，文件的目录位置必须已存在，否则会报错，慢查询日志功能自动关闭。</p><p>另外还一些其他的参数可以修改，方法跟上面的一样。</p><ul><li><code>long_query_time</code> 慢查询阈值，当查询时间多于设定的阈值时记录日志。默认 10 秒。</li><li><code>log_queries_not_using_indexes</code> 未使用索引的查询也被记录到慢查询日志中（可选项）。</li><li><code>log_output</code> 日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</li></ul><h2><span id="fen-xi-gong-ju">分析工具</span><a href="#fen-xi-gong-ju" class="header-anchor"></a></h2><p>Mysql 提供了慢查询日志的分析工具 mysqldumpslow，这要比自己查看日志文件要方便的多。</p><p>下面是几个常用的参数</p><ul><li><code>-s</code> 是表示按照何种方式排序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c: 访问计数</span><br><span class="line">l: 锁定时间</span><br><span class="line">r: 返回记录</span><br><span class="line">t: 查询时间</span><br><span class="line">al:平均锁定时间</span><br><span class="line">ar:平均返回记录数</span><br><span class="line">at:平均查询时间</span><br></pre></td></tr></table></figure><ul><li><code>-t</code> 是top n的意思，即为返回前面多少条的数据</li><li><code>-g</code> 后边可以写一个正则匹配模式，大小写不敏感的</li></ul><p>更多的参数可以查看帮助文档 <code>mysqldumpslow --help</code></p><p>举个例子，查看记录最多的 10 个 sql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldumpslow -s r -t 10</span><br><span class="line">Can<span class="string">'t find '</span>/var/lib/mysql/*-slow.log<span class="string">'</span></span><br></pre></td></tr></table></figure><p>如果我们自定义了日志文件，并且格式比较随意，那默认会报找不到文件的错误。</p><p>如果你的日志文件已经自定义为其它格式，那也可以通过传入文件名的方式分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldumpslow -s r -t 10 /var/lib/mysql/some-name.log</span><br></pre></td></tr></table></figure><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html" target="_blank" rel="noopener">The Slow Query Log</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldumpslow.html" target="_blank" rel="noopener">mysqldumpslow — Summarize Slow Query Log Files</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目长期运行过程中，Mysql 慢查询的监控是必不可少的一步日常工作，今天来说下配置过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://wxnacy.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Ansible 在 Vagrant 中使用</title>
    <link href="http://wxnacy.com/2019/07/31/ansible-vagrant-host/"/>
    <id>http://wxnacy.com/2019/07/31/ansible-vagrant-host/</id>
    <published>2019-07-31T09:38:41.000Z</published>
    <updated>2019-07-31T09:38:41.202Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible 在 Vagrant 中使用的难点在于获取 ssh 登录需要的配置信息。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>在默认 <code>Vagrantfile</code> 中我们找不到这些信息，此时需要通过 <code>vagrant ssh-config</code> 命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh-config</span><br><span class="line">Host default</span><br><span class="line">  HostName 127.0.0.1</span><br><span class="line">  User vagrant</span><br><span class="line">  Port 2222</span><br><span class="line">  UserKnownHostsFile /dev/null</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  PasswordAuthentication no</span><br><span class="line">  IdentityFile /Users/wxnacy/.vagrant.d/boxes/wxnacy-VAGRANTSLASH-ubuntu1804/0/virtualbox/vagrant_private_key</span><br><span class="line">  IdentitiesOnly yes</span><br><span class="line">  LogLevel FATAL</span><br></pre></td></tr></table></figure><p>啊，让我费解的 <code>IdentityFile</code> 文件终于露出来，关键就是这个文件。</p><p>接下来我们只需要配置 Ansible 的 hosts 文件，<code>/etc/ansible/hosts</code> 中添加，或者创建独立的 <code>hosts</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vagrant]</span><br><span class="line">127.0.0.1 ansible_ssh_user=vagrant ansible_ssh_port=2222 ansible_ssh_private_key_file=/Users/wxnacy/.vagrant.d/boxes/wxnacy-VAGRANTSLASH-ubuntu1804/0/virtualbox/vagrant_private_key</span><br></pre></td></tr></table></figure><p>最后查看是否能正常连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ansible all -m <span class="built_in">command</span> -a <span class="string">'who'</span> --inventory-file=hosts</span><br><span class="line">127.0.0.1 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">vagrant  pts/0        Jul 30 07:35 (10.0.2.2)</span><br><span class="line">vagrant  pts/1        Jul 30 06:19 (10.0.2.2)</span><br></pre></td></tr></table></figure><p>如果新建其他位置的 <code>hosts</code> 文件，需要 <code>--inventory-file, -i</code> 指定文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ansible 在 Vagrant 中使用的难点在于获取 ssh 登录需要的配置信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vagrant" scheme="http://wxnacy.com/tags/vagrant/"/>
    
      <category term="ansible" scheme="http://wxnacy.com/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Python 报错 f-string expression part cannot include a backslash</title>
    <link href="http://wxnacy.com/2019/07/30/python-f-string-error1/"/>
    <id>http://wxnacy.com/2019/07/30/python-f-string-error1/</id>
    <published>2019-07-30T07:02:15.000Z</published>
    <updated>2019-07-30T07:02:15.722Z</updated>
    
    <content type="html"><![CDATA[<p>Python 3.6 版本新增加的 <code>f-string</code> 语句非常简洁，其中可以直接在字符串中使用表达式，可以让代码写起来非常方便。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>不过也要了解它的一些特性，不然就可能会报一个错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f'say <span class="subst">&#123;<span class="string">"\t"</span> * n&#125;</span>'</span></span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span></span><br><span class="line">SyntaxError: f-string expression part cannot include a backslash</span><br></pre></td></tr></table></figure><p>好像也没有用错，确实应该这样写的，错误翻译过来是 <code>f-string</code> 的表达式中不能出现反斜杠。</p><p>那记住这一点，以后写起来注意下就好了，有两个方法解决。</p><p><strong>外部计算</strong></p><p>将表达式挪到外部计算好后在传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tables = <span class="string">"\t"</span> * n</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f'say <span class="subst">&#123;tables&#125;</span>'</span></span><br><span class="line"><span class="string">'say \t\t'</span></span><br></pre></td></tr></table></figure><p><strong>使用 format </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'say &#123;&#125;'</span>.format(<span class="string">'\t'</span> * n)</span><br><span class="line"><span class="string">'say \t\t'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 3.6 版本新增加的 &lt;code&gt;f-string&lt;/code&gt; 语句非常简洁，其中可以直接在字符串中使用表达式，可以让代码写起来非常方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 容器的一些操作</title>
    <link href="http://wxnacy.com/2019/07/27/docker-container-cmd/"/>
    <id>http://wxnacy.com/2019/07/27/docker-container-cmd/</id>
    <published>2019-07-27T13:22:38.000Z</published>
    <updated>2019-07-27T13:22:38.096Z</updated>
    
    <content type="html"><![CDATA[<p>整理自<a href="https://yeasy.gitbooks.io/docker_practice/container/" target="_blank" rel="noopener">操作 Docker 容器</a>，为了方便查看简化整理为一篇。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#qi-dong-rong-qi">启动容器</a></li><li><a href="#jin-ru-rong-qi">进入容器</a></li><li><a href="#dao-chu-he-dao-ru">导出和导入</a></li><li><a href="#ting-zhi-rong-qi">停止容器</a></li><li><a href="#shan-chu">删除</a></li></ul><!-- tocstop --></div><h2><span id="qi-dong-rong-qi">启动容器</span><a href="#qi-dong-rong-qi" class="header-anchor"></a></h2><p><strong>新建并启动</strong></p><p>启动容器并执行命令后，如果命令进程退出，该容器也会立马终止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:bionic <span class="built_in">echo</span> <span class="string">'hello world'</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>在全部容器列表中可以查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">7c4a4cea19aa        ubuntu:bionic       <span class="string">"echo 'hello world'"</span>   3 minutes ago       Exited (0) 7 seconds ago                       elegant_brahmagupta</span><br></pre></td></tr></table></figure><p>使用 <code>-it</code> 参数可以进入交互模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu:bionic /bin/bash</span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># ls</span></span><br><span class="line">bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  etc  lib   media  opt  root  sbin  sys  usr</span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。</p><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p><strong>启动已终止容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>以刚才的交互模式容器为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a                    <span class="comment"># 1</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED              STATUS                          PORTS               NAMES</span><br><span class="line">7c4a4cea19aa        ubuntu:bionic       <span class="string">"echo 'hello world'"</span>   About a minute ago   Exited (0) About a minute ago                       elegant_brahmagupta</span><br><span class="line">82a4d9031d1c        ubuntu:bionic       <span class="string">"/bin/bash"</span>            2 minutes ago        Exited (0) About a minute ago                       tender_jennings</span><br><span class="line"></span><br><span class="line">$ docker container start 82a4d9031d1c       <span class="comment"># 2</span></span><br><span class="line">82a4d9031d1c</span><br><span class="line"></span><br><span class="line">$ docker container ls                       <span class="comment"># 3</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">82a4d9031d1c        ubuntu:bionic       <span class="string">"/bin/bash"</span>            3 minutes ago       Up 7 seconds                                        tender_jennings</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 82a4d9031d1c /bin/bash    <span class="comment"># 4</span></span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># ps                     # 5</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">   25 pts/1    00:00:00 bash</span><br><span class="line">   34 pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure><ul><li><code>1</code> 查看所有转态的容器</li><li><code>2</code> 启动执行 <code>/bin/bash</code> 命令的容器</li><li><code>3</code> 查看当前运行的容器</li><li><code>4</code> 启动容器的交互模式</li><li><code>5</code> 查看容器中的进程</li></ul><p>通过最后一步可以得知，容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p><strong>后台守护运行</strong></p><p>使用 <code>-d</code> 参数即可将容器在后台运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs -f &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>即可实时查看最新日志</p><h2><span id="jin-ru-rong-qi">进入容器</span><a href="#jin-ru-rong-qi" class="header-anchor"></a></h2><p>前面我们试过使用 <code>run</code> 命令配合 <code>-it</code> 参数来进入交互模式，进入容器的交互模式也是类似，不过这里需要 <code>exec</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it ubuntu:bionic /bin/bash</span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>使用完毕，使用 <code>exit</code> 退出即可，容器的运行状态不会影响。</p><p>还有一个命令也可以进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>但是该模式下使用 <code>exit</code> 退出时，容器也会跟着停止，所以并不实用，了解即可。</p><h2><span id="dao-chu-he-dao-ru">导出和导入</span><a href="#dao-chu-he-dao-ru" class="header-anchor"></a></h2><p><strong>导出</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">82a4d9031d1c        ubuntu:bionic       <span class="string">"/bin/bash"</span>            3 minutes ago       Up 7 seconds                                        tender_jennings</span><br><span class="line">$ docker <span class="built_in">export</span> 82a4d9031d1c &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>将容器快照导出到本地</p><p><strong>导入容器镜像</strong></p><p>使用本地文件导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | docker import demo/ubuntu:v1.0</span><br></pre></td></tr></table></figure><p>使用网络地址导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz demo/ubuntu:v1.0</span><br></pre></td></tr></table></figure><p>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h2><span id="ting-zhi-rong-qi">停止容器</span><a href="#ting-zhi-rong-qi" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop &lt;id|name&gt;       <span class="comment"># 停止容器</span></span><br><span class="line">$ docker container start &lt;id|name&gt;      <span class="comment"># 启动容器</span></span><br><span class="line">$ docker container restart &lt;id|name&gt;    <span class="comment"># 重启容器</span></span><br></pre></td></tr></table></figure><h2><span id="shan-chu">删除</span><a href="#shan-chu" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭已经停止的容器</span></span><br><span class="line">$ docker container rm &lt;id:name&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</span></span><br><span class="line">$ docker container rm -f &lt;id:name&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭全部终止状态的容器</span></span><br><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理自&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/container/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;操作 Docker 容器&lt;/a&gt;，为了方便查看简化整理为一篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 改变镜像下载目录</title>
    <link href="http://wxnacy.com/2019/07/26/docker-change-store-dir/"/>
    <id>http://wxnacy.com/2019/07/26/docker-change-store-dir/</id>
    <published>2019-07-26T07:16:22.000Z</published>
    <updated>2019-07-26T07:16:22.830Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 占用储存空间很大的部分在于下载的镜像，因为 Docker 包括容器、镜像等存储数据都默认保存在 <code>/var/lib/docker</code> 目录下，如果系统磁盘空间比较小的话就会很麻烦，我想将目录改为挂载的扩充磁盘上。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>先停止 Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br></pre></td></tr></table></figure><p>确认没有 Docker 进程在跑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps faux | grep docker</span><br></pre></td></tr></table></figure><p>假设新的目录为 <code>/data/docker</code>，先将数据复制到新的目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp -r /var/lib/docker /data/docker</span><br></pre></td></tr></table></figure><p>然后将该目录软连接到 <code>/var/lib/docker</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -sf /data/docker /var/lib/docker</span><br></pre></td></tr></table></figure><p>启动 Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>最后查看镜像列表是否正常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker image ls</span><br></pre></td></tr></table></figure><p>这样软连接的方式是比较灵活的，不会改变我们熟知的存储目录。官方论坛中也有修改配置文件来全局修改存储位置的方法，感兴趣的同学可以点击下方链接进入。</p><ul><li><a href="https://forums.docker.com/t/how-do-i-change-the-docker-image-installation-directory/1169/1" target="_blank" rel="noopener">How do I change the Docker image installation directory?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 占用储存空间很大的部分在于下载的镜像，因为 Docker 包括容器、镜像等存储数据都默认保存在 &lt;code&gt;/var/lib/docker&lt;/code&gt; 目录下，如果系统磁盘空间比较小的话就会很麻烦，我想将目录改为挂载的扩充磁盘上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 报错 Please provide a source image with `from` prior to commit</title>
    <link href="http://wxnacy.com/2019/07/22/docker-before-from-use-args/"/>
    <id>http://wxnacy.com/2019/07/22/docker-before-from-use-args/</id>
    <published>2019-07-22T01:38:03.000Z</published>
    <updated>2019-07-22T01:38:03.405Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 openresty 的 <a href="https://hub.docker.com/r/openresty/openresty/" target="_blank" rel="noopener">docker</a> 版本时，需要重构镜像，本地测试通过，但服务器上报错。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please provide a <span class="built_in">source</span> image with `from` prior to commit</span><br></pre></td></tr></table></figure><p>Google 后发现问题出在这里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG RESTY_IMAGE_BASE=<span class="string">"ubuntu"</span></span><br><span class="line">ARG RESTY_IMAGE_TAG=<span class="string">"bionic"</span></span><br><span class="line"></span><br><span class="line">FROM <span class="variable">$&#123;RESTY_IMAGE_BASE&#125;</span>:<span class="variable">$&#123;RESTY_IMAGE_TAG&#125;</span></span><br></pre></td></tr></table></figure><p>在老版本中是不支持 <code>FROM</code> 前使用 <code>ARG</code> 的，这个问题在 <a href="https://github.com/moby/moby/pull/31352" target="_blank" rel="noopener">docker 17.05.0-ce</a> 版本中得到了修改，而服务器上的版本比较老，所以才报错，只要升级版本即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 openresty 的 &lt;a href=&quot;https://hub.docker.com/r/openresty/openresty/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;docker&lt;/a&gt; 版本时，需要重构镜像，本地测试通过，但服务器上报错。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant 使用 root 账号登录</title>
    <link href="http://wxnacy.com/2019/07/18/vagrant-root-login/"/>
    <id>http://wxnacy.com/2019/07/18/vagrant-root-login/</id>
    <published>2019-07-18T09:42:57.000Z</published>
    <updated>2019-07-18T09:42:57.127Z</updated>
    
    <content type="html"><![CDATA[<p>Vagrant 想要使用 root 身份登录要稍微麻烦一点。网上的文章大多是从一个地方抄过来的，并且还没抄对，所以我在这里总结一篇正确做法。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#xiu-gai-sshd-pei-zhi">修改 sshd 配置</a></li><li><a href="#xiu-gai-vagrantfile">修改 Vagrantfile</a></li><li><a href="#shi-yong-gong-si-yao-deng-lu">使用公私钥登录</a></li></ul><!-- tocstop --></div><h2><span id="xiu-gai-sshd-pei-zhi">修改 sshd 配置</span><a href="#xiu-gai-sshd-pei-zhi" class="header-anchor"></a></h2><p>首先以默认身份登录，并修改 <code>sshd</code> 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh</span><br><span class="line">$ sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>做如下变动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PermitRootLogin prohibit-password</span></span><br><span class="line">PermitRootLogin yes             <span class="comment"># 允许 root 身份登录</span></span><br><span class="line"><span class="comment"># PasswordAuthentication on</span></span><br><span class="line">PasswordAuthentication yes      <span class="comment"># 可以使用密码登录</span></span><br></pre></td></tr></table></figure><p>重启 <code>sshd</code> 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><h2><span id="xiu-gai-vagrantfile">修改 Vagrantfile</span><a href="#xiu-gai-vagrantfile" class="header-anchor"></a></h2><p>增加如下配置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.ssh.username = <span class="string">'root'</span></span><br><span class="line">config.ssh.password = <span class="string">'root'</span></span><br><span class="line">config.ssh.insert_key = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>然后再次登录即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh</span><br></pre></td></tr></table></figure><p>这里注意，网上大部分给出的例子是设置 <code>config.ssh.insert_key = true</code>，如果你这样设置了，会发现 <code>config.ssh.password</code> 将会失效，每次登录都需要手动输入密码。</p><p>为什么呢？根据<a href="https://www.vagrantup.com/docs/vagrantfile/ssh_settings.html#config-ssh-insert_key" target="_blank" rel="noopener">官网</a>的定义，<code>config.ssh.insert_key</code> 代表了是否使用公私钥来登录虚拟机，如果你想要使用不那么安全的登录方式，比如密码登录，则可以将它设置为 <code>false</code>，它的默认值为 <code>true</code></p><p>了解了这一点，就可以发现手动设置 <code>config.ssh.insert_key=true</code> 是有点蠢的做法。</p><h2><span id="shi-yong-gong-si-yao-deng-lu">使用公私钥登录</span><a href="#shi-yong-gong-si-yao-deng-lu" class="header-anchor"></a></h2><p>使用密码登录的缺点很明显，明文的密码就像只穿一个裤衩就出门一样让人不安，默认的 <code>vagrant</code> 就不需要密码，那它是怎么登录的呢？</p><p>关于怎么使用公私钥登录服务器可以查看这篇文章 <a href="/2017/08/23/linux-2017-08-23-ssh/">Linux SSH 登陆远程服务器和无密码操作</a></p><p>有了这篇文章作为基础，我们来查看下 <code>vagrant</code> 账号是否做了秘钥登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /home/vagrant/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>执行这条命令后会发现文件中包含一条记录，证明了确实使用了秘钥登录。</p><p>下面我们为 <code>root</code> 用户赋予秘钥登录的功能</p><p>首先将电脑的公钥内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>复制到虚拟机中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'公钥内容'</span> &gt;&gt; /home/vagrant/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后修改 <code>Vagrantfile</code> 配置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config.ssh.username = <span class="string">'root'</span>                                <span class="comment"># 使用 root 身份登录</span></span><br><span class="line">config.ssh.private_key_path = <span class="string">'/Users/wxnacy/.ssh/id_rsa'</span>   <span class="comment"># 私钥位置</span></span><br></pre></td></tr></table></figure><p>接下来在登录会发现如 <code>vagrant</code> 账号般顺滑</p><ul><li><a href="https://www.vagrantup.com/docs/vagrantfile/ssh_settings.html#config-ssh-private_key_path" target="_blank" rel="noopener">SSH Settings</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vagrant 想要使用 root 身份登录要稍微麻烦一点。网上的文章大多是从一个地方抄过来的，并且还没抄对，所以我在这里总结一篇正确做法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vagrant" scheme="http://wxnacy.com/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 Requests 模块进行身份验证</title>
    <link href="http://wxnacy.com/2019/07/17/requests-auth/"/>
    <id>http://wxnacy.com/2019/07/17/requests-auth/</id>
    <published>2019-07-17T02:46:27.000Z</published>
    <updated>2019-07-17T02:46:27.152Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">Requests</a> 可以说是 Python 最好用的 http 模块，没有之一。</p><a id="more"></a><p>它对于身份验证有非常方便的使用规则。</p><p><strong>基本身份验证</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'https://api.github.com/user'</span>, auth=HTTPBasicAuth(<span class="string">'user'</span>, <span class="string">'pass'</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p>因为这种验证非常常用，所以也提供了方便的写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'https://api.github.com/user'</span>, auth=(<span class="string">'user'</span>, <span class="string">'pass'</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p><strong>摘要式身份认证</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPDigestAuth</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/digest-auth/auth/user/pass'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(url, auth=HTTPDigestAuth(<span class="string">'user'</span>, <span class="string">'pass'</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p><strong>OAuth 1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> requests_oauthlib <span class="keyword">import</span> OAuth1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.twitter.com/1.1/account/verify_credentials.json'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>auth = OAuth1(<span class="string">'YOUR_APP_KEY'</span>, <span class="string">'YOUR_APP_SECRET'</span>,</span><br><span class="line"><span class="meta">... </span>              <span class="string">'USER_OAUTH_TOKEN'</span>, <span class="string">'USER_OAUTH_TOKEN_SECRET'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(url, auth=auth)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p>更多复杂验证如 OAuth 2，请参看<a href="http://docs.python-requests.org/zh_CN/latest/user/authentication.html?highlight=requests.auth#oauth-2-openid" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/kennethreitz/requests&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Requests&lt;/a&gt; 可以说是 Python 最好用的 http 模块，没有之一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 报错 no resolver defined to resolve</title>
    <link href="http://wxnacy.com/2019/07/16/nginx-no-resolver-defined-to-resolve/"/>
    <id>http://wxnacy.com/2019/07/16/nginx-no-resolver-defined-to-resolve/</id>
    <published>2019-07-16T06:49:25.000Z</published>
    <updated>2019-07-16T06:49:25.476Z</updated>
    
    <content type="html"><![CDATA[<p>起因是使用 <code>ngxin + lua</code> 链接外部机器 Redis 时产生的</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>原因是 Nginx 0.6.18以后的版本中启用了一个resolver指令，在使用变量来构造某个server地址的时候一定要用resolver指令来指定DNS服务器的地址，所以解决这个问题的方法很简单：在nginx的配置文件中的http{}部分添加一行DNS地址即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果机器支持 ipv6，可以去掉对它的支持，免得产生类似错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8 ipv6=off;</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-resty-redis/issues/159" target="_blank" rel="noopener">No resolver defined to resolve</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起因是使用 &lt;code&gt;ngxin + lua&lt;/code&gt; 链接外部机器 Redis 时产生的&lt;/p&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://wxnacy.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Python 对 JSON 中的特殊类型进行 Encoder</title>
    <link href="http://wxnacy.com/2019/07/13/python-json-encoder-decoder/"/>
    <id>http://wxnacy.com/2019/07/13/python-json-encoder-decoder/</id>
    <published>2019-07-13T01:56:59.000Z</published>
    <updated>2019-07-13T02:04:21.229Z</updated>
    
    <content type="html"><![CDATA[<p>Python 处理 JSON 数据时，<code>dumps</code> 函数是经常用到的，当 JSON 数据中有特殊类型时，往往是比较头疼的，因为经常会报这样一个错误。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#zi-ding-yi-bian-ma-lei">自定义编码类</a></li><li><a href="#dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang">单分派装饰器处理对象</a></li></ul><!-- tocstop --></div><h2><span id="zi-ding-yi-bian-ma-lei">自定义编码类</span><a href="#zi-ding-yi-bian-ma-lei" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">USER_DATA = dict(</span><br><span class="line">    id = <span class="number">1</span>, name = <span class="string">'wxnacy'</span>, ts = datetime.now()</span><br><span class="line">)</span><br><span class="line">print(json.dumps(USER_DATA))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/wxnacy/PycharmProjects/study/python/office_module/json_demo/dumps.py"</span>, line 74, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dumps_encoder()</span><br><span class="line">  File <span class="string">"/Users/wxnacy/PycharmProjects/study/python/office_module/json_demo/dumps.py"</span>, line 68, <span class="keyword">in</span> dumps_encoder</span><br><span class="line">    <span class="built_in">print</span>(json.dumps(USER_DATA))</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/__init__.py"</span>, line 231, <span class="keyword">in</span> dumps</span><br><span class="line">    <span class="built_in">return</span> _default_encoder.encode(obj)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 199, <span class="keyword">in</span> encode</span><br><span class="line">    chunks = self.iterencode(o, _one_shot=True)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 257, <span class="keyword">in</span> iterencode</span><br><span class="line">    <span class="built_in">return</span> _iterencode(o, 0)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 180, <span class="keyword">in</span> default</span><br><span class="line">    o.__class__.__name__)</span><br><span class="line">TypeError: Object of <span class="built_in">type</span> <span class="string">'datetime'</span> is not JSON serializable</span><br></pre></td></tr></table></figure><p>原因在于 <code>dumps</code> 函数不知道如何处理 <code>datetime</code> 对象，默认情况下 <code>json</code> 模块使用 <code>json.JSONEncoder</code> 类来进行编码，此时我们需要自定义一下编码类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(x, datetime):</span><br><span class="line">            <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line">        <span class="keyword">return</span> super().default(self, x)</span><br></pre></td></tr></table></figure><p>定义编码类 <code>CustomEncoder</code> 并重写实例的 <code>default</code> 函数，对特殊类型进行处理，其余类型继续使用父类的解析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(x, datetime):</span><br><span class="line">            <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line">        <span class="keyword">return</span> super().default(self, x)</span><br><span class="line"></span><br><span class="line">USER_DATA = dict(</span><br><span class="line">    id = <span class="number">1</span>, name = <span class="string">'wxnacy'</span>, ts = datetime.now()</span><br><span class="line">)</span><br><span class="line">print(json.dumps(USER_DATA, cls=CustomEncoder))</span><br><span class="line"><span class="comment"># &#123;"id": 1, "name": "wxnacy", "ts": 1562938926&#125;</span></span><br></pre></td></tr></table></figure><p>最后整合起来，将类使用 <code>cls</code> 参数传入 <code>dumps</code> 函数即可。</p><p>使用 <code>CustomEncoder</code> 实例的 <code>encode</code> 函数可以对对象进行转码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line">print(CustomEncoder().encode(datetime.now()))</span><br><span class="line"><span class="comment"># 1562939035</span></span><br></pre></td></tr></table></figure><p>在父类源码中，所有的编码逻辑都在 <code>encode</code> 函数中，<code>default</code> 只负责抛出 <code>TypeError</code> 异常，这就是文章开始报错的出处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, o)</span>:</span></span><br><span class="line">    <span class="string">"""Implement this method in a subclass such that it returns</span></span><br><span class="line"><span class="string">    a serializable object for ``o``, or calls the base implementation</span></span><br><span class="line"><span class="string">    (to raise a ``TypeError``).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For example, to support arbitrary iterators, you could</span></span><br><span class="line"><span class="string">    implement default like this::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        def default(self, o):</span></span><br><span class="line"><span class="string">            try:</span></span><br><span class="line"><span class="string">                iterable = iter(o)</span></span><br><span class="line"><span class="string">            except TypeError:</span></span><br><span class="line"><span class="string">                pass</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                return list(iterable)</span></span><br><span class="line"><span class="string">            # Let the base class default method raise the TypeError</span></span><br><span class="line"><span class="string">            return JSONEncoder.default(self, o)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">f'Object of type <span class="subst">&#123;o.__class__.__name__&#125;</span> '</span></span><br><span class="line">                    <span class="string">f'is not JSON serializable'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self, o)</span>:</span></span><br><span class="line">    <span class="string">"""Return a JSON string representation of a Python data structure.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from json.encoder import JSONEncoder</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; JSONEncoder().encode(&#123;"foo": ["bar", "baz"]&#125;)</span></span><br><span class="line"><span class="string">    '&#123;"foo": ["bar", "baz"]&#125;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># This is for extremely simple cases and benchmarks.</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(o, str):</span><br><span class="line">        <span class="keyword">if</span> self.ensure_ascii:</span><br><span class="line">            <span class="keyword">return</span> encode_basestring_ascii(o)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> encode_basestring(o)</span><br><span class="line">    <span class="comment"># This doesn't pass the iterator directly to ''.join() because the</span></span><br><span class="line">    <span class="comment"># exceptions aren't as detailed.  The list call should be roughly</span></span><br><span class="line">    <span class="comment"># equivalent to the PySequence_Fast that ''.join() would do.</span></span><br><span class="line">    chunks = self.iterencode(o, _one_shot=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(chunks, (list, tuple)):</span><br><span class="line">        chunks = list(chunks)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(chunks)</span><br></pre></td></tr></table></figure><h2><span id="dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang">单分派装饰器处理对象</span><a href="#dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang" class="header-anchor"></a></h2><p><code>CustomEncoder</code> 如果处理的对象种类很多的话，需要写多个 <code>if elif else</code> 来区分，这样并不是不行，但是不够优雅，不够 pythonic</p><p>根据对象的类型不同，而做出不同的处理。刚好有个装饰器可以做到这点，它就是单分派函数 <code>functools.singledispatch</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> encode(x)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> super().default(self, x)</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch             # 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">'Unencode type'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@encode.register(datetime)  # 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line"></span><br><span class="line"><span class="meta">@encode.register(date)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x.isoformat()</span><br><span class="line"></span><br><span class="line">print(json.dumps(dict(dt = datetime.now(), d = date.today()), cls=CustomEncoder))</span><br><span class="line"><span class="comment"># &#123;"dt": 1562940781, "d": "2019-07-12"&#125;</span></span><br></pre></td></tr></table></figure><ul><li>1 使用 <code>@singledispatch</code> 装饰 <code>encode</code> 函数，是他处理默认类型。同时给他添加一个装饰器构造函数变量。</li><li>2 <a href="mailto:`@encode.register" target="_blank" rel="noopener">`@encode.register</a>()` 是一个装饰器构造函数，接收需要处理的对象类型作为参数。用它装饰的函数不需要名字，<em>_</em> 代替即可。</li></ul><p>最后提一点，<code>json</code> 也可以在命令行中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'&#123;"json": "obj"&#125;'</span> | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"json"</span>: <span class="string">"obj"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">json</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 处理 JSON 数据时，&lt;code&gt;dumps&lt;/code&gt; 函数是经常用到的，当 JSON 数据中有特殊类型时，往往是比较头疼的，因为经常会报这样一个错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 如何安装 Redis</title>
    <link href="http://wxnacy.com/2019/07/12/centos7-install-redis/"/>
    <id>http://wxnacy.com/2019/07/12/centos7-install-redis/</id>
    <published>2019-07-12T09:02:08.000Z</published>
    <updated>2019-07-12T09:06:01.078Z</updated>
    
    <content type="html"><![CDATA[<p>Centos 默认仓库不包含 Redis 安装包，我们可以从 Remi 仓库中来安装。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p><strong>安装 Remi 仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install epel-release yum-utils</span><br><span class="line">$ sudo yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm</span><br><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> remi</span><br></pre></td></tr></table></figure><p><strong>安装 Redis</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y redis</span><br></pre></td></tr></table></figure><p><strong>启动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start redis    <span class="comment"># 启动</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> redis   <span class="comment"># 开机自启</span></span><br></pre></td></tr></table></figure><p><strong>测试是否安装成功</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><ul><li><a href="https://linuxize.com/post/how-to-install-and-configure-redis-on-centos-7/" target="_blank" rel="noopener">How To Install and Configure Redis on CentOS 7</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Centos 默认仓库不包含 Redis 安装包，我们可以从 Remi 仓库中来安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>apt 下载报错 [Could not get lock /var/lib/dpkg/lock-frontend]</title>
    <link href="http://wxnacy.com/2019/07/11/apt-install-error/"/>
    <id>http://wxnacy.com/2019/07/11/apt-install-error/</id>
    <published>2019-07-11T13:15:29.000Z</published>
    <updated>2019-07-11T13:35:24.193Z</updated>
    
    <content type="html"><![CDATA[<p>有两种情况会导致软件安装工具报这种错</p><ul><li><code>Synaptic Package Manager</code> 或 <code>Software Updater</code> 是打开的。</li><li>一些apt命令在终端中运行或者在后台有进程正在运行。</li></ul><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y redis</span><br><span class="line">E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)</span><br><span class="line">E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?</span><br></pre></td></tr></table></figure><p><strong>查看进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep apt</span><br><span class="line">root 1747 0.0 0.0 4628 808 ? Ss 07:06 0:00 /bin/sh /usr/lib/apt/apt.systemd.daily update</span><br><span class="line">root 1769 0.0 0.0 4628 1820 ? S 07:06 0:00 /bin/sh /usr/lib/apt/apt.systemd.daily lock_is_held update</span><br><span class="line">_apt 16225 3.0 0.2 80192 8796 ? S 07:07 0:04 /usr/lib/apt/methods/http</span><br><span class="line">_apt 16226 0.7 0.2 80188 8800 ? S 07:07 0:01 /usr/lib/apt/methods/http</span><br></pre></td></tr></table></figure><p><strong>停掉进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo killall apt apt-get</span><br></pre></td></tr></table></figure><p>这是比较快捷的方式，但是还不够，前两条都无法关闭，只能将 pid 杀死</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">kill</span> -9 &lt;pid&gt;</span><br></pre></td></tr></table></figure><p><strong>删除加锁文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /var/lib/apt/lists/lock</span><br><span class="line">$ sudo rm /var/cache/apt/archives/lock</span><br><span class="line">$ sudo rm /var/lib/dpkg/lock*</span><br></pre></td></tr></table></figure><p><strong>重新配置 dpkg</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg --configure -a</span><br><span class="line">dpkg: error: parsing file <span class="string">'/var/lib/dpkg/updates/0004'</span> near line 0:</span><br><span class="line">newline <span class="keyword">in</span> field name <span class="string">'#padding'</span></span><br></pre></td></tr></table></figure><p>这时候有可能还会出现一个错误，这时要手动删除该文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/dpkg/updates/0004</span><br></pre></td></tr></table></figure><p>再次执行配置命令，然后继续安装软件即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update -y</span><br><span class="line">$ sudo apt install -y redis</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两种情况会导致软件安装工具报这种错&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Synaptic Package Manager&lt;/code&gt; 或 &lt;code&gt;Software Updater&lt;/code&gt; 是打开的。&lt;/li&gt;
&lt;li&gt;一些apt命令在终端中运行或者在后台有进程正在运行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 内存管理之 `*` 运算的陷阱</title>
    <link href="http://wxnacy.com/2019/07/10/python-memory-mul/"/>
    <id>http://wxnacy.com/2019/07/10/python-memory-mul/</id>
    <published>2019-07-10T13:05:49.000Z</published>
    <updated>2019-07-10T13:06:47.677Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中实现了 <code>__mul__</code> 魔法函数的对象，都支持 <code>*</code> 号运算。内置类型更是默认实现了该函数，使用起来也很方便。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>但是对列表对象进行 <code>*</code> 运算时，却不得不注意一个陷阱。</p><p>刚接触这个特性时，美滋滋的以为可以快速的扩展列表，比如这样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>看起来没什么问题，然而实际开发中没这么简单的例子，随便复杂一点，就会出现问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [[]] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[], [], []]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>很显然出现了问题，我只是给索引位置 <code>0</code> 的元素增加了一个子元素，然后所有的元素都改变了。</p><p>出现这个问题的原因是 <code>*</code> 运算复制的不是子元素，而是当前子元素所指对象的引用，所以当改变该对象时，所有引用该对象的元素都会发生改变。</p><p>关于对象引用可以看 <a href="/2019/06/16/python-memory-management">Python 内存管理</a>，里面有更详细的讲解。</p><p>再看一个现象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>] = [<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">2</span>], [<span class="number">1</span>], [<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>这次就想开始那个简单例子一样，结果跟我们预期的一样，这次是为什么呢？</p><p>因为我们没有改变该索引位置的对象，而是让他引向了新的对象 <code>[2]</code>，这样就不影响其他索引位置的对象了。</p><p>那么怎么才能做到扩展列表呢？答案是列表解析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[[], [], []]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[[<span class="number">1</span>], [], []]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中实现了 &lt;code&gt;__mul__&lt;/code&gt; 魔法函数的对象，都支持 &lt;code&gt;*&lt;/code&gt; 号运算。内置类型更是默认实现了该函数，使用起来也很方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 命令行参数模块 argparse</title>
    <link href="http://wxnacy.com/2019/07/08/python-argparse/"/>
    <id>http://wxnacy.com/2019/07/08/python-argparse/</id>
    <published>2019-07-08T13:32:29.000Z</published>
    <updated>2019-07-10T14:19:15.386Z</updated>
    
    <content type="html"><![CDATA[<p>Python 有很多处理命令行参数的外部模块，<a href="https://github.com/pallets/click" target="_blank" rel="noopener">click</a> 是其中的佼佼者，如果你是要完成一个稍微复杂点的项目，我也推荐使用它。但是如果编写一个独立的脚本，我认为方便简洁才是最重要的，也就是能用内置模块就用内置模块。此时了解相应功能的实现方式就尤为重要，何况 <a href="https://docs.python.org/3/howto/argparse.html" target="_blank" rel="noopener">argparse</a> 也真的没有想象中的那么难用。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#chu-shi-hua">初始化</a></li><li><a href="#jie-xi-can-shu">解析参数</a></li><li><a href="#shi-ji-ming-ling-de-li-zi">实际命令的例子</a></li></ul><!-- tocstop --></div><p>直接进入正题，基础用法如下</p><h2><span id="chu-shi-hua">初始化</span><a href="#chu-shi-hua" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># filename: demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'This is a argparse demo'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python demo.py -h</span><br><span class="line">usage: demo.py [-h]</span><br><span class="line"></span><br><span class="line">This is a argparse demo</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>三行代码即可初始化一个命令行参数模块，默认有一个 <code>-h, --help</code> 参数显示帮助信息。</p><p><code>ArgumentParser</code> 函数有如下参数:</p><ul><li><code>prog</code> 程序的名字，默认是argv[0]。若设置，则在帮助信息中，可以使用%(prog)s来作为格式化的引用（修改一处全局受用）。</li><li><code>usage</code> 帮助信息的usage字段，描述程序的各种用法，默认情况下会依据add_argument()来自动生成。</li><li><code>description</code> 一个简单描述程序主要干啥以及怎么用的字符段，默认为空。</li><li><code>epilog</code> optional arguments字符段之后的字符段，默认为空。</li><li><code>parents</code> 继承的父parser，为了避免一些公共的内容重复定义，父parser在初始化时会设置add_help=False，这是为了防止出现父与子parser的-h冲突而抛出异常。</li><li><code>formatter_class</code> 对于help输出进行格式化，除了输出的样式外，如果设置为ArgumentDefaultsHelpFormatter，则会自动在help输出中添加已定义的default值。</li><li><code>prefix_chars</code> options前的字符，默认为’-‘，可以添加其他字符，如’-+’，但是如果没有包括’-‘，那么对应的option如’-h’就无法解析。</li><li><code>fromfile_prefix_chars</code> 有时会使用文件给parse_args()传入参数，为了能够识别文件字符串，如”demo.txt”，需要设置此值，如”@”，那么所有以此字符为开头的字符串都被当作是文件，所以传给parse_args()的参数应该是@demo.txt。在该文件中，一行只能有一个参数。如文件中的’-f\nbar’会被解析成[‘-f’,’bar’]。</li><li><code>argument_default</code> 一般情况下，默认值使用add_argument()来添加，或者使用set_defaults()设置一些键值对来添加。剩下一种情况就是设置此项（此处没看明白是咋回事）。</li><li><code>conflict_handler</code> 解决在add_argument()阶段有冲突的option的依据策略，默认为error即抛出异常。一般情况下遇到冲突是抛出异常即可，但是如果设置了parents，那么需要重写父parser中的规则的时候，就需要将此项设置为resolve，但是重写是精确匹配的，如老规则定义了-h/–help，重写了-h，那么–help还是老规则。</li><li><code>add_help</code> 是否添加-h/–helpoption，默认为True。为False时，是要做parent（其实可以设置子Parser重写）。默认是-h/–help，若prefix_chars中没有包含’-‘，那么就以其中第一个字符作为代替。</li></ul><h2><span id="jie-xi-can-shu">解析参数</span><a href="#jie-xi-can-shu" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># filename: demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'This is a argparse demo'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'file'</span>, help=<span class="string">'List file or dir'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-u'</span>, <span class="string">'--user'</span>, help=<span class="string">'Config user name'</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.file)</span><br><span class="line">print(args.user)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python demo.py bashrc -u wxnacy</span><br><span class="line">bashrc</span><br><span class="line">wxnacy</span><br></pre></td></tr></table></figure><p><code>add_argument</code> 函数有如下参数：</p><ul><li><p><code>name or flags</code> 是位置参数，则需要传入名字；要是可选参数，则需要进行定义，如’-f’，’–foo’。</p></li><li><p><code>action</code> 定义传入的参数如何处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">action=&apos;store&apos;，默认取值，保存传入参数。</span><br><span class="line">action=&apos;store_const&apos;，需要添加const，意味着该argument的值不从命令行输入，而是取const的值。</span><br><span class="line">action=&apos;store_true&apos; or action=&apos;store_false&apos;，&apos;store_const&apos;的特殊情形，意味着const的值为True或False。</span><br><span class="line">action=&apos;append&apos;，表示传入的值会作为一个列表的一项，意味着option可以在命令行中多次出现。</span><br><span class="line">action=&apos;append_const&apos;，传入列表的项由const定义，通常用在需要多个argument将值传入一个列表中的场景。</span><br><span class="line">action=&apos;count&apos;，输出argument出现的次数。</span><br><span class="line">action=&apos;help&apos;，已默认添加。</span><br><span class="line">action=&apos;version&apos;，需要定义version，使用时输出版本信息并退出。</span><br><span class="line">自定义，通过定义一个argparse.Action子类来实现。实际上，上面的这些可选项都是通过这种形式定义的。</span><br></pre></td></tr></table></figure></li><li><p><code>nargs</code> ArgumentParser对象通常将一个动作与一个命令行参数关联。nargs关键字参数将一个动作与不同数目的命令行参数关联在一起：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nargs=N，一个选项后可以跟多个参数（action=&apos;append&apos;时，依然是一个选项后跟一个参数，只不过选项可以多次出现），参数的个数必须为N的值，这些参数会生成一个列表，当nargs=1时，会生成一个长度为1的列表。</span><br><span class="line">nargs=?，如果没有在命令行中出现对应的项，则给对应的项赋值为default。特殊的是，对于可选项，如果命令行中出现了此可选项，但是之后没有跟随赋值参数，则此时给此可选项并不是赋值default的值，而是赋值const的值。</span><br><span class="line">nargs=* 位置参数 0 到多个</span><br><span class="line">nargs=+ 位置参数 1 到多个</span><br><span class="line">nargs=argparse.REMAINDER，所有剩余的参数，均转化为一个列表赋值给此项，通常用此方法来将剩余的参数传入另一个parser进行解析。如果nargs没有定义，则可传入参数的数量由action决定，通常情况下为一个，并且不会生成长度为一的列表。</span><br></pre></td></tr></table></figure><ul><li><code>const</code> 一种是定义action=’store_const’或action=’append_const’时使用。一种是定义nargs=’?’时，可选项出现在命令行中，但之后并没有跟随赋值的参数，作为默认值传给此可选项。</li><li><code>default</code> 默认值。<br>  如果是一个字符串，那么Parser解析的时候会将它作为命令行传入值，使用type的值来进行转换类型，但是如果不是的话，就会使用定义的值而不进行类型转换。如果设置了nargs=’?’或nargs=<code>*</code>，那么当没有参数赋值给该项时，会使用default定义的值。<br>而default=argparse.SUPPRESS时，则表示命令行中未出现某一项时，不会对它进行默认赋值。</li><li><code>type</code> 用于类型检查和类型转换。<br>  使用FileType可简化对文件的操作。还可以自定义函数，输入是一个字符串，输出是转换后的字符串。当设置choices的时，类型检查会变得容易，因为只需要在一个范围内比较即可。</li><li><code>choices</code> 给定了取值范围，超出会报错。<br>  当type也有定义时，会先使用type进行类型检查，所以choices中的取值必须符合type的定义，否则在parse_args()时会报错。任何支持in操作符的均可作为choices的赋值，所以字典，列表，集合，等等其他容器均都支持。</li><li><code>required</code> 默认情况下，可选项（前面有’-‘）被认为并不一定需要出现在命令行参数中，但是如果设置了required=True的话，则必须出现。此类设置违背人的常识，应避免使用。</li><li><code>help</code> 帮助信息。<br>  之前提到的%(prog)s可用于此处程序名的格式化，此外，还有%(default)s格式化default的值，%(type)s格式化type的值。<br>设置为argparse.SUPPRESS可不显示帮助信息。</li><li><code>metavar</code> 在Parser生成帮助信息时，需要有字符代表需要传入的值。（这一段和dest相同，使用的就是dest的值）如果是位置参数，则用它本身代替；如果是可选参数，则使用它的大写来代替。使用metavar可替换默认的字符。</li><li><code>dest</code> 大部分的选项都需要通过命令行来给其赋值，这些值的名字通过dest来定义，默认的规则如同metavar中所述。</li></ul><h2><span id="shi-ji-ming-ling-de-li-zi">实际命令的例子</span><a href="#shi-ji-ming-ling-de-li-zi" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls ~/Downloads ~/Documents</span></span><br><span class="line"><span class="comment"># 位置参数 0 或多个</span></span><br><span class="line">parser.add_argument(<span class="string">'files'</span>, nargs=<span class="string">'*'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget https://wxnacy.com</span></span><br><span class="line"><span class="comment"># 位置参数为必传</span></span><br><span class="line">parser.add_argument(<span class="string">'url'</span>, nargs=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget https://wxnacy.com</span></span><br><span class="line"><span class="comment"># 位置参数为必传</span></span><br><span class="line">parser.add_argument(<span class="string">'url'</span>, nargs=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl -X POST &lt;url&gt; -H 'Content-Type: application/json' -H 'Postman-Token: 0871758a-2782-4600-9d1f-e3da3270fd95'</span></span><br><span class="line"><span class="comment"># 可选参数可以叠加</span></span><br><span class="line">parser.add_argument(<span class="string">'-H'</span>, <span class="string">'--headers'</span>, action=<span class="string">'append'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -a</span></span><br><span class="line"><span class="comment"># 可选参数为 bool 类型</span></span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, action=<span class="string">'store_true'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 有很多处理命令行参数的外部模块，&lt;a href=&quot;https://github.com/pallets/click&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;click&lt;/a&gt; 是其中的佼佼者，如果你是要完成一个稍微复杂点的项目，我也推荐使用它。但是如果编写一个独立的脚本，我认为方便简洁才是最重要的，也就是能用内置模块就用内置模块。此时了解相应功能的实现方式就尤为重要，何况 &lt;a href=&quot;https://docs.python.org/3/howto/argparse.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;argparse&lt;/a&gt; 也真的没有想象中的那么难用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux split 分割日志</title>
    <link href="http://wxnacy.com/2019/06/25/linux-split/"/>
    <id>http://wxnacy.com/2019/06/25/linux-split/</id>
    <published>2019-06-25T06:43:11.000Z</published>
    <updated>2019-06-25T07:21:56.093Z</updated>
    
    <content type="html"><![CDATA[<p>split 命令用于将文件平均分割为多个小文件，多用于日志查看。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>先下载一个测试文件 <a href="https://raw.githubusercontent.com/wxnacy/file/master/common/split_test" target="_blank" rel="noopener">split_test</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ split split_test</span><br><span class="line">$ ll</span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 wxnacy  staff  216320 Jun 25 14:52 split_test</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xaa</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xab</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xac</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xad</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xae</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xaf</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xag</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xah</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xai</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xaj</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   16320 Jun 25 14:54 xak</span><br></pre></td></tr></table></figure><p>默认 <code>split</code> 会将文件均匀的分割成多个小文件，文件名以 <code>x</code> 开头，剩余字符按字符表排序。</p><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ split [OPTION]... [FILE [PREFIX]]</span><br></pre></td></tr></table></figure><p><code>split</code> 命令有多个参数可供调用</p><p><code>-b</code> 指定输出文件的大小，单位为 byte。<br><code>-d</code> 使用数字作为后缀。<br><code>-l</code> 指定输出文件的行数<br><code>-a</code> 指定后缀的长度</p><p><strong>分割出 100k 的文件</strong></p><p><code>-b</code> 默认单位为 byte，可以指定分割单位，如 <code>K,M,G,T,P,E,Z,Y</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 100k split_test</span><br><span class="line">$ ll</span><br><span class="line">total 856</span><br><span class="line">-rw-r--r--  1 wxnacy  staff  216320 Jun 25 14:52 split_test</span><br><span class="line">-rw-r--r--  1 wxnacy  staff  102400 Jun 25 14:59 xaa</span><br><span class="line">-rw-r--r--  1 wxnacy  staff  102400 Jun 25 14:59 xab</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   11520 Jun 25 14:59 xac</span><br></pre></td></tr></table></figure><p><strong>使用数字为后缀，并指定长度</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 100k -d -a 4 split_test</span><br><span class="line">$ ll</span><br><span class="line">total 424</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 216320 Jun 25 07:12 split_test</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:13 x0000</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:13 x0001</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  11520 Jun 25 07:13 x0002</span><br></pre></td></tr></table></figure><p><strong>指定文件前缀</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 100k -d -a 4 split_test split.</span><br><span class="line">$ ll</span><br><span class="line">total 424</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 216320 Jun 25 07:12 split_test</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:15 split.0000</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:15 split.0001</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  11520 Jun 25 07:15 split.0002</span><br></pre></td></tr></table></figure><p><strong>指定行数分割文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ split -l 1000 split_test</span><br><span class="line">$ ll</span><br><span class="line">total 428</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 216320 Jun 25 07:12 split_test</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xaa</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xab</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xac</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xad</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xae</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xaf</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xag</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xah</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xai</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xaj</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  16320 Jun 25 07:20 xak</span><br><span class="line"></span><br><span class="line">$ wc -l xaa</span><br><span class="line">1000 xaa</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;split 命令用于将文件平均分割为多个小文件，多用于日志查看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
</feed>
