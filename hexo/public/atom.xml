<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-07-16T06:49:25.476Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx 报错 no resolver defined to resolve</title>
    <link href="http://wxnacy.com/2019/07/16/nginx-no-resolver-defined-to-resolve/"/>
    <id>http://wxnacy.com/2019/07/16/nginx-no-resolver-defined-to-resolve/</id>
    <published>2019-07-16T06:49:25.000Z</published>
    <updated>2019-07-16T06:49:25.476Z</updated>
    
    <content type="html"><![CDATA[<p>起因是使用 <code>ngxin + lua</code> 链接外部机器 Redis 时产生的</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>原因是 Nginx 0.6.18以后的版本中启用了一个resolver指令，在使用变量来构造某个server地址的时候一定要用resolver指令来指定DNS服务器的地址，所以解决这个问题的方法很简单：在nginx的配置文件中的http{}部分添加一行DNS地址即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果机器支持 ipv6，可以去掉对它的支持，免得产生类似错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8 ipv6=off;</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-resty-redis/issues/159" target="_blank" rel="noopener">No resolver defined to resolve</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起因是使用 &lt;code&gt;ngxin + lua&lt;/code&gt; 链接外部机器 Redis 时产生的&lt;/p&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://wxnacy.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Python 对 JSON 中的特殊类型进行 Encoder</title>
    <link href="http://wxnacy.com/2019/07/13/python-json-encoder-decoder/"/>
    <id>http://wxnacy.com/2019/07/13/python-json-encoder-decoder/</id>
    <published>2019-07-13T01:56:59.000Z</published>
    <updated>2019-07-13T02:04:21.229Z</updated>
    
    <content type="html"><![CDATA[<p>Python 处理 JSON 数据时，<code>dumps</code> 函数是经常用到的，当 JSON 数据中有特殊类型时，往往是比较头疼的，因为经常会报这样一个错误。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#zi-ding-yi-bian-ma-lei">自定义编码类</a></li><li><a href="#dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang">单分派装饰器处理对象</a></li></ul><!-- tocstop --></div><h2><span id="zi-ding-yi-bian-ma-lei">自定义编码类</span><a href="#zi-ding-yi-bian-ma-lei" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">USER_DATA = dict(</span><br><span class="line">    id = <span class="number">1</span>, name = <span class="string">'wxnacy'</span>, ts = datetime.now()</span><br><span class="line">)</span><br><span class="line">print(json.dumps(USER_DATA))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/wxnacy/PycharmProjects/study/python/office_module/json_demo/dumps.py"</span>, line 74, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dumps_encoder()</span><br><span class="line">  File <span class="string">"/Users/wxnacy/PycharmProjects/study/python/office_module/json_demo/dumps.py"</span>, line 68, <span class="keyword">in</span> dumps_encoder</span><br><span class="line">    <span class="built_in">print</span>(json.dumps(USER_DATA))</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/__init__.py"</span>, line 231, <span class="keyword">in</span> dumps</span><br><span class="line">    <span class="built_in">return</span> _default_encoder.encode(obj)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 199, <span class="keyword">in</span> encode</span><br><span class="line">    chunks = self.iterencode(o, _one_shot=True)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 257, <span class="keyword">in</span> iterencode</span><br><span class="line">    <span class="built_in">return</span> _iterencode(o, 0)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 180, <span class="keyword">in</span> default</span><br><span class="line">    o.__class__.__name__)</span><br><span class="line">TypeError: Object of <span class="built_in">type</span> <span class="string">'datetime'</span> is not JSON serializable</span><br></pre></td></tr></table></figure><p>原因在于 <code>dumps</code> 函数不知道如何处理 <code>datetime</code> 对象，默认情况下 <code>json</code> 模块使用 <code>json.JSONEncoder</code> 类来进行编码，此时我们需要自定义一下编码类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(x, datetime):</span><br><span class="line">            <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line">        <span class="keyword">return</span> super().default(self, x)</span><br></pre></td></tr></table></figure><p>定义编码类 <code>CustomEncoder</code> 并重写实例的 <code>default</code> 函数，对特殊类型进行处理，其余类型继续使用父类的解析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(x, datetime):</span><br><span class="line">            <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line">        <span class="keyword">return</span> super().default(self, x)</span><br><span class="line"></span><br><span class="line">USER_DATA = dict(</span><br><span class="line">    id = <span class="number">1</span>, name = <span class="string">'wxnacy'</span>, ts = datetime.now()</span><br><span class="line">)</span><br><span class="line">print(json.dumps(USER_DATA, cls=CustomEncoder))</span><br><span class="line"><span class="comment"># &#123;"id": 1, "name": "wxnacy", "ts": 1562938926&#125;</span></span><br></pre></td></tr></table></figure><p>最后整合起来，将类使用 <code>cls</code> 参数传入 <code>dumps</code> 函数即可。</p><p>使用 <code>CustomEncoder</code> 实例的 <code>encode</code> 函数可以对对象进行转码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line">print(CustomEncoder().encode(datetime.now()))</span><br><span class="line"><span class="comment"># 1562939035</span></span><br></pre></td></tr></table></figure><p>在父类源码中，所有的编码逻辑都在 <code>encode</code> 函数中，<code>default</code> 只负责抛出 <code>TypeError</code> 异常，这就是文章开始报错的出处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, o)</span>:</span></span><br><span class="line">    <span class="string">"""Implement this method in a subclass such that it returns</span></span><br><span class="line"><span class="string">    a serializable object for ``o``, or calls the base implementation</span></span><br><span class="line"><span class="string">    (to raise a ``TypeError``).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For example, to support arbitrary iterators, you could</span></span><br><span class="line"><span class="string">    implement default like this::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        def default(self, o):</span></span><br><span class="line"><span class="string">            try:</span></span><br><span class="line"><span class="string">                iterable = iter(o)</span></span><br><span class="line"><span class="string">            except TypeError:</span></span><br><span class="line"><span class="string">                pass</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                return list(iterable)</span></span><br><span class="line"><span class="string">            # Let the base class default method raise the TypeError</span></span><br><span class="line"><span class="string">            return JSONEncoder.default(self, o)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">f'Object of type <span class="subst">&#123;o.__class__.__name__&#125;</span> '</span></span><br><span class="line">                    <span class="string">f'is not JSON serializable'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self, o)</span>:</span></span><br><span class="line">    <span class="string">"""Return a JSON string representation of a Python data structure.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from json.encoder import JSONEncoder</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; JSONEncoder().encode(&#123;"foo": ["bar", "baz"]&#125;)</span></span><br><span class="line"><span class="string">    '&#123;"foo": ["bar", "baz"]&#125;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># This is for extremely simple cases and benchmarks.</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(o, str):</span><br><span class="line">        <span class="keyword">if</span> self.ensure_ascii:</span><br><span class="line">            <span class="keyword">return</span> encode_basestring_ascii(o)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> encode_basestring(o)</span><br><span class="line">    <span class="comment"># This doesn't pass the iterator directly to ''.join() because the</span></span><br><span class="line">    <span class="comment"># exceptions aren't as detailed.  The list call should be roughly</span></span><br><span class="line">    <span class="comment"># equivalent to the PySequence_Fast that ''.join() would do.</span></span><br><span class="line">    chunks = self.iterencode(o, _one_shot=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(chunks, (list, tuple)):</span><br><span class="line">        chunks = list(chunks)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(chunks)</span><br></pre></td></tr></table></figure><h2><span id="dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang">单分派装饰器处理对象</span><a href="#dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang" class="header-anchor"></a></h2><p><code>CustomEncoder</code> 如果处理的对象种类很多的话，需要写多个 <code>if elif else</code> 来区分，这样并不是不行，但是不够优雅，不够 pythonic</p><p>根据对象的类型不同，而做出不同的处理。刚好有个装饰器可以做到这点，它就是单分派函数 <code>functools.singledispatch</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> encode(x)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> super().default(self, x)</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch             # 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">'Unencode type'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@encode.register(datetime)  # 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line"></span><br><span class="line"><span class="meta">@encode.register(date)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x.isoformat()</span><br><span class="line"></span><br><span class="line">print(json.dumps(dict(dt = datetime.now(), d = date.today()), cls=CustomEncoder))</span><br><span class="line"><span class="comment"># &#123;"dt": 1562940781, "d": "2019-07-12"&#125;</span></span><br></pre></td></tr></table></figure><ul><li>1 使用 <code>@singledispatch</code> 装饰 <code>encode</code> 函数，是他处理默认类型。同时给他添加一个装饰器构造函数变量。</li><li>2 <a href="mailto:`@encode.register" target="_blank" rel="noopener">`@encode.register</a>()` 是一个装饰器构造函数，接收需要处理的对象类型作为参数。用它装饰的函数不需要名字，<em>_</em> 代替即可。</li></ul><p>最后提一点，<code>json</code> 也可以在命令行中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'&#123;"json": "obj"&#125;'</span> | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"json"</span>: <span class="string">"obj"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">json</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 处理 JSON 数据时，&lt;code&gt;dumps&lt;/code&gt; 函数是经常用到的，当 JSON 数据中有特殊类型时，往往是比较头疼的，因为经常会报这样一个错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 如何安装 Redis</title>
    <link href="http://wxnacy.com/2019/07/12/centos7-install-redis/"/>
    <id>http://wxnacy.com/2019/07/12/centos7-install-redis/</id>
    <published>2019-07-12T09:02:08.000Z</published>
    <updated>2019-07-12T09:06:01.078Z</updated>
    
    <content type="html"><![CDATA[<p>Centos 默认仓库不包含 Redis 安装包，我们可以从 Remi 仓库中来安装。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p><strong>安装 Remi 仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install epel-release yum-utils</span><br><span class="line">$ sudo yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm</span><br><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> remi</span><br></pre></td></tr></table></figure><p><strong>安装 Redis</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y redis</span><br></pre></td></tr></table></figure><p><strong>启动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start redis    <span class="comment"># 启动</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> redis   <span class="comment"># 开机自启</span></span><br></pre></td></tr></table></figure><p><strong>测试是否安装成功</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><ul><li><a href="https://linuxize.com/post/how-to-install-and-configure-redis-on-centos-7/" target="_blank" rel="noopener">How To Install and Configure Redis on CentOS 7</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Centos 默认仓库不包含 Redis 安装包，我们可以从 Remi 仓库中来安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>apt 下载报错 [Could not get lock /var/lib/dpkg/lock-frontend]</title>
    <link href="http://wxnacy.com/2019/07/11/apt-install-error/"/>
    <id>http://wxnacy.com/2019/07/11/apt-install-error/</id>
    <published>2019-07-11T13:15:29.000Z</published>
    <updated>2019-07-11T13:35:24.193Z</updated>
    
    <content type="html"><![CDATA[<p>有两种情况会导致软件安装工具报这种错</p><ul><li><code>Synaptic Package Manager</code> 或 <code>Software Updater</code> 是打开的。</li><li>一些apt命令在终端中运行或者在后台有进程正在运行。</li></ul><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y redis</span><br><span class="line">E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)</span><br><span class="line">E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?</span><br></pre></td></tr></table></figure><p><strong>查看进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep apt</span><br><span class="line">root 1747 0.0 0.0 4628 808 ? Ss 07:06 0:00 /bin/sh /usr/lib/apt/apt.systemd.daily update</span><br><span class="line">root 1769 0.0 0.0 4628 1820 ? S 07:06 0:00 /bin/sh /usr/lib/apt/apt.systemd.daily lock_is_held update</span><br><span class="line">_apt 16225 3.0 0.2 80192 8796 ? S 07:07 0:04 /usr/lib/apt/methods/http</span><br><span class="line">_apt 16226 0.7 0.2 80188 8800 ? S 07:07 0:01 /usr/lib/apt/methods/http</span><br></pre></td></tr></table></figure><p><strong>停掉进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo killall apt apt-get</span><br></pre></td></tr></table></figure><p>这是比较快捷的方式，但是还不够，前两条都无法关闭，只能将 pid 杀死</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">kill</span> -9 &lt;pid&gt;</span><br></pre></td></tr></table></figure><p><strong>删除加锁文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /var/lib/apt/lists/lock</span><br><span class="line">$ sudo rm /var/cache/apt/archives/lock</span><br><span class="line">$ sudo rm /var/lib/dpkg/lock*</span><br></pre></td></tr></table></figure><p><strong>重新配置 dpkg</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg --configure -a</span><br><span class="line">dpkg: error: parsing file <span class="string">'/var/lib/dpkg/updates/0004'</span> near line 0:</span><br><span class="line">newline <span class="keyword">in</span> field name <span class="string">'#padding'</span></span><br></pre></td></tr></table></figure><p>这时候有可能还会出现一个错误，这时要手动删除该文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/dpkg/updates/0004</span><br></pre></td></tr></table></figure><p>再次执行配置命令，然后继续安装软件即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update -y</span><br><span class="line">$ sudo apt install -y redis</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两种情况会导致软件安装工具报这种错&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Synaptic Package Manager&lt;/code&gt; 或 &lt;code&gt;Software Updater&lt;/code&gt; 是打开的。&lt;/li&gt;
&lt;li&gt;一些apt命令在终端中运行或者在后台有进程正在运行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 内存管理之 `*` 运算的陷阱</title>
    <link href="http://wxnacy.com/2019/07/10/python-memory-mul/"/>
    <id>http://wxnacy.com/2019/07/10/python-memory-mul/</id>
    <published>2019-07-10T13:05:49.000Z</published>
    <updated>2019-07-10T13:06:47.677Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中实现了 <code>__mul__</code> 魔法函数的对象，都支持 <code>*</code> 号运算。内置类型更是默认实现了该函数，使用起来也很方便。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>但是对列表对象进行 <code>*</code> 运算时，却不得不注意一个陷阱。</p><p>刚接触这个特性时，美滋滋的以为可以快速的扩展列表，比如这样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>看起来没什么问题，然而实际开发中没这么简单的例子，随便复杂一点，就会出现问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [[]] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[], [], []]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>很显然出现了问题，我只是给索引位置 <code>0</code> 的元素增加了一个子元素，然后所有的元素都改变了。</p><p>出现这个问题的原因是 <code>*</code> 运算复制的不是子元素，而是当前子元素所指对象的引用，所以当改变该对象时，所有引用该对象的元素都会发生改变。</p><p>关于对象引用可以看 <a href="/2019/06/16/python-memory-management">Python 内存管理</a>，里面有更详细的讲解。</p><p>再看一个现象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>] = [<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">2</span>], [<span class="number">1</span>], [<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>这次就想开始那个简单例子一样，结果跟我们预期的一样，这次是为什么呢？</p><p>因为我们没有改变该索引位置的对象，而是让他引向了新的对象 <code>[2]</code>，这样就不影响其他索引位置的对象了。</p><p>那么怎么才能做到扩展列表呢？答案是列表解析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[[], [], []]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[[<span class="number">1</span>], [], []]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中实现了 &lt;code&gt;__mul__&lt;/code&gt; 魔法函数的对象，都支持 &lt;code&gt;*&lt;/code&gt; 号运算。内置类型更是默认实现了该函数，使用起来也很方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 命令行参数模块 argparse</title>
    <link href="http://wxnacy.com/2019/07/08/python-argparse/"/>
    <id>http://wxnacy.com/2019/07/08/python-argparse/</id>
    <published>2019-07-08T13:32:29.000Z</published>
    <updated>2019-07-10T14:19:15.386Z</updated>
    
    <content type="html"><![CDATA[<p>Python 有很多处理命令行参数的外部模块，<a href="https://github.com/pallets/click" target="_blank" rel="noopener">click</a> 是其中的佼佼者，如果你是要完成一个稍微复杂点的项目，我也推荐使用它。但是如果编写一个独立的脚本，我认为方便简洁才是最重要的，也就是能用内置模块就用内置模块。此时了解相应功能的实现方式就尤为重要，何况 <a href="https://docs.python.org/3/howto/argparse.html" target="_blank" rel="noopener">argparse</a> 也真的没有想象中的那么难用。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#chu-shi-hua">初始化</a></li><li><a href="#jie-xi-can-shu">解析参数</a></li><li><a href="#shi-ji-ming-ling-de-li-zi">实际命令的例子</a></li></ul><!-- tocstop --></div><p>直接进入正题，基础用法如下</p><h2><span id="chu-shi-hua">初始化</span><a href="#chu-shi-hua" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># filename: demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'This is a argparse demo'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python demo.py -h</span><br><span class="line">usage: demo.py [-h]</span><br><span class="line"></span><br><span class="line">This is a argparse demo</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>三行代码即可初始化一个命令行参数模块，默认有一个 <code>-h, --help</code> 参数显示帮助信息。</p><p><code>ArgumentParser</code> 函数有如下参数:</p><ul><li><code>prog</code> 程序的名字，默认是argv[0]。若设置，则在帮助信息中，可以使用%(prog)s来作为格式化的引用（修改一处全局受用）。</li><li><code>usage</code> 帮助信息的usage字段，描述程序的各种用法，默认情况下会依据add_argument()来自动生成。</li><li><code>description</code> 一个简单描述程序主要干啥以及怎么用的字符段，默认为空。</li><li><code>epilog</code> optional arguments字符段之后的字符段，默认为空。</li><li><code>parents</code> 继承的父parser，为了避免一些公共的内容重复定义，父parser在初始化时会设置add_help=False，这是为了防止出现父与子parser的-h冲突而抛出异常。</li><li><code>formatter_class</code> 对于help输出进行格式化，除了输出的样式外，如果设置为ArgumentDefaultsHelpFormatter，则会自动在help输出中添加已定义的default值。</li><li><code>prefix_chars</code> options前的字符，默认为’-‘，可以添加其他字符，如’-+’，但是如果没有包括’-‘，那么对应的option如’-h’就无法解析。</li><li><code>fromfile_prefix_chars</code> 有时会使用文件给parse_args()传入参数，为了能够识别文件字符串，如”demo.txt”，需要设置此值，如”@”，那么所有以此字符为开头的字符串都被当作是文件，所以传给parse_args()的参数应该是@demo.txt。在该文件中，一行只能有一个参数。如文件中的’-f\nbar’会被解析成[‘-f’,’bar’]。</li><li><code>argument_default</code> 一般情况下，默认值使用add_argument()来添加，或者使用set_defaults()设置一些键值对来添加。剩下一种情况就是设置此项（此处没看明白是咋回事）。</li><li><code>conflict_handler</code> 解决在add_argument()阶段有冲突的option的依据策略，默认为error即抛出异常。一般情况下遇到冲突是抛出异常即可，但是如果设置了parents，那么需要重写父parser中的规则的时候，就需要将此项设置为resolve，但是重写是精确匹配的，如老规则定义了-h/–help，重写了-h，那么–help还是老规则。</li><li><code>add_help</code> 是否添加-h/–helpoption，默认为True。为False时，是要做parent（其实可以设置子Parser重写）。默认是-h/–help，若prefix_chars中没有包含’-‘，那么就以其中第一个字符作为代替。</li></ul><h2><span id="jie-xi-can-shu">解析参数</span><a href="#jie-xi-can-shu" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># filename: demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'This is a argparse demo'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'file'</span>, help=<span class="string">'List file or dir'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-u'</span>, <span class="string">'--user'</span>, help=<span class="string">'Config user name'</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.file)</span><br><span class="line">print(args.user)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python demo.py bashrc -u wxnacy</span><br><span class="line">bashrc</span><br><span class="line">wxnacy</span><br></pre></td></tr></table></figure><p><code>add_argument</code> 函数有如下参数：</p><ul><li><p><code>name or flags</code> 是位置参数，则需要传入名字；要是可选参数，则需要进行定义，如’-f’，’–foo’。</p></li><li><p><code>action</code> 定义传入的参数如何处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">action=&apos;store&apos;，默认取值，保存传入参数。</span><br><span class="line">action=&apos;store_const&apos;，需要添加const，意味着该argument的值不从命令行输入，而是取const的值。</span><br><span class="line">action=&apos;store_true&apos; or action=&apos;store_false&apos;，&apos;store_const&apos;的特殊情形，意味着const的值为True或False。</span><br><span class="line">action=&apos;append&apos;，表示传入的值会作为一个列表的一项，意味着option可以在命令行中多次出现。</span><br><span class="line">action=&apos;append_const&apos;，传入列表的项由const定义，通常用在需要多个argument将值传入一个列表中的场景。</span><br><span class="line">action=&apos;count&apos;，输出argument出现的次数。</span><br><span class="line">action=&apos;help&apos;，已默认添加。</span><br><span class="line">action=&apos;version&apos;，需要定义version，使用时输出版本信息并退出。</span><br><span class="line">自定义，通过定义一个argparse.Action子类来实现。实际上，上面的这些可选项都是通过这种形式定义的。</span><br></pre></td></tr></table></figure></li><li><p><code>nargs</code> ArgumentParser对象通常将一个动作与一个命令行参数关联。nargs关键字参数将一个动作与不同数目的命令行参数关联在一起：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nargs=N，一个选项后可以跟多个参数（action=&apos;append&apos;时，依然是一个选项后跟一个参数，只不过选项可以多次出现），参数的个数必须为N的值，这些参数会生成一个列表，当nargs=1时，会生成一个长度为1的列表。</span><br><span class="line">nargs=?，如果没有在命令行中出现对应的项，则给对应的项赋值为default。特殊的是，对于可选项，如果命令行中出现了此可选项，但是之后没有跟随赋值参数，则此时给此可选项并不是赋值default的值，而是赋值const的值。</span><br><span class="line">nargs=* 位置参数 0 到多个</span><br><span class="line">nargs=+ 位置参数 1 到多个</span><br><span class="line">nargs=argparse.REMAINDER，所有剩余的参数，均转化为一个列表赋值给此项，通常用此方法来将剩余的参数传入另一个parser进行解析。如果nargs没有定义，则可传入参数的数量由action决定，通常情况下为一个，并且不会生成长度为一的列表。</span><br></pre></td></tr></table></figure><ul><li><code>const</code> 一种是定义action=’store_const’或action=’append_const’时使用。一种是定义nargs=’?’时，可选项出现在命令行中，但之后并没有跟随赋值的参数，作为默认值传给此可选项。</li><li><code>default</code> 默认值。<br>  如果是一个字符串，那么Parser解析的时候会将它作为命令行传入值，使用type的值来进行转换类型，但是如果不是的话，就会使用定义的值而不进行类型转换。如果设置了nargs=’?’或nargs=<code>*</code>，那么当没有参数赋值给该项时，会使用default定义的值。<br>而default=argparse.SUPPRESS时，则表示命令行中未出现某一项时，不会对它进行默认赋值。</li><li><code>type</code> 用于类型检查和类型转换。<br>  使用FileType可简化对文件的操作。还可以自定义函数，输入是一个字符串，输出是转换后的字符串。当设置choices的时，类型检查会变得容易，因为只需要在一个范围内比较即可。</li><li><code>choices</code> 给定了取值范围，超出会报错。<br>  当type也有定义时，会先使用type进行类型检查，所以choices中的取值必须符合type的定义，否则在parse_args()时会报错。任何支持in操作符的均可作为choices的赋值，所以字典，列表，集合，等等其他容器均都支持。</li><li><code>required</code> 默认情况下，可选项（前面有’-‘）被认为并不一定需要出现在命令行参数中，但是如果设置了required=True的话，则必须出现。此类设置违背人的常识，应避免使用。</li><li><code>help</code> 帮助信息。<br>  之前提到的%(prog)s可用于此处程序名的格式化，此外，还有%(default)s格式化default的值，%(type)s格式化type的值。<br>设置为argparse.SUPPRESS可不显示帮助信息。</li><li><code>metavar</code> 在Parser生成帮助信息时，需要有字符代表需要传入的值。（这一段和dest相同，使用的就是dest的值）如果是位置参数，则用它本身代替；如果是可选参数，则使用它的大写来代替。使用metavar可替换默认的字符。</li><li><code>dest</code> 大部分的选项都需要通过命令行来给其赋值，这些值的名字通过dest来定义，默认的规则如同metavar中所述。</li></ul><h2><span id="shi-ji-ming-ling-de-li-zi">实际命令的例子</span><a href="#shi-ji-ming-ling-de-li-zi" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls ~/Downloads ~/Documents</span></span><br><span class="line"><span class="comment"># 位置参数 0 或多个</span></span><br><span class="line">parser.add_argument(<span class="string">'files'</span>, nargs=<span class="string">'*'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget https://wxnacy.com</span></span><br><span class="line"><span class="comment"># 位置参数为必传</span></span><br><span class="line">parser.add_argument(<span class="string">'url'</span>, nargs=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget https://wxnacy.com</span></span><br><span class="line"><span class="comment"># 位置参数为必传</span></span><br><span class="line">parser.add_argument(<span class="string">'url'</span>, nargs=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl -X POST &lt;url&gt; -H 'Content-Type: application/json' -H 'Postman-Token: 0871758a-2782-4600-9d1f-e3da3270fd95'</span></span><br><span class="line"><span class="comment"># 可选参数可以叠加</span></span><br><span class="line">parser.add_argument(<span class="string">'-H'</span>, <span class="string">'--headers'</span>, action=<span class="string">'append'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -a</span></span><br><span class="line"><span class="comment"># 可选参数为 bool 类型</span></span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, action=<span class="string">'store_true'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 有很多处理命令行参数的外部模块，&lt;a href=&quot;https://github.com/pallets/click&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;click&lt;/a&gt; 是其中的佼佼者，如果你是要完成一个稍微复杂点的项目，我也推荐使用它。但是如果编写一个独立的脚本，我认为方便简洁才是最重要的，也就是能用内置模块就用内置模块。此时了解相应功能的实现方式就尤为重要，何况 &lt;a href=&quot;https://docs.python.org/3/howto/argparse.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;argparse&lt;/a&gt; 也真的没有想象中的那么难用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux split 分割日志</title>
    <link href="http://wxnacy.com/2019/06/25/linux-split/"/>
    <id>http://wxnacy.com/2019/06/25/linux-split/</id>
    <published>2019-06-25T06:43:11.000Z</published>
    <updated>2019-06-25T07:21:56.093Z</updated>
    
    <content type="html"><![CDATA[<p>split 命令用于将文件平均分割为多个小文件，多用于日志查看。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>先下载一个测试文件 <a href="https://raw.githubusercontent.com/wxnacy/file/master/common/split_test" target="_blank" rel="noopener">split_test</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ split split_test</span><br><span class="line">$ ll</span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 wxnacy  staff  216320 Jun 25 14:52 split_test</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xaa</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xab</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xac</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xad</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xae</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xaf</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xag</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xah</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xai</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xaj</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   16320 Jun 25 14:54 xak</span><br></pre></td></tr></table></figure><p>默认 <code>split</code> 会将文件均匀的分割成多个小文件，文件名以 <code>x</code> 开头，剩余字符按字符表排序。</p><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ split [OPTION]... [FILE [PREFIX]]</span><br></pre></td></tr></table></figure><p><code>split</code> 命令有多个参数可供调用</p><p><code>-b</code> 指定输出文件的大小，单位为 byte。<br><code>-d</code> 使用数字作为后缀。<br><code>-l</code> 指定输出文件的行数<br><code>-a</code> 指定后缀的长度</p><p><strong>分割出 100k 的文件</strong></p><p><code>-b</code> 默认单位为 byte，可以指定分割单位，如 <code>K,M,G,T,P,E,Z,Y</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 100k split_test</span><br><span class="line">$ ll</span><br><span class="line">total 856</span><br><span class="line">-rw-r--r--  1 wxnacy  staff  216320 Jun 25 14:52 split_test</span><br><span class="line">-rw-r--r--  1 wxnacy  staff  102400 Jun 25 14:59 xaa</span><br><span class="line">-rw-r--r--  1 wxnacy  staff  102400 Jun 25 14:59 xab</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   11520 Jun 25 14:59 xac</span><br></pre></td></tr></table></figure><p><strong>使用数字为后缀，并指定长度</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 100k -d -a 4 split_test</span><br><span class="line">$ ll</span><br><span class="line">total 424</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 216320 Jun 25 07:12 split_test</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:13 x0000</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:13 x0001</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  11520 Jun 25 07:13 x0002</span><br></pre></td></tr></table></figure><p><strong>指定文件前缀</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 100k -d -a 4 split_test split.</span><br><span class="line">$ ll</span><br><span class="line">total 424</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 216320 Jun 25 07:12 split_test</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:15 split.0000</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:15 split.0001</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  11520 Jun 25 07:15 split.0002</span><br></pre></td></tr></table></figure><p><strong>指定行数分割文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ split -l 1000 split_test</span><br><span class="line">$ ll</span><br><span class="line">total 428</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 216320 Jun 25 07:12 split_test</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xaa</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xab</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xac</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xad</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xae</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xaf</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xag</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xah</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xai</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xaj</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  16320 Jun 25 07:20 xak</span><br><span class="line"></span><br><span class="line">$ wc -l xaa</span><br><span class="line">1000 xaa</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;split 命令用于将文件平均分割为多个小文件，多用于日志查看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux date 获取指定时间</title>
    <link href="http://wxnacy.com/2019/06/18/date-want-time/"/>
    <id>http://wxnacy.com/2019/06/18/date-want-time/</id>
    <published>2019-06-18T03:07:25.000Z</published>
    <updated>2019-06-19T00:13:44.468Z</updated>
    
    <content type="html"><![CDATA[<p>最近要写一些清洗数据的脚本，需要用到各种日期格式，今天来探讨下使用 <code>date</code> 命令的 <code>-d/--date</code> 参数来获取指定时间。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#shi-jian-chuo">时间戳</a></li><li><a href="#shi-qu">时区</a></li><li><a href="#datestr">datestr</a><ul><li><a href="#shi-jian-chuo-1">时间戳</a></li><li><a href="#shi-jian-ge-shi">时间格式</a></li><li><a href="#next-guan-jian-zi">next 关键字</a></li><li><a href="#ago-guan-jian-zi">ago 关键字</a></li></ul></li></ul><!-- tocstop --></div><p><code>-d/--date</code> 是非常强大且语法很多样复杂的参数，我了解的可能并不全面，想到哪里说到哪，提到的东西只能保证满足日常开发需求。</p><p><strong>本文提到的命令都是在 Linux 环境下进行的，Mac 环境需要下载 <code>GNU</code> 相应的命令。</strong></p><h2><span id="shi-jian-chuo">时间戳</span><a href="#shi-jian-chuo" class="header-anchor"></a></h2><p>将描述转换为 UTC 时间 1970-01-01 以后的时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'@12'</span></span><br><span class="line">Thu Jan  1 00:00:12 UTC 1970</span><br></pre></td></tr></table></figure><p>很明显我们可以用它来做时间戳的格式化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'@1560825826'</span></span><br><span class="line">Tue Jun 18 02:43:46 UTC 2019</span><br></pre></td></tr></table></figure><p>然后可以使用 <code>+FORMAT</code> 将时间转为时间戳</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'2019-06-18 11:36:19'</span> +%s</span><br><span class="line">1560857779</span><br></pre></td></tr></table></figure><h2><span id="shi-qu">时区</span><a href="#shi-qu" class="header-anchor"></a></h2><p>服务器一般默认使用的是 UTC 时区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br><span class="line">Tue Jun 18 03:41:35 UTC 2019</span><br></pre></td></tr></table></figure><p>返回指定时区格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ TZ=<span class="string">"Asia/Shanghai"</span> date</span><br><span class="line">Tue Jun 18 11:28:42 CST 2019</span><br></pre></td></tr></table></figure><p>设置指定时间的时区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'TZ="Asia/Shanghai" 2019-06-18 11:13:59'</span></span><br><span class="line">Tue Jun 18 03:13:59 UTC 2019</span><br></pre></td></tr></table></figure><p>世界时区名称列表 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">List of tz database time zones</a></p><h2><span id="datestr">datestr</span><a href="#datestr" class="header-anchor"></a></h2><p><code>-d/--date</code> 的语法为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ date -d datestr</span><br></pre></td></tr></table></figure><p>前面我们已经简单领略了他的使用方式，下面详细说说他都支持什么格式。</p><h3><span id="shi-jian-chuo">时间戳</span><a href="#shi-jian-chuo" class="header-anchor"></a></h3><p>这里注意一定要前面加上 <code>@</code> 符号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'@12'</span></span><br><span class="line">Thu Jan  1 00:00:12 UTC 1970</span><br></pre></td></tr></table></figure><h3><span id="shi-jian-ge-shi">时间格式</span><a href="#shi-jian-ge-shi" class="header-anchor"></a></h3><p>如果不加 <code>@</code> 会怎么样呢，如果传入的数字默认返回当天的指定小时的时间，取值 [0, 23]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'12'</span></span><br><span class="line">Tue Jun 18 12:00:00 UTC 2019</span><br></pre></td></tr></table></figure><p>更复杂的格式化按照标准格式 <code>YYYY-mm-dd HH:MM:SS</code> 来指定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'2019-06-18 11:58:20'</span></span><br><span class="line">Tue Jun 18 11:58:20 UTC 2019</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'11:20'</span></span><br><span class="line">Tue Jun 18 11:20:00 UTC 2019</span><br></pre></td></tr></table></figure><p>咦？似乎这样的设置没什么意义啊，固定的日子和时间，我为什么要多此一举的用 <code>date</code> 在获取一次。确实，它再搭配一点其他的语句就有很大的用处了。</p><h3><span id="next-guan-jian-zi">next 关键字</span><a href="#next-guan-jian-zi" class="header-anchor"></a></h3><p><code>next</code> 关键字可以让上面的命令更有意义</p><p>获取明天 9 点的时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'9 next day'</span></span><br><span class="line">Wed Jun 19 09:00:00 UTC 2019</span><br></pre></td></tr></table></figure><p>下周</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'9 next week'</span></span><br><span class="line">Wed Jun 25 09:00:00 UTC 2019</span><br></pre></td></tr></table></figure><p>下周一</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'9 next Mon'</span></span><br><span class="line">Wed Jun 24 09:00:00 UTC 2019</span><br></pre></td></tr></table></figure><p>下个月</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'9 next month'</span></span><br><span class="line">Wed Jun 24 09:00:00 UTC 2019</span><br></pre></td></tr></table></figure><p>如你所见，<code>next</code> 后面跟一个符合常理的时间或缩写就可以获取指定时间以后的某个时间，如果去掉 <code>9</code>，则返回的是当前时间以后的时间。</p><p>下一分钟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'next minute'</span></span><br><span class="line">Tue Jun 18 04:13:04 UTC 2019</span><br></pre></td></tr></table></figure><p>总结下 <code>next</code> 后面跟的参数</p><ul><li><code>second[s]</code> <code>minute[s]</code> <code>hour[s]</code> <code>day[s]</code> <code>week[s]</code> <code>month[s]</code> <code>year[s]</code></li><li>星期 <code>Sun[day]</code> <code>Mon[day]</code> <code>Tue[sday]</code> <code>Wed[nesday]</code> <code>Thu[rsday]</code> <code>Fri[day]</code> <code>Sat[urday]</code></li></ul><h3><span id="ago-guan-jian-zi">ago 关键字</span><a href="#ago-guan-jian-zi" class="header-anchor"></a></h3><p>可以获取之后，就可以获取之前的时间，安装英语的语法应该这样的</p><p>一分钟前</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'1 minute ago'</span></span><br><span class="line">Tue Jun 18 06:31:15 UTC 2019</span><br></pre></td></tr></table></figure><p><code>09:00</code> 的一分钟前</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'09:00 minute ago'</span></span><br><span class="line">Tue Jun 18 08:59:00 UTC 2019</span><br></pre></td></tr></table></figure><p>相信不用多举例，你也已经可以明白它的用法了，另外最前面的数字可以为负数，代表的是时间以后。下面两种方式都是获取以后以后的时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'-1 day ago'</span></span><br><span class="line">Wed Jun 19 06:36:53 UTC 2019</span><br><span class="line"></span><br><span class="line">$ date -d <span class="string">'next day'</span></span><br><span class="line">Wed Jun 19 06:37:00 UTC 2019</span><br></pre></td></tr></table></figure><p>总结下 <code>ago</code> 前可以使用的参数</p><ul><li><code>second[s]</code> <code>minute[s]</code> <code>hour[s]</code> <code>day[s]</code> <code>week[s]</code> <code>month[s]</code> <code>year[s]</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要写一些清洗数据的脚本，需要用到各种日期格式，今天来探讨下使用 &lt;code&gt;date&lt;/code&gt; 命令的 &lt;code&gt;-d/--date&lt;/code&gt; 参数来获取指定时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 内存管理</title>
    <link href="http://wxnacy.com/2019/06/16/python-memory-management/"/>
    <id>http://wxnacy.com/2019/06/16/python-memory-management/</id>
    <published>2019-06-16T07:08:10.000Z</published>
    <updated>2019-07-01T11:39:47.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>要不这样吧，如果编程语言里有个地方你弄不明白，而正好又有个人用了这个功能，那就开枪把他打死。这比学习新特性要容易些，然后过不了多久，那些活下来的程序员就会开始用 0.9.6 版的 Python，而且他们只需要使用这个版本中易于理解的那一小部分就好了（眨眼）。<br>  —— Tim Peters （传奇的核心开发者，“Python 之禅”作者）</p></blockquote><p>今天我们来聊一聊 Python 的内存管理。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#dui-xiang-yin-yong">对象引用</a><ul><li><a href="#bian-liang-ding-yi">变量定义</a></li><li><a href="#dong-tai-lei-xing">动态类型</a></li><li><a href="#dui-xiang-yin-yong-1">对象引用</a></li></ul></li><li><a href="#yin-yong-ji-shu">引用计数</a><ul><li><a href="#zeng-jia-yin-yong-ji-shu">增加引用计数</a></li><li><a href="#jian-shao-yin-yong-ji-shu">减少引用计数</a></li></ul></li><li><a href="#huan-cun-chi">缓存池</a><ul><li><a href="#bu-er-zhi">布尔值</a></li><li><a href="#xiao-zheng-shu">小整数</a></li><li><a href="#shou-gui-ju-zi-fu-chuan">守规矩字符串</a></li><li><a href="#xiang-tong-dai-ma-kuai">相同代码块</a></li></ul></li><li><a href="#la-ji-hui-shou">垃圾回收</a><ul><li><a href="#yin-yong-ji-shu-wei-0-de">引用计数为 0 的</a></li><li><a href="#fen-dai-hui-shou">分代回收</a></li><li><a href="#xun-huan-yin-yong">循环引用</a></li></ul></li><li><a href="#can-kao-wen-xian">参考文献</a></li></ul><!-- tocstop --></div><h2><span id="dui-xiang-yin-yong">对象引用</span><a href="#dui-xiang-yin-yong" class="header-anchor"></a></h2><h3><span id="bian-liang-ding-yi">变量定义</span><a href="#bian-liang-ding-yi" class="header-anchor"></a></h3><p>Python 不像多数的编译语言那样，需要对变量进行显示的声明。变量在第一次赋值时自动声明，变量只有被创建和赋值后才能被使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>k</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    k</span><br><span class="line">NameError: name <span class="string">'k'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3><span id="dong-tai-lei-xing">动态类型</span><a href="#dong-tai-lei-xing" class="header-anchor"></a></h3><p>严格来说变量是没有类型的，对象才有类型，变量引用了什么类型的对象，它就是什么类型。</p><p>变量的类型无需声明，是在程序运行时动态确定的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>k = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(k)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; k = "a"</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(k)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="dui-xiang-yin-yong">对象引用</span><a href="#dui-xiang-yin-yong" class="header-anchor"></a></h3><p>如何理解变量是对对象的引用呢？内置函数 <code>id()</code> 可以返回对象的内存地址，我们来看一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">1</span>)</span><br><span class="line"><span class="number">4432996208</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4432996208</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4432996208</span></span><br></pre></td></tr></table></figure><p>给变量 <code>a</code> 赋值 <code>1</code>，又给 <code>b</code> 赋值了 <code>a</code>，此时 <code>b</code> 并没有创建新对象，而是引向了 <code>a</code> 所指向的对象，换句话说 <code>b</code> 是对象的另一个别名。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/memory1.png" alt="1"></p><p>现在考虑一个问题，如果此时将 <code>a</code> 赋值为 <code>2</code>，<code>b</code> 等于多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果明白了上面说的，可以得到 <code>b</code> 依然等于 <code>1</code>，因为 <code>a</code> 和 <code>b</code> 都作为对象 <code>1</code> 的引用变量，现在只是将 <code>a</code> 引向其他对象，<code>b</code> 并不受影响。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/memory2.png" alt="2"></p><p>如果这一点可以理解的话，再看一个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br></pre></td></tr></table></figure><p>这时输出 <code>b</code> 你觉得会返回什么结果呢？</p><p>变量 <code>a</code> 和 <code>b</code> 都引用了列表对象 <code>[1, 2, 3]</code>，<code>a[0] = 4</code> 只是将列表对象索引位置 <code>0</code> 的子对象替换为 <code>4</code>，变量 <code>a</code> 和 <code>b</code> 对它的引用关系都没有改变，所以 <code>b</code> 也等于 <code>[4, 2, 3]</code></p><h2><span id="yin-yong-ji-shu">引用计数</span><a href="#yin-yong-ji-shu" class="header-anchor"></a></h2><p>刚才我们讲 <code>b = a</code> 时，提到此时 <code>b</code> 并没有创建新的对象，而是引用了 <code>a</code> 所引用的对象。</p><p>每个对象都包含一个头部信息，内容为类型标识符和引用计数器(Reference counter)。当对象被创建时 <code>a = [1, 2, 3]</code> 该对象的引用计数设置为 1，当对象有一个新的引用时，引用计数会自动加 1。</p><h3><span id="zeng-jia-yin-yong-ji-shu">增加引用计数</span><a href="#zeng-jia-yin-yong-ji-shu" class="header-anchor"></a></h3><p><code>sys</code> 模块中的 <code>getrefcount()</code> 函数可以获取对象的引用计数。当对象做参数传入该函数时，实际上也创建一个该对象的引用，所以返回值比预期会加 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>对象的引用计数增加，有下面几种情况</p><ul><li>对象被创建</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">114</span></span><br></pre></td></tr></table></figure><p><code>114</code> 这个数字有些过于超出我们的预期，我先按下不表，稍后的缓存池小节我会讲到。</p><ul><li>对象被其他变量引用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">115</span></span><br></pre></td></tr></table></figure><ul><li>对象成为容器对象的一个元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">123</span>, <span class="number">256</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">116</span></span><br></pre></td></tr></table></figure><ul><li>对象作为参数传递给函数（新的本地引用）<code>foo(n)</code></li></ul><h3><span id="jian-shao-yin-yong-ji-shu">减少引用计数</span><a href="#jian-shao-yin-yong-ji-shu" class="header-anchor"></a></h3><p>有增加，就会有减少。对象的引用不会不休止的增加，下面几种情况引用计数会减少</p><ul><li>对象的引用变量被赋值给另一个对象时</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">119</span></span><br></pre></td></tr></table></figure><ul><li>对象的引用变量被显示的销毁</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">118</span></span><br></pre></td></tr></table></figure><p><code>del</code> 语句会产生两个结果</p><ul><li><ul><li>从现在的变量名称空间中删除 <code>b</code></li></ul></li><li><ul><li>对象 <code>256</code> 的引用减少 1</li></ul></li><li><p>对象被一个容器对象中移除</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">123</span>, <span class="number">256</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">118</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.remove(<span class="number">256</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">117</span></span><br></pre></td></tr></table></figure><ul><li>容器对象本身被销毁</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">123</span>, <span class="number">256</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">118</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">117</span></span><br></pre></td></tr></table></figure><ul><li>一个本地引用离开其作用域时，比如 <code>foo(n)</code> 函数执行完毕时</li></ul><p>当对象的最后一个引用被移除时，该对象的引用计数减少为 0，这会导致该对象<strong>无法被访问</strong>。该对象就会成为垃圾回收机制的回收对象，而任何对该对象的追踪或调试都将增加它的引用计数，这也将推迟该对象被回收的时间。</p><h2><span id="huan-cun-chi">缓存池</span><a href="#huan-cun-chi" class="header-anchor"></a></h2><p>刚才我抛出了一个问题，对象 <code>256</code> 刚被创建出来，引用计数就是 <code>114</code>，有点诡异。</p><p>其实 Python 内部存在一个缓存池，缓存池内的对象在内存中只存在一份。所有符合缓存规则的对象，如果该对象不存在，创建后会进入缓存池，以后再次调用只是增加引用计数，如果该对象已经存在，那么针对它的所有调用都只是增加它的引用计数，即不会增加新的内存地址。这有一个很明显的好处，缓存池中的对象都是程序中最常用到的，缓存池的机制将在一定程度上减少内存的消耗。</p><p>现在可以回答刚才的问题了，<code>256</code> 对象身处缓存池中，所以我们以为 <code>a = 256</code> 是对它的创建，但其实只是某一个引用而已。</p><p>Python 的缓存池会包含三部分<strong>布尔值</strong>、<strong>小整数</strong>和<strong>守规矩字符串</strong></p><h3><span id="bu-er-zhi">布尔值</span><a href="#bu-er-zhi" class="header-anchor"></a></h3><p>布尔值比较好说，就两个值，任何情况下它都会被缓存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3><span id="xiao-zheng-shu">小整数</span><a href="#xiao-zheng-shu" class="header-anchor"></a></h3><p>这个小整数的范围为 [-5, 256]，我们想办法对此做一些验证。Python 中判断两个对象的值是否相等时可以使用 <code>==</code>，而判断两个对象是否为同一内存地址时需要使用 <code>is</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p><code>257</code> 超出了整数缓存池的范围，所以每次赋值都会创建一个新对象，即内存地址不同，我们可以通过 <code>id()</code> 函数查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4597659056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4592739216</span></span><br></pre></td></tr></table></figure><p>所以一般情况下你看到的拥有两个相同值的变量，往往他们引向的是两个不同的对象。</p><h3><span id="shou-gui-ju-zi-fu-chuan">守规矩字符串</span><a href="#shou-gui-ju-zi-fu-chuan" class="header-anchor"></a></h3><p>字符串的缓存逻辑比较复杂，我将符合规则的字符串称为<strong>守规矩字符串</strong>，规则有下面几种情况</p><ul><li>长度为 1 时</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"@"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"@"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li>长度大于 1，并且只含有大小写字母、数字、下划线时</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"wo_ai_ni_zhongguo"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"wo_ai_ni_zhongguo"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li><p>某些乘法时</p></li><li><ul><li>乘数为 1</li></ul></li><li><ul><li><ul><li>字符串长度等于 1</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"@"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"@"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li><ul><li><ul><li>字符串长度大于 1，且只含有大小写字母、数字、下划线时</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"wo_ai_ni_zhongguo"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"wo_ai_ni_zhongguo"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li><ul><li>乘数大于 1，仅含大小写字母，数字，下划线，总长度&lt;=20</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"wxnacy"</span> * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"wxnacy"</span> * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>面对这么多的规则，完全靠记忆的话，在开发中难免有些畏手畏脚，并且通常我们涉及到的字符串都比较复杂，那么这时我们怎么优化内存的使用呢？</p><p><code>sys</code> 模块中有一个函数 <code>insern()</code>，可以将任何形式的字符驻留在缓存池中，同时也可以将该字符从缓存池中取出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sys <span class="keyword">import</span> intern</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = intern(<span class="string">"12345!@#$%^qwertZXCV"</span> * <span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = intern(<span class="string">"12345!@#$%^qwertZXCV"</span> * <span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="string">"12345!@#$%^qwertZXCV"</span> * <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> c</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>每次使用都要调用该函数，才能保持字符串的内存地址一致，刚才我们提到的那些守规矩字符串内部也是这样实现的。我有理由相信，在任何需要字符串复用的地方都可以使用该函数，这将大大的优化程序的内存消耗</p><h3><span id="xiang-tong-dai-ma-kuai">相同代码块</span><a href="#xiang-tong-dai-ma-kuai" class="header-anchor"></a></h3><p>你以为到这就完了吗，再等等，还差点。</p><p>刚才我们的实验都是在不同代码块中进行的，在 Python 交互模式下，每个独立命令都是一个单独的代码块。而在相同的代码块下，缓存池的规则将简单很多。</p><p>任何的整数和布尔类型在相同代码块中都满足缓存机制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="number">1234567</span></span><br><span class="line"><span class="meta">... </span>    b = <span class="number">1234567</span></span><br><span class="line"><span class="meta">... </span>    print(a <span class="keyword">is</span> b)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>字符串依然要单拎出来说下</p><ul><li>非乘法得到的字符串都满足缓存机制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="string">"1234567!@#$%^&amp;QWERTY"</span></span><br><span class="line"><span class="meta">... </span>    b = <span class="string">"1234567!@#$%^&amp;QWERTY"</span></span><br><span class="line"><span class="meta">... </span>    print(a <span class="keyword">is</span> b)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li>乘法时，乘数为 1 时都满足缓存机制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="string">"1234567!@#$%^&amp;QWERTY"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    b = <span class="string">"1234567!@#$%^&amp;QWERTY"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    print(a <span class="keyword">is</span> b)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li>乘数大于 1 时，仅含大小写字母，数字，下划线，且总长度小于等于 20 满足缓存机制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="string">"wxnacy"</span> * <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    b = <span class="string">"wxnacy"</span> * <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    print(a <span class="keyword">is</span> b)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>除了上面说的类型，其它的类型如数组、字典等都不会进入缓存池</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2><span id="la-ji-hui-shou">垃圾回收</span><a href="#la-ji-hui-shou" class="header-anchor"></a></h2><p>我们给变量分配的内存，其实是在借用系统资源，有借就要有还。还资源的步骤就是垃圾回收时进行的，Python 解释器将会承担内存分配回收的复杂任务，我们只需要关心我们的业务流程，以及尽量的了解垃圾回收的过程，并写出更好的代码。</p><!-- 垃圾回收器在回收内存时会有遇到两种情况 --><h3><span id="yin-yong-ji-shu-wei-0-de">引用计数为 0 的</span><a href="#yin-yong-ji-shu-wei-0-de" class="header-anchor"></a></h3><p>前面我们提到，对象的引用会将它的引用计数加 1，而移除对它的引用会自动减 1。当对象的引用计数为 0 时，它将成为一个待回收的垃圾内存。</p><p>垃圾回收器会寻找这些引用计数为 0 的对象，垃圾回收时 Python 无法进行其它的任务，这个过程会将降低工作效率，所以当垃圾内存很少时没有必要频繁的执行垃圾回收。</p><p>当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</p><p><strong>查看阈值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> gc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.get_threshold()</span><br><span class="line">(<span class="number">700</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>返回值解释</p><ul><li><code>700</code> 垃圾回收启动的阈值</li><li><code>10</code> 每 10 次 0 代垃圾回收，会配合 1 次 1 代的垃圾回收</li><li><code>10</code> 每 10 次 1 代垃圾回收，会配合 1 次 2 代的垃圾回收</li></ul><p>我们也可以手动启动垃圾回收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.collect()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3><span id="fen-dai-hui-shou">分代回收</span><a href="#fen-dai-hui-shou" class="header-anchor"></a></h3><p>Python 将所有的对象分为 0、1、2 代，所有新建的对象为 0 代，每经历一次垃圾回收，依然存活的对象，会归入下一代对象。</p><p>分代（generation）回收策略基于这样的假设，在程序运行过程中，存活时间越久的对象，越不容易在后面的程序中变成垃圾。对于经历了几次垃圾回收依然存活的对象，出于信任和效率的考虑，垃圾回收器会减少对它的扫描频率。</p><h3><span id="xun-huan-yin-yong">循环引用</span><a href="#xun-huan-yin-yong" class="header-anchor"></a></h3><p>相信有过开发经验的同学都会碰见循环引用的情况，两个对象相互引用，会构成<strong>引用环（reference cycle）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [a]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> b</span><br></pre></td></tr></table></figure><p>在引用环中，即使删除了 <code>a</code> 和 <code>b</code> 对象，但是仍然有部分对象，从此以后无法使用，引用计数也不为 0，这将给垃圾回收造成很大的麻烦。</p><p>我们来模拟一下这个无法使用、引用计数也不为 0 的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="string">"wxnacy"</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">"wxnacy"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="string">"wxnacy"</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [a]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="string">"wxnacy"</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="string">"wxnacy"</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="string">"wxnacy"</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>相信看过前面章节后，很容易可以理解这个流程。我以短字符串 <code>wxnacy</code> 为参考对象，执行函数 <code>getrefcount(&quot;wxnacy&quot;)</code> 获取初始引用计数 2 （字符串本身被创建引用一次，getrefcount 函数本地引用一次），容器对象 <code>a</code> 引用加 1，直到 <code>del a</code> 前没有增加引用，而这一步删除容器对象的操作，本应该减少一次对 <code>wxnacy</code> 的引用次数，然后最后再次获取引用次数时，依然为 3，<code>wxnacy</code> 对象就将作为那个无法被使用，但是引用计数又不为 0 的对象遗漏在内存中。</p><p>为了回收这样的对象，Python 复制了每个对象的引用计数，记做 <code>gc_ref</code>，假设，每个对象 i，该计数为 <code>gc_ref_i</code>。Python 会遍历所有的对象 i。对于每个对象 i 引用的对象 j，将相应的 <code>gc_ref_j</code> 减 1。</p><p>在结束遍历后，<code>gc_ref</code> 不为 0 的对象，和这些对象引用的对象，以及更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.collect()</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>手动执行垃圾回收发现回收了两个对象，这说明这个简单的引用环就有两个无法被回收的对象，实际开发中这样的对象将是一个可怕的数字。</p><p>深入了解一门语言，理解内存管理机制是很有必要的。搞清楚内存分配和垃圾回收的过程，将会是提供程序性能的重要一步。现在再回过头来去看以前的代码，就会发现很多有风险的代码隐藏在其中，而现在能写出优秀的代码，也将是理所当然的。</p><h2><span id="can-kao-wen-xian">参考文献</span><a href="#can-kao-wen-xian" class="header-anchor"></a></h2><ul><li>Python 核心编程（第二版）49 页</li><li><a href="https://www.cnblogs.com/geaozhang/p/7111961.html" target="_blank" rel="noopener">Python内存管理机制</a></li><li><a href="https://www.cnblogs.com/jin-xin/articles/9439483.html" target="_blank" rel="noopener">python小数据池，代码块的最详细、深入剖析</a></li><li><a href="https://www.cnblogs.com/vamei/p/3232088.html" target="_blank" rel="noopener">Python深入06 Python的内存管理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;要不这样吧，如果编程语言里有个地方你弄不明白，而正好又有个人用了这个功能，那就开枪把他打死。这比学习新特性要容易些，然后过不了多久，那些活下来的程序员就会开始用 0.9.6 版的 Python，而且他们只需要使用这个版本中易于理解的那一小部分就好了（眨眼）。&lt;br&gt;  —— Tim Peters （传奇的核心开发者，“Python 之禅”作者）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来聊一聊 Python 的内存管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python collections.namedtuple() 命名元组的工厂函数</title>
    <link href="http://wxnacy.com/2019/06/12/python-collections-namedtuple/"/>
    <id>http://wxnacy.com/2019/06/12/python-collections-namedtuple/</id>
    <published>2019-06-12T08:25:52.000Z</published>
    <updated>2019-06-12T13:27:46.568Z</updated>
    
    <content type="html"><![CDATA[<p><code>collections</code> 包中的 <code>namedtuple()</code> 函数可以创建命名元组，并提供可读性和自文档性。它可以用于普通元组并使用名称或索引获取值。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>先看一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>User = namedtuple(<span class="string">'User'</span>, [<span class="string">'name'</span>, <span class="string">'age'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = User(<span class="string">'wxnacy'</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">User(name=<span class="string">'wxnacy'</span>, age=<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.name</span><br><span class="line"><span class="string">'wxnacy'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u[<span class="number">1</span>]</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(u)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">User</span>'&gt;</span></span><br></pre></td></tr></table></figure><p><code>namedtuple()</code> 可以很快捷的创建一个元组子类，再来看一下它的语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collections.namedtuple(typename, field_names, *, rename=<span class="keyword">False</span>, defaults=<span class="keyword">None</span>, module=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><ul><li><code>typename</code> 是创建得到的元组子类名</li><li><code>field_names</code> 域名序列，可以是一个字符串序列 <code>[x, y]</code>，或者用空格、逗号隔开的字符串 <code>x y</code> 或 <code>x, y</code><br>  任何有效的字符串都可以当做域名，除了以下划线和数字开头的字符串和<a href="https://docs.python.org/zh-cn/3/library/keyword.html#module-keyword" target="_blank" rel="noopener">关键字</a>，比如 <code>_name</code>, ‘class’ 等</li><li><code>rename</code> 无效域名会自动转换成位置名。比如 <code>[&#39;abc&#39;, &#39;def&#39;, &#39;ghi&#39;, &#39;abc&#39;]</code> 转换成 <code>[&#39;abc&#39;, &#39;_1&#39;, &#39;ghi&#39;, &#39;_3&#39;]</code> ， 消除关键词 def 和重复域名 abc。</li><li><code>defaults</code> 可以为 None 或者是一个默认值的 iterable 。如果一个默认值域必须跟其他没有默认值的域在一起出现，defaults 就应用到最右边的参数。比如如果域名 [‘x’, ‘y’, ‘z’] 和默认值 (1, 2) ，那么 x 就必须指定一个参数值 ，y 默认值 1 ， z 默认值 2 。</li><li><code>module</code> 值如果有定义，命名元组的 <code>__module__</code> 属性值就被设置。</li></ul><p><strong>命名元组实例没有字典，所以它们要更轻量，并且占用更小内存。</strong></p><p>除了继承元组的方法，命名元组还支持三个额外的方法和两个属性。为了防止域名冲突，方法和属性以下划线开始。</p><ul><li><code>classmethod somenamedtuple._make(iterable)</code> 类方法从存在的序列或迭代实例创建一个新实例。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>User._make([<span class="string">'wxnacy'</span>, <span class="number">18</span>])</span><br><span class="line">User(name=<span class="string">'wxnacy'</span>, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure><ul><li><code>somenamedtuple._asdict()</code> 返回一个新的 OrderedDict ，它将字段名称映射到它们对应的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = User._make([<span class="string">'wxnacy'</span>, <span class="number">18</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u._asdict()</span><br><span class="line">OrderedDict([(<span class="string">'name'</span>, <span class="string">'wxnacy'</span>), (<span class="string">'age'</span>, <span class="number">18</span>)])</span><br></pre></td></tr></table></figure><ul><li><code>somenamedtuple._replace(**kwargs)</code> 返回一个新的命名元组实例，并将指定域替换为新的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u._replace(name = <span class="string">'winn'</span>)</span><br><span class="line">User(name=<span class="string">'winn'</span>, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure><ul><li><code>somenamedtuple._fields</code> 字符串元组列出了域名。用于提醒和从现有元组创建一个新的命名元组类型。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u._fields</span><br><span class="line">(<span class="string">'name'</span>, <span class="string">'age'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>somenamedtuple._field_defaults</code> 默认值的字典。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>User = namedtuple(<span class="string">'User'</span>, [<span class="string">'name'</span>, <span class="string">'age'</span>], defaults=[<span class="string">'wxnacy'</span>, <span class="number">18</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = User()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u._fields_defaults</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'wxnacy'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p><code>3.5</code> 版本以后，文档字段变为可写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>User = namedtuple(<span class="string">'User'</span>, [<span class="string">'name'</span>, <span class="string">'age'</span>], defaults=[<span class="string">'wxnacy'</span>, <span class="number">18</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>User.__doc__</span><br><span class="line"><span class="string">'User(name, age)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>User.__doc__ += <span class="string">": user in collection"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>User.__doc__</span><br><span class="line"><span class="string">'User(name, age): user in collection'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>User.name.__doc__ = <span class="string">"User name"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>User.name.__doc__</span><br><span class="line"><span class="string">'User name'</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.python.org/zh-cn/3/library/collections.html#collections.namedtuple" target="_blank" rel="noopener">namedtuple()</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;collections&lt;/code&gt; 包中的 &lt;code&gt;namedtuple()&lt;/code&gt; 函数可以创建命名元组，并提供可读性和自文档性。它可以用于普通元组并使用名称或索引获取值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux 查看文件的几种方式</title>
    <link href="http://wxnacy.com/2019/06/08/linux-show-file/"/>
    <id>http://wxnacy.com/2019/06/08/linux-show-file/</id>
    <published>2019-06-07T21:48:00.000Z</published>
    <updated>2019-06-07T21:48:00.191Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 中查看文件是很常见的操作，根据需求不同可以有几个不同的查看方式。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#cat">cat</a></li><li><a href="#head">head</a></li><li><a href="#tail">tail</a></li><li><a href="#less">less</a></li></ul><!-- tocstop --></div><p>首先点击下载一个 demo 文件: <a href="https://raw.githubusercontent.com/wxnacy/file/master/common/nums.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/wxnacy/file/master/common/nums.txt</a></p><h2><span id="cat">cat</span><a href="#cat" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat nums.txt</span><br></pre></td></tr></table></figure><p><code>cat</code> 可以将文本全部打印到屏幕中，但是只适合短小的文件，像这个 600 行的文件，翻看起来会很麻烦，如果你刚好是看最后几行的内容还好，如果想看头几行的内容那就惨了。</p><p><strong>其他参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat -e nums.txt       <span class="comment"># 每行最后添加 $ 符号</span></span><br><span class="line">$ cat -n nums.txt       <span class="comment"># 每行开头带有行号</span></span><br></pre></td></tr></table></figure><h2><span id="head">head</span><a href="#head" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ head nums.txt</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><code>head</code> 可以查看前十行的内容，另外可以传参查看前 n 行的数据，或者前 n 个字节的数据。</p><p><strong>其他参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ head -n 15 nums.txt   <span class="comment"># 前 15 行</span></span><br><span class="line">$ head -c 90 nums.txt   <span class="comment"># 前 90 字节</span></span><br></pre></td></tr></table></figure><h2><span id="tail">tail</span><a href="#tail" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tail nums.txt</span><br><span class="line"></span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br></pre></td></tr></table></figure><p><code>tail</code> 查看末尾 10 行的数据，经常查看日志的同学肯定对它很熟悉，<code>tail -f file</code> 可以等待文件追加并且到屏幕中，动态查看新增日志非常常用。</p><p><strong>其他参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tail -n 15 nums.txt     <span class="comment"># 末尾 15 行的数据</span></span><br><span class="line">tail -c 15 nums.txt     <span class="comment"># 末尾 15 个字节的数据</span></span><br><span class="line">tail -b 1 nums.txt      <span class="comment"># 末尾 1 个 512 字节块的数据</span></span><br><span class="line">tail -q nums.txt n.txt  <span class="comment"># 检查多个文件时，进制打印标头</span></span><br><span class="line">tail -f nums.txt        <span class="comment"># 等待文件追加，并输出到标准输出中</span></span><br><span class="line">tail -r -n 10 nums.txt  <span class="comment"># 将最后 10 行，倒序显示</span></span><br></pre></td></tr></table></figure><h2><span id="less">less</span><a href="#less" class="header-anchor"></a></h2><p>最后是重头戏，<code>less</code> 是 Linux 的正统查看文件的方式，相似的还有 <code>more</code> 命令，虽然都说它不如 <code>less</code>，但是我觉得两者相差无几。</p><p><code>less</code> 可以分页显示文档，翻页的方式与 <code>vim</code> 几乎一致，如果你不了解 <code>vim</code> 的翻页机制，可以看这里 <a href="https://vim.wxnacy.com/#docs/all-key#%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8" target="_blank" rel="noopener">光标移动</a></p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/less1.gif" alt="1"></p><p>它还可以搜索文件，方式也与 <code>vim</code> 一样，输入 <code>/</code> 后输入匹配字符，使用 <code>n</code> 向后查找，使用 <code>N</code> 向前查找</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/less2.gif" alt="2"></p><p>查看多个文件时，使用 <code>:e filename</code> 切换查看文件，或者使用 <code>:n</code> 和 <code>:p</code> 向后或向前查找</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/less3.gif" alt="3"></p><p>既然它跟 <code>vim</code> 有这么多的相似点，那切换到 <code>vim</code> 模式也是很方便的，按下 <code>v</code> 即可</p><p>使用 <code>F</code> 则可以达到 <code>tail -f file</code> 的效果，等待文件的输入，<code>&lt;CTRL-C&gt;</code> 退出。</p><p>最后按下 <code>q</code> 即可退出 <code>less</code> 模式。</p><p><code>less</code> 命令模式非常常见，帮助命令 <code>man</code> 就是完全依照此模式来使用的，使用 <code>man less</code> 查看更多的使用方式。</p><p><strong>其他参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ less -N nums.txt      <span class="comment"># 显示行号</span></span><br><span class="line">$ less -m nums.txt      <span class="comment"># 显示查看的百分比进度</span></span><br><span class="line">$ less -e nums.txt      <span class="comment"># 查看到文档末尾时，自动退出</span></span><br><span class="line">$ less +20 nums.txt     <span class="comment"># 从第 20 行开始查看</span></span><br></pre></td></tr></table></figure><p>其它的命令搭配 <code>less</code> 管道输入模式可以起到很好的效果。</p><p><strong>分页显示当前所有进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | less</span><br></pre></td></tr></table></figure><p><strong>分页显示历史命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">history</span> | less</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 中查看文件是很常见的操作，根据需求不同可以有几个不同的查看方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 二分查找模块 bisect</title>
    <link href="http://wxnacy.com/2019/06/07/python-bisect/"/>
    <id>http://wxnacy.com/2019/06/07/python-bisect/</id>
    <published>2019-06-07T12:50:03.000Z</published>
    <updated>2019-06-07T12:50:03.243Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中 bisect 模块的作用是将一个数字插入到一个排好序的数组中，而不影响数组原来的排序。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>换句话说是找到一个数字在一个排序数组中应该出现的位置，而它采用的是二分查找法。</p><p>既然是二分查找法首先要准备一个排好序的数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>我们希望知道再插入一个 <code>4</code>，应该出现在什么位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bisect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.bisect(a, <span class="number">4</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>bisect()</code> 方法只是返回一个索引不会更改数组，另外还有 <code>bisect_right()</code> 和 <code>bisect_left()</code> 两个方法，<code>bisect_right()</code> 等同于 <code>bisect()</code> 都是从数组右侧开始查找，而 <code>bisect()</code> 是从左侧开始查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.bisect_left(a, <span class="number">4</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果想要直接插入这个数字呢？可以用 <code>insort()</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.insort(a, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>这个方法没有返回值，是在原数组上做的修改，另外也还有 <code>insort_left()</code> 和 <code>insort_right()</code>，他们的作用相信你已经明白了。</p><p>说到这的话，其实标题说 <code>bisect</code> 是二分查找模块有点不准确，因为当数组中没有该数字时，<code>bisect.bisect()</code> 方法也会返回一个有效索引。所以如果我们想把它当做二分查找法的话，还需要做一些判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(nums, n)</span>:</span></span><br><span class="line">    i = bisect.bisect_left(nums, n)</span><br><span class="line">    <span class="keyword">if</span> i &gt;= len(nums):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> nums[i] == n:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>最后要说的是，数组只能是正序，如果是倒序该模块不生效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.insort_left(a, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中 bisect 模块的作用是将一个数字插入到一个排好序的数组中，而不影响数组原来的排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>cURL 如何只返回状态码 status code</title>
    <link href="http://wxnacy.com/2019/06/06/curl-return-code/"/>
    <id>http://wxnacy.com/2019/06/06/curl-return-code/</id>
    <published>2019-06-06T00:15:42.000Z</published>
    <updated>2019-06-06T00:48:28.816Z</updated>
    
    <content type="html"><![CDATA[<p>在写一些 Shell 测试用例时需要检测 url 的状态是否为 <code>200</code>，这时如果能只获取它的状态码是最理想的，cURL 可以很方便的实现。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p><code>-w</code> 可以格式化输出 reponse 的返回结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl -w <span class="string">"%&#123;http_code&#125;"</span> https://baidu.com</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=<span class="string">"white"</span>&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;bfe/1.0.8.18&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">302%</span><br></pre></td></tr></table></figure><p>访问带有跳转性质的网站，我们还需要加上 <code>-L</code> 做进一步跳转，同时为了避免当资源过大请求缓慢的情况，通过 <code>-I</code> 只返回头信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ curl -IL -w <span class="string">"%&#123;http_code&#125;"</span> https://baidu.com</span><br><span class="line"></span><br><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: bfe/1.0.8.18</span><br><span class="line">Date: Thu, 06 Jun 2019 00:25:02 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 161</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://www.baidu.com/</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 277</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Thu, 06 Jun 2019 00:25:05 GMT</span><br><span class="line">Etag: <span class="string">"575e1f60-115"</span></span><br><span class="line">Last-Modified: Mon, 13 Jun 2016 02:50:08 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Server: bfe/1.0.8.18</span><br><span class="line"></span><br><span class="line">200%</span><br></pre></td></tr></table></figure><p>然后隐藏掉打印信息，将打印的结果输出到 <code>/dev/null</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -IL -w <span class="string">"%&#123;http_code&#125;"</span> -o /dev/null https://baidu.com</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0   161    0     0    0     0      0      0 --:--:--  0:00:03 --:--:--     0</span><br><span class="line">  0   277    0     0    0     0      0      0 --:--:--  0:00:03 --:--:--     0</span><br><span class="line">200%</span><br></pre></td></tr></table></figure><p>竟然还有多余信息，继续使用 <code>-s</code> 不显示进度和错误信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sIL -w <span class="string">"%&#123;http_code&#125;"</span> -o /dev/null https://baidu.com</span><br><span class="line">200%</span><br></pre></td></tr></table></figure><p>最后的最后，默认输出是不换行的，也就是会带有一个 <code>%</code> 符号，我们有两种方式去掉它</p><p><strong>输出换行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sIL -w <span class="string">"%&#123;http_code&#125;\n"</span> -o /dev/null https://baidu.com</span><br><span class="line">200</span><br></pre></td></tr></table></figure><p><strong>使用 echo</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(curl -sIL -w <span class="string">"%&#123;http_code&#125;"</span> -o /dev/null https://baidu.com)</span><br><span class="line">200</span><br></pre></td></tr></table></figure><p><code>-w</code> 的一些其它参数，没有注明的可以自行测试下</p><ul><li><code>url_effective</code></li><li><code>http_code</code> 状态码</li><li><code>http_connect</code></li><li><code>time_total</code> 请求总用时</li><li><code>time_namelookup</code> DNS 域名解析的时候，就是把 <a href="https://baidu.com" target="_blank" rel="noopener">https://baidu.com</a> 转换成 ip 地址的过程</li><li><code>time_connect</code> TCP 连接建立的时间，就是三次握手的时间</li><li><code>time_appconnect</code> SSL/SSH 等上层协议建立连接的时间，比如 connect/handshake 的时间</li><li><code>time_redirect</code> 从开始到最后一个请求事务的时间</li><li><code>time_pretransfer</code> 从请求开始到响应开始传输的时间</li><li><code>time_starttransfer</code> 从请求开始到第一个字节将要传输的时间</li><li><code>size_download</code></li><li><code>size_upload</code></li><li><code>size_header</code></li><li><code>size_request</code></li><li><code>speed_download</code></li><li><code>speed_upload</code></li><li><code>content_type</code></li><li><code>num_connects</code></li><li><code>num_redirects</code></li><li><code>ftp_entry_path</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写一些 Shell 测试用例时需要检测 url 的状态是否为 &lt;code&gt;200&lt;/code&gt;，这时如果能只获取它的状态码是最理想的，cURL 可以很方便的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://wxnacy.com/tags/http/"/>
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置有爱心的 404</title>
    <link href="http://wxnacy.com/2019/06/04/lovely-404/"/>
    <id>http://wxnacy.com/2019/06/04/lovely-404/</id>
    <published>2019-06-04T13:39:02.000Z</published>
    <updated>2019-06-04T13:39:02.534Z</updated>
    
    <content type="html"><![CDATA[<p>之前我是不太在乎 404 页面的，一是我基本不会修改网页的地址，搜索过来的时候都能准确访问。二是我默认看我博客的都是技术人员，他们可以很容易的找到首页地址，虽然我的博客可能不会让他们有那么大的动力这么干。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>但是，今天我想配置上 404 的页面，一个有爱心的 404 页面</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/404-2_709.png" alt="1"></p><p>作为一名老父亲，看到这些丢失的孩子，心里是感觉被揪了一下的。如果你也想在自己的站点加一个这样的 404 页面，可以接着看下去。</p><p>这个页面是由益云提供的，这是他们的网址 <a href="https://yibo.iyiyun.com/Home/Index/web404" target="_blank" rel="noopener">https://yibo.iyiyun.com/Home/Index/web404</a></p><p>点击进入后根据自己的需求选择完成后，点击生成代码即可</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/404-3_1285.png" alt="2"></p><p>复制生成的代码，黏贴你自己的 <code>404.html</code> 的 <code>body</code> 标签中即可。</p><p>然后怎么在网站中生效呢？如果你之前配置过，那现在刷新页面就已经生效了。如果像我一样没有配置过，那只要在 Nginx 中做一些小改动即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    error_page 404 404.html;</span><br><span class="line"></span><br><span class="line">    location /404.html &#123;</span><br><span class="line">        # 配置 404.html 的目录</span><br><span class="line">        root   /www/wxnacy.github.io/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你的 <code>server</code> 标签中也做如上配置即可，<code>root</code> 改成你存放 <code>404.html</code> 页面的目录</p><p><strong>重新加载配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -t          <span class="comment"># 测试配置是否通过</span></span><br><span class="line">$ nginx -s reload   <span class="comment"># 重新加载</span></span><br></pre></td></tr></table></figure><p>再次访问网站的 404 页面即可生效。</p><p>需要注意的一点，他默认提供的代码中，给的是 <code>http://</code> 开头的网址，如果你的网站是 <code>https</code> 的话，那会请求失败，所以需要手动改成 <code>https</code>。</p><p>说到公益 404，印象比较深的是微信公众号里的 web 页面，如果网页提供者返回了 404 状态，那微信就会强制显示这个公益的 404 页面，而提供者的页面就会被覆盖。虽然这是件有爱心的事，但做法却有点耍流氓，你也不能强制别人献爱心啊。</p><p>最后呢，希望我的一点小小的举动，可以给身处黑暗中的孩子一点莹莹星火，让他们可以早点找到家的方向。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我是不太在乎 404 页面的，一是我基本不会修改网页的地址，搜索过来的时候都能准确访问。二是我默认看我博客的都是技术人员，他们可以很容易的找到首页地址，虽然我的博客可能不会让他们有那么大的动力这么干。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://wxnacy.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>MkDocs 使用 Markdown 管理项目文档</title>
    <link href="http://wxnacy.com/2019/06/03/mkdocs/"/>
    <id>http://wxnacy.com/2019/06/03/mkdocs/</id>
    <published>2019-06-03T00:54:17.000Z</published>
    <updated>2019-06-03T00:54:18.014Z</updated>
    
    <content type="html"><![CDATA[<p>坚持写博客也两年多了，使用 hexo 的一个很大的问题就是不太方便写系列性的文章，属于比较随性的想起什么写什么，最近发现了 <a href="https://github.com/mkdocs/mkdocs" target="_blank" rel="noopener">mkdocs</a>，同样的使用 Markdown 格式编写文档，写系列文章很合适。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#an-zhuang-shi-yong">安装使用</a></li><li><a href="#pei-zhi">配置</a></li></ul><!-- tocstop --></div><p>它的官网就是用 mkdocs 搭建的。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mkdocs2_1058.png" alt="2"></p><p>如果这个界面不熟悉的话，看下面的截图</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mkdocs1_1102.png" alt="1"></p><p>这是它为著名的 <a href="https://readthedocs.org/" target="_blank" rel="noopener">readthedocs</a> 提供的主题，是不是很亲切。</p><p>mkdocs 使用配置起来都很简单，它是由 Python 编写的，这是让我亲切的另一个原因。</p><h2><span id="an-zhuang-shi-yong">安装使用</span><a href="#an-zhuang-shi-yong" class="header-anchor"></a></h2><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install mkdocs</span><br></pre></td></tr></table></figure><p><strong>生成项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdocs new my-project</span><br><span class="line">$ <span class="built_in">cd</span> my-project</span><br></pre></td></tr></table></figure><p>项目的结构如下</p><p><img src="https://www.mkdocs.org/img/initial-layout.png" alt="3"></p><p><strong>启动服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdocs serve</span><br><span class="line">INFO    -  Building documentation...</span><br><span class="line">INFO    -  Cleaning site directory</span><br><span class="line">[I 160402 15:50:43 server:271] Serving on http://127.0.0.1:8000</span><br><span class="line">[I 160402 15:50:43 handlers:58] Start watching changes</span><br><span class="line">[I 160402 15:50:43 handlers:60] Start detecting changes</span><br></pre></td></tr></table></figure><p>mkdocs 会启动一个端口为 8000 的服务，效果如下</p><p><img src="https://www.mkdocs.org/img/screenshot.png" alt="4"></p><p>网页首页默认打开的是文档 <code>docs/index.md</code>，修改文档内容，网页会自动刷新到最新状态。</p><p><strong>生成静态文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdocs build</span><br></pre></td></tr></table></figure><p>随后根目录下会生成一个 <code>site</code> 文件夹，内容是文档的静态网页，使用 Nginx 代理即可访问。</p><h2><span id="pei-zhi">配置</span><a href="#pei-zhi" class="header-anchor"></a></h2><p>mkdocs 的全部配置都在 <code>mkdocs.yml</code> 中，一个最简单的配置如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site_name:</span> <span class="string">MkLorum</span>      <span class="comment"># 站点名称</span></span><br><span class="line"><span class="attr">nav:</span>                    <span class="comment"># 文档目录</span></span><br><span class="line"><span class="attr">    - Home:</span> <span class="string">index.md</span></span><br><span class="line"><span class="attr">    - About:</span> <span class="string">about.md</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">readthedocs</span>      <span class="comment"># 主题</span></span><br></pre></td></tr></table></figure><p><img src="https://www.mkdocs.org/img/readthedocs.png" alt="5"></p><p>另外还有一些常用配置</p><ul><li><code>repo_url</code> 页面会生成一个链接，指向仓库地址，可以是 <code>GitHub, Bitbucket, GitLab</code> 等</li><li><code>site_description</code> 网站的描述</li><li><code>copyright</code> 版权信息</li><li><code>google_analytics</code> 配置 <code>Google analytics</code> 信息，接收一个数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google_analytics: [&apos;UA-36723568-3&apos;, &apos;mkdocs.org&apos;]</span><br></pre></td></tr></table></figure><ul><li><code>docs_dir</code> 文档的存放目录，默认为 <code>docs</code></li><li><code>site_dir</code> 生成静态网页的存放目录，默认为 <code>site</code></li><li><code>dev_addr</code> 使用 <code>mkdocs serve</code> 时启动的地址和端口号，默认 <code>127.0.0.1:8000</code></li></ul><p>更多的配置详见<a href="https://www.mkdocs.org/user-guide/configuration/" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;坚持写博客也两年多了，使用 hexo 的一个很大的问题就是不太方便写系列性的文章，属于比较随性的想起什么写什么，最近发现了 &lt;a href=&quot;https://github.com/mkdocs/mkdocs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mkdocs&lt;/a&gt;，同样的使用 Markdown 格式编写文档，写系列文章很合适。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://wxnacy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>重新学 Java 系列：数组</title>
    <link href="http://wxnacy.com/2019/05/29/java-array/"/>
    <id>http://wxnacy.com/2019/05/29/java-array/</id>
    <published>2019-05-29T01:47:05.000Z</published>
    <updated>2019-05-29T02:36:38.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个是一个系列阅读，关于为什么重新学习，我在文章 <a href="/2018/12/29/java-renew-why/">重新学 Java 系列：新系列、新开始</a>(<a href="https://wxnacy.com/2018/12/29/java-renew-why/">https://wxnacy.com/2018/12/29/java-renew-why/</a>) 中有提到，这个系列是在有 Java 基础的情况下，重新学习讨论一下以前可能忽略掉，或者没理解的知识细节，我想要永远在学习的路上。</p></blockquote><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#sheng-ming">声明</a></li><li><a href="#ding-yi">定义</a></li><li><a href="#bian-li">遍历</a></li><li><a href="#fang-fa">方法</a></li><li><a href="#can-kao">参考</a></li></ul><!-- tocstop --></div><p>已经习惯了 Python 的列表对象，再回来看 Java 的数组和列表很是不适，这种不适已经上升到了生理反应，我为什么要重新学 Java？我是谁？我在哪？</p><p>Java 中数组是用来存储<strong><em>固定大小</em></strong>的<strong><em>同类型</em></strong>元素。</p><h2><span id="sheng-ming">声明</span><a href="#sheng-ming" class="header-anchor"></a></h2><p><code>int</code> 类型数组有两种声明方式 <code>int[] varName</code> 或者 <code>int varName[]</code>，一般建议使用第一种声明方式。后者来源于 <code>c/c++</code>，是为了让 <code>c/c++</code> 程序员快速理解 Java。</p><h2><span id="ding-yi">定义</span><a href="#ding-yi" class="header-anchor"></a></h2><p>有三种定义方式</p><p><strong>静态初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>静态初始化简化方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] b = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>静态初始化不能指定元素个数，或者说初始化后元素个数已经固定了，不需要指定。</p><p><strong>动态初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>动态初始化后，数组每个元素会赋值当前类型的默认值，分别如下所以：</p><table><thead><tr><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>整数类型（byte、short、int、long）</td><td>0</td></tr><tr><td>浮点类型（float、double）</td><td>0.0</td></tr><tr><td>字符类型（char）</td><td>‘\u0000’</td></tr><tr><td>布尔类型（boolean）</td><td>false</td></tr><tr><td>引用类型（类、接口、数组）</td><td>null</td></tr></tbody></table><h2><span id="bian-li">遍历</span><a href="#bian-li" class="header-anchor"></a></h2><p>两种方式 <code>for</code> 和 <code>forEach</code></p><p><strong>for</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>forEach</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> n: nums ) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="fang-fa">方法</span><a href="#fang-fa" class="header-anchor"></a></h2><p>数组本身不提供方法，只有一个变量 <code>length</code> 用来获取数组的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = nums.length</span><br></pre></td></tr></table></figure><p>记得当年刚开始学习 Java 时，总是跟列表的 <code>size()</code> 方法搞混，不知道什么时候用 <code>length</code>，什么时候用 <code>size()</code>。现在看来只需要记住，数组的大小是不可变的，所以使用变量 <code>length</code> 即可获取数组大小。而列表是可变的，所以需要使用方法 <code>size()</code> 动态获取大小。</p><p><code>java.util.Arrays</code> 类提供了操作数组的方法，都是静态方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public static void sort(Object[] a)</td><td>排序数组，升序</td></tr><tr><td>public static int binarySearch(Object[] a, Object key)</td><td>使用二分搜索来搜索给定元素，数组需要先排序，返回索引</td></tr><tr><td>public static boolean equals(Object[] a, Object[] a2)</td><td>比较数组是否相同，返回 boolean 类型</td></tr><tr><td>public static void fill(Object[] a, Object val)</td><td>给数组的所有元素指定某个值</td></tr></tbody></table><h2><span id="can-kao">参考</span><a href="#can-kao" class="header-anchor"></a></h2><ul><li><a href="https://www.runoob.com/java/java-array.html" target="_blank" rel="noopener">Java 数组</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个是一个系列阅读，关于为什么重新学习，我在文章 &lt;a href=&quot;/2018/12/29/java-renew-why/&quot;&gt;重新学 Java 系列：新系列、新开始&lt;/a&gt;(&lt;a href=&quot;https://wxnacy.com/2018/12/29/java-renew-why/&quot;&gt;https://wxnacy.com/2018/12/29/java-renew-why/&lt;/a&gt;) 中有提到，这个系列是在有 Java 基础的情况下，重新学习讨论一下以前可能忽略掉，或者没理解的知识细节，我想要永远在学习的路上。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://wxnacy.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>异或运算及应用</title>
    <link href="http://wxnacy.com/2019/05/28/what-is-xor/"/>
    <id>http://wxnacy.com/2019/05/28/what-is-xor/</id>
    <published>2019-05-28T06:04:30.000Z</published>
    <updated>2019-05-28T06:21:41.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>异或，英文为exclusive OR，缩写成xor，异或是一个数学运算符。它应用于逻辑运算</p></blockquote><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>异或也叫半加运算，其运算法则相当于不带进位的二进制加法，它的运算规则为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制的比较位相同则结果返回 0，不同则为 1</span><br></pre></td></tr></table></figure><p>运算符有几种表示方式</p><table><thead><tr><th>名称</th><th>符号</th></tr></thead><tbody><tr><td>数学符号</td><td>⊕</td></tr><tr><td>英文简称</td><td>xor</td></tr><tr><td>程序符号</td><td>^</td></tr></tbody></table><p><strong>运算推导</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 ^ 8 = 2</span><br></pre></td></tr></table></figure><p>单看这个表达式比较费解，我们转成二进制来看下</p><table><thead><tr><th>-</th><th>相同</th><th>不同</th><th>相同</th></tr></thead><tbody><tr><td>5</td><td>1</td><td>0</td><td>1</td></tr><tr><td>8</td><td>1</td><td>1</td><td>1</td></tr><tr><td>5 ^ 8</td><td>0</td><td>1</td><td>0</td></tr><tr><td>2</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>异或在开发中的应用可以参看一道算法题 <a href="/leetcode/problems/136-single-number/">只出现一次的数字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;异或，英文为exclusive OR，缩写成xor，异或是一个数学运算符。它应用于逻辑运算&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://wxnacy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python list 对象一些方法的时间复杂度</title>
    <link href="http://wxnacy.com/2019/05/27/python-list-time-complexity/"/>
    <id>http://wxnacy.com/2019/05/27/python-list-time-complexity/</id>
    <published>2019-05-27T09:07:51.000Z</published>
    <updated>2019-05-27T09:36:33.810Z</updated>
    
    <content type="html"><![CDATA[<p>列举下 Python list 对象常用方法的时间复杂度</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><table><thead><tr><th>方法</th><th>时间复杂度</th></tr></thead><tbody><tr><td>list[i]</td><td>O(1)</td></tr><tr><td>list[i] = 1</td><td>O(1)</td></tr><tr><td>list[i:j]</td><td>O(k)  k = j - i</td></tr><tr><td>list[i:k] = list()</td><td>O(n + k)</td></tr><tr><td>list.index(item)</td><td>O(n)</td></tr><tr><td>list.append(item)</td><td>O(1)</td></tr><tr><td>list.insert(i, item)</td><td>O(n)</td></tr><tr><td>list.pop()</td><td>O(1)</td></tr><tr><td>list.pop(i)</td><td>O(n) 假如推出的是第一个元素，那么数组所有的元素都要重新计算坐标</td></tr><tr><td>del list[i]</td><td>O(n)</td></tr><tr><td>item in list</td><td>O(n)</td></tr><tr><td>list.reverse()</td><td>O(n)</td></tr><tr><td>list.sort()</td><td>O(n logn)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列举下 Python list 对象常用方法的时间复杂度&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 跳转其他页面</title>
    <link href="http://wxnacy.com/2019/05/25/js-href/"/>
    <id>http://wxnacy.com/2019/05/25/js-href/</id>
    <published>2019-05-25T01:49:45.000Z</published>
    <updated>2019-05-25T01:51:51.228Z</updated>
    
    <content type="html"><![CDATA[<p>几种常见的页面跳转方式</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span> type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       window.location.href=<span class="string">"login.jsp?backurl="</span>+window.location.href;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</span><br><span class="line">    alert(<span class="string">"返回"</span>);</span><br><span class="line">    window.history.back(-<span class="number">1</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</span><br><span class="line">    window.navigate(<span class="string">"top.jsp"</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"JavaScript"</span>&gt;</span><br><span class="line">    self.location=’top.htm’;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</span><br><span class="line">    alert(<span class="string">"非法访问！"</span>);</span><br><span class="line">    top.location=’xx.jsp’;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种常见的页面跳转方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://wxnacy.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Git blame 查看代码是谁写的</title>
    <link href="http://wxnacy.com/2019/05/21/git-blame/"/>
    <id>http://wxnacy.com/2019/05/21/git-blame/</id>
    <published>2019-05-21T10:30:27.000Z</published>
    <updated>2019-05-21T10:30:27.125Z</updated>
    
    <content type="html"><![CDATA[<p><code>git blame</code> 命令可以查看每行代码的提交详情，包括提交人、时间等信息，成熟的编辑器如 Sublime、Jetbrains 等都集成了这个功能，使用起来非常简单，今天我们来关注下这个命令本身，毕竟在服务器上我们可不能安装这些编辑器。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame1_874.png" alt="1"></p><p>得到的结果，每列分别为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提交 sha1   用户名 提交时间                    行数    代码</span><br><span class="line">...</span><br><span class="line">39a22489    (wxnacy 2018-07-26 19:01:55 +0800  6)      def filter(<span class="built_in">source</span>: dict, *args, **kwargs):</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这是最简单的语法，我们查看文件的每一行代码的最后提交详情，不过这通常不是我们的目的，一般只需要看某一行或某个范围行，这时可以使用 <code>-L</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L &lt;start&gt;[,&lt;end&gt;]</span><br></pre></td></tr></table></figure><p><strong>查看第 10 行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,10</span><br></pre></td></tr></table></figure><p><strong>查看第 10 行及以后</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10</span><br></pre></td></tr></table></figure><p><strong>查看第 10 到 20 行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,20</span><br></pre></td></tr></table></figure><p><code>end</code> 也可以加上正负符号，比如</p><p><strong>查看 10 行以后 5 行的数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,+5</span><br></pre></td></tr></table></figure><p><strong>查看 10 行以前 5 行的数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 10,-5</span><br></pre></td></tr></table></figure><p><code>start</code> 和 <code>end</code> 又不止于数字，它还可以是个正则表达式，如果 <code>start</code> 为正则表达式，则会匹配到 <code>end</code> 行，如果 <code>end</code> 为正则表达式，则从 <code>start</code> 行开始匹配，到匹配行截止，如果 <code>start</code> 或者 <code>end</code> 其中之一有值，则从匹配行开始显示全部内容。</p><p><strong>查看正则匹配到 20 行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L /filter/,20</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame2_872.png" alt="2"></p><p><strong>查看 3 行到正则匹配行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L 3,/filter/</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame3.png" alt="3"></p><p><code>-L</code> 参数的功能还不止这些，有个更智能的方式是直接通过函数名来查看一个区域块的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L:&lt;func_name&gt;</span><br></pre></td></tr></table></figure><p>这是很方便的能力，不过只能识别文件最外层的方法名和类名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;filename&gt; -L:filter</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/git-blame4.png" alt="4"></p><p>完整参数列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">usage: git blame [&lt;options&gt;] [&lt;rev-opts&gt;] [&lt;rev&gt;] [--] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">    &lt;rev-opts&gt; are documented <span class="keyword">in</span> git-rev-list(1)</span><br><span class="line"></span><br><span class="line">    --incremental         Show blame entries as we find them, incrementally</span><br><span class="line">    -b                    Show blank SHA-1 <span class="keyword">for</span> boundary commits (Default: off)</span><br><span class="line">    --root                Do not treat root commits as boundaries (Default: off)</span><br><span class="line">    --show-stats          Show work cost statistics</span><br><span class="line">    --progress            Force progress reporting</span><br><span class="line">    --score-debug         Show output score <span class="keyword">for</span> blame entries</span><br><span class="line">    -f, --show-name       Show original filename (Default: auto)</span><br><span class="line">    -n, --show-number     Show original linenumber (Default: off)</span><br><span class="line">    -p, --porcelain       Show <span class="keyword">in</span> a format designed <span class="keyword">for</span> machine consumption</span><br><span class="line">    --line-porcelain      Show porcelain format with per-line commit information</span><br><span class="line">    -c                    Use the same output mode as git-annotate (Default: off)</span><br><span class="line">    -t                    提交时间显示为时间戳，默认关闭</span><br><span class="line">    -l                    显示完整的 commit sha1，默认关闭</span><br><span class="line">    -s                    Suppress author name and timestamp (Default: off)</span><br><span class="line">    -e, --show-email      显示提交用户的邮箱，默认关闭</span><br><span class="line">    -w                    Ignore whitespace differences</span><br><span class="line">    --indent-heuristic    Use an experimental heuristic to improve diffs</span><br><span class="line">    --minimal             Spend extra cycles to find better match</span><br><span class="line">    -S &lt;file&gt;             Use revisions from &lt;file&gt; instead of calling git-rev-list</span><br><span class="line">    --contents &lt;file&gt;     Use &lt;file&gt;<span class="string">'s contents as the final image</span></span><br><span class="line"><span class="string">    -C[&lt;score&gt;]           Find line copies within and across files</span></span><br><span class="line"><span class="string">    -M[&lt;score&gt;]           Find line movements within and across files</span></span><br><span class="line"><span class="string">    -L &lt;n,m&gt;              Process only line range n,m, counting from 1</span></span><br><span class="line"><span class="string">    --abbrev[=&lt;n&gt;]        use &lt;n&gt; digits to display SHA-1s</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://git-scm.com/docs/git-blame" target="_blank" rel="noopener">git-blame</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;git blame&lt;/code&gt; 命令可以查看每行代码的提交详情，包括提交人、时间等信息，成熟的编辑器如 Sublime、Jetbrains 等都集成了这个功能，使用起来非常简单，今天我们来关注下这个命令本身，毕竟在服务器上我们可不能安装这些编辑器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://wxnacy.com/tags/git/"/>
    
  </entry>
  
</feed>
