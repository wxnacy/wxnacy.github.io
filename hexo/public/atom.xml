<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-04-13T02:27:32.442Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux tar 打包命令</title>
    <link href="http://wxnacy.com/2019/04/13/linux-tar/"/>
    <id>http://wxnacy.com/2019/04/13/linux-tar/</id>
    <published>2019-04-13T01:52:28.000Z</published>
    <updated>2019-04-13T02:27:32.442Z</updated>
    
    <content type="html"><![CDATA[<p>在 Github 打标签的时候，它会自动归档两种压缩格式的文件 <code>.zip</code> 和 <code>.tar.gz</code>，如图</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/tar.png" alt="tar"></p><p><code>zip</code> 格式的压缩和解压可以参看我这篇文章 <a href="/2018/09/19/zip-unzip/">Linux zip 和 unzip 命令</a></p><p>今天我主要来说一下 <code>tar</code> 打包命令。</p><div class="toc"><!-- toc --><ul><li><a href="#da-bao-jie-bao">打包解包</a></li><li><a href="#ya-suo-jie-ya-gz-ge-shi">压缩解压 .gz 格式</a></li><li><a href="#ya-suo-jie-ya-bz2-ge-shi">压缩解压 .bz2 格式</a></li><li><a href="#geng-duo-yu-fa">更多语法</a></li></ul><!-- tocstop --></div><p>首先要强调的是 <code>tar</code> 是打包命令，本身不压缩，需要调用 <code>gzip</code> 压缩命令才可以生成 <code>.gz</code> 后缀的压缩文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tar cvf pm2.log.tar pm2.log       <span class="comment"># 打包</span></span><br><span class="line">$ tar zcvf pm2.log.tar.gz pm2.log   <span class="comment"># 打包，并压缩</span></span><br><span class="line">$ zip pm2.zip pm2.log               <span class="comment"># 使用 zip 压缩</span></span><br><span class="line">$ ll</span><br><span class="line">-rw-r--r--    1 wxnacy  staff  259615701 Apr 13 06:37 pm2.log</span><br><span class="line">-rw-r--r--    1 wxnacy  staff  259617280 Apr 13 09:47 pm2.log.tar</span><br><span class="line">-rw-r--r--    1 wxnacy  staff    7746015 Apr 13 09:48 pm2.log.tar.gz</span><br><span class="line">-rw-r--r--    1 wxnacy  staff    7763656 Apr 13 09:51 pm2.zip</span><br></pre></td></tr></table></figure><p>从结果来看，只是打包命令的话，不但不压缩，本身比原文件还要大一点，调用压缩命令后，压缩比很明显，并且比 <code>zip</code> 的压缩比要高，所以在文件压缩时，我们可以优先使用 <code>tar</code> 打包并压缩。</p><h2><span id="da-bao-jie-bao">打包解包</span><a href="#da-bao-jie-bao" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar cvf &lt;filename&gt;.tar &lt;filename|dirname&gt;     <span class="comment"># 打包</span></span><br><span class="line">$ tar xvf &lt;filename&gt;.tar                        <span class="comment"># 解包</span></span><br></pre></td></tr></table></figure><h2><span id="ya-suo-jie-ya-gz-ge-shi">压缩解压 .gz 格式</span><a href="#ya-suo-jie-ya-gz-ge-shi" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar zcvf &lt;filename&gt;.tar.gz &lt;filename|dirname&gt;     <span class="comment"># 压缩</span></span><br><span class="line">$ tar zxvf &lt;filename&gt;.tar.gz                        <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><h2><span id="ya-suo-jie-ya-bz2-ge-shi">压缩解压 .bz2 格式</span><a href="#ya-suo-jie-ya-bz2-ge-shi" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar jcvf &lt;filename&gt;.tar.bz2 &lt;filename|dirname&gt;     <span class="comment"># 压缩</span></span><br><span class="line">$ tar jxvf &lt;filename&gt;.tar.bz2                        <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><h2><span id="geng-duo-yu-fa">更多语法</span><a href="#geng-duo-yu-fa" class="header-anchor"></a></h2><p>必要参数有如下：</p><ul><li><code>-A</code> 新增压缩文件到已存在的压缩</li><li><code>-B</code> 设置区块大小</li><li><code>-c</code> 建立新的压缩文件</li><li><code>-d</code> 记录文件的差别</li><li><code>-r</code> 添加文件到已经压缩的文件</li><li><code>-u</code> 添加改变了和现有的文件到已经存在的压缩文件</li><li><code>-x</code> 从压缩的文件中提取文件</li><li><code>-t</code> 显示压缩文件的内容</li><li><code>-z</code> 支持gzip解压文件</li><li><code>-j</code> 支持bzip2解压文件</li><li><code>-Z</code> 支持compress解压文件</li><li><code>-v</code> 显示操作过程</li><li><code>-l</code> 文件系统边界设置</li><li><code>-k</code> 保留原有文件不覆盖</li><li><code>-m</code> 保留文件不被覆盖</li><li><code>-W</code> 确认压缩文件的正确性</li></ul><p>可选参数如下：</p><ul><li><code>-b</code> 设置区块数目</li><li><code>-C</code> 切换到指定目录</li><li><code>-f</code> 指定压缩文件</li><li><code>--help</code> 显示帮助信息</li><li><code>--version</code> 显示版本信息</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Github 打标签的时候，它会自动归档两种压缩格式的文件 &lt;code&gt;.zip&lt;/code&gt; 和 &lt;code&gt;.tar.gz&lt;/code&gt;，如图&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 如何打印不换行进度条</title>
    <link href="http://wxnacy.com/2019/04/12/python-single-line-progress/"/>
    <id>http://wxnacy.com/2019/04/12/python-single-line-progress/</id>
    <published>2019-04-12T14:36:10.000Z</published>
    <updated>2019-04-12T14:48:11.317Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中打印不换行进度条，可以说是简单透顶，使用内置方法 <code>print</code> 直接打印即可</p><a id="more"></a><p>先看下效果</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/python_progress.gif" alt="image"></p><p>大部分时间我们使用 <code>print</code> 是不带多与参数的，但是它有个带有默认值的参数 <code>end</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">''</span>, end=<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p>默认情况下 <code>end=&#39;\n&#39;</code>，表示打印完毕后进行换行。</p><p><code>\r</code> 则表示将光标移动到行首</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">''</span>, end=<span class="string">'\r'</span>)     <span class="comment"># 简而言之，这样就可以起到不换行的效果</span></span><br></pre></td></tr></table></figure><p>完整代码请见 <a href="https://github.com/wxnacy/study/blob/master/python/simple/single_line_progress.py" target="_blank" rel="noopener">single_line_progress.py</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中打印不换行进度条，可以说是简单透顶，使用内置方法 &lt;code&gt;print&lt;/code&gt; 直接打印即可&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 操作 ini 配置文件</title>
    <link href="http://wxnacy.com/2019/04/11/python-configparser/"/>
    <id>http://wxnacy.com/2019/04/11/python-configparser/</id>
    <published>2019-04-11T03:25:49.000Z</published>
    <updated>2019-04-11T03:25:49.336Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中使用 <code>configparser</code> 模块来操作 ini 文件。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>假如想要生成 <code>example.ini</code> 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ServerAliveInterval = 45</span><br><span class="line">Compression = yes</span><br><span class="line">CompressionLevel = 9</span><br><span class="line">ForwardX11 = yes</span><br><span class="line"></span><br><span class="line">[bitbucket.org]</span><br><span class="line">User = hg</span><br><span class="line"></span><br><span class="line">[topsecret.server.com]</span><br><span class="line">Port = 50022</span><br><span class="line">ForwardX11 = no</span><br></pre></td></tr></table></figure><p><strong>写入操作</strong></p><p><code>configparser.ConfigParser()</code> 方法生成实例，配置和读取内容都可以按照 <code>dict</code> 的方式进行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> configparser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config = configparser.ConfigParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'DEFAULT'</span>] = &#123;<span class="string">'ServerAliveInterval'</span>: <span class="string">'45'</span>,</span><br><span class="line"><span class="meta">... </span>                     <span class="string">'Compression'</span>: <span class="string">'yes'</span>,</span><br><span class="line"><span class="meta">... </span>                     <span class="string">'CompressionLevel'</span>: <span class="string">'9'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>] = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>][<span class="string">'User'</span>] = <span class="string">'hg'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'topsecret.server.com'</span>] = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret = config[<span class="string">'topsecret.server.com'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'Port'</span>] = <span class="string">'50022'</span>     <span class="comment"># mutates the parser</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'ForwardX11'</span>] = <span class="string">'no'</span>  <span class="comment"># same here</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'DEFAULT'</span>][<span class="string">'ForwardX11'</span>] = <span class="string">'yes'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'example.ini'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> configfile:</span><br><span class="line"><span class="meta">... </span>  config.write(configfile)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>读取操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>config = configparser.ConfigParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.sections()</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.read(<span class="string">'example.ini'</span>)</span><br><span class="line">[<span class="string">'example.ini'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.sections()</span><br><span class="line">[<span class="string">'bitbucket.org'</span>, <span class="string">'topsecret.server.com'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'bitbucket.org'</span> <span class="keyword">in</span> config</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'bytebong.com'</span> <span class="keyword">in</span> config</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>][<span class="string">'User'</span>]</span><br><span class="line"><span class="string">'hg'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'DEFAULT'</span>][<span class="string">'Compression'</span>]</span><br><span class="line"><span class="string">'yes'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret = config[<span class="string">'topsecret.server.com'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'ForwardX11'</span>]</span><br><span class="line"><span class="string">'no'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'Port'</span>]</span><br><span class="line"><span class="string">'50022'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> config[<span class="string">'bitbucket.org'</span>]:</span><br><span class="line"><span class="meta">... </span>    print(key)</span><br><span class="line">user</span><br><span class="line">compressionlevel</span><br><span class="line">serveraliveinterval</span><br><span class="line">compression</span><br><span class="line">forwardx11</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>][<span class="string">'ForwardX11'</span>]</span><br><span class="line"><span class="string">'yes'</span></span><br></pre></td></tr></table></figure><p><strong>修改操作</strong></p><p>因为此处配置的写入是覆盖模式，所以如果想要修改文件，需要判断下文件是否存在，存在的话，先加载文件内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">config</span><span class="params">(filepath, section, **data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    filepath: 配置文件地址</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    conf = configparser.ConfigParser()</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(filepath):</span><br><span class="line">        conf.read(filepath)</span><br><span class="line"></span><br><span class="line">    conf[section] = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        conf.write(f)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.python.org/3/library/configparser.html" target="_blank" rel="noopener">configparser</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中使用 &lt;code&gt;configparser&lt;/code&gt; 模块来操作 ini 文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 如何创建文件</title>
    <link href="http://wxnacy.com/2019/04/09/python-create-file/"/>
    <id>http://wxnacy.com/2019/04/09/python-create-file/</id>
    <published>2019-04-09T10:02:33.000Z</published>
    <updated>2019-04-10T10:03:15.091Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中可以使用 <code>open()</code> 内置方法来创建和打开文件。</p><a id="more"></a><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(file, [mode])</span><br></pre></td></tr></table></figure><p>Mode:</p><ul><li><code>x</code> 创建文件，如果文件已经存在会报错。</li><li><code>w</code> 创建可写文件，写入内容覆盖文件。</li><li><code>r</code> 获取可读文件，默认模式。</li><li><code>a</code> 打开一个可追加文件，广告默认在文尾。</li><li><code>t</code> 打开一个 text 模式，默认模式</li><li><code>b</code> 打开一个二进制模式</li></ul><p><strong>创建文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test'</span>, <span class="string">'x'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test'</span>, <span class="string">'x'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    f = open(<span class="string">'/tmp/test'</span>, <span class="string">'x'</span>)</span><br><span class="line">FileExistsError: [Errno <span class="number">17</span>] File exists: <span class="string">'/tmp/test'</span></span><br></pre></td></tr></table></figure><p><strong>创建可写文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hw'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p><strong>创建可追加文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hw'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">'hwhw'</span></span><br></pre></td></tr></table></figure><p><strong>获取可读文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">'hwhw'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'rb'</span>)    <span class="comment"># 以二进制打开</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b'hwhw'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.guru99.com/reading-and-writing-files-in-python.htm" target="_blank" rel="noopener">Python File Handling: Create, Open, Append, Read, Write</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中可以使用 &lt;code&gt;open()&lt;/code&gt; 内置方法来创建和打开文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Mac 系统中使用 ffmpeg 给视频添加文字水印</title>
    <link href="http://wxnacy.com/2019/04/08/ffmpeg-drawtext/"/>
    <id>http://wxnacy.com/2019/04/08/ffmpeg-drawtext/</id>
    <published>2019-04-08T06:16:42.000Z</published>
    <updated>2019-04-08T06:16:42.408Z</updated>
    
    <content type="html"><![CDATA[<p>最近有给视频加文字水印的需求，第一个想到的肯定是使用 ffmpeg，搜索了下发现网上的博客多是从别人那复制过来的，直接使用多是报错，经过摸索后，终于搞清楚了简单用法，今天简单总结下。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#ying-wen-shui-yin">英文水印</a></li><li><a href="#zhong-wen-shui-yin">中文水印</a></li></ul><!-- tocstop --></div><p>先来看个例子，我希望在如下的视频右侧加上文字水印，如下</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel33.png" alt="mavel3"></p><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><p>首先需要安装最新版本的 ffmpeg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install ffmpeg</span><br></pre></td></tr></table></figure><h2><span id="ying-wen-shui-yin">英文水印</span><a href="#ying-wen-shui-yin" class="header-anchor"></a></h2><p>运行下面的命令，即可达到上图效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -y -i mavel4.mp4 -vf <span class="string">"drawtext=text='Avengers\: Endgame':x=700:y=200:fontsize=24:fontcolor=red"</span> mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>参数含义</p><ul><li><code>-i</code>：需要渲染的视频，<code>mavel4.mp4</code> 为视频源</li><li><code>-vf</code>：后面跟着需要的具体渲染效果，后面的参数需要使用双引号包裹起来</li><li><code>mavel4_drawtext.mp4</code>：就是最后输出的文件名</li><li><code>-y</code>：对一切提示回答 <code>yes</code></li></ul><p><code>-vf</code> 后面的参数比较复杂，我们先将命令行折行美化下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -y -i mavel4.mp4 \</span><br><span class="line">    -vf <span class="string">"drawtext=\</span></span><br><span class="line"><span class="string">        text='Avengers\: Endgame':\</span></span><br><span class="line"><span class="string">        x=700:\</span></span><br><span class="line"><span class="string">        y=200:\</span></span><br><span class="line"><span class="string">        fontsize=24:\</span></span><br><span class="line"><span class="string">        fontcolor=red:\</span></span><br><span class="line"><span class="string">        "</span> \</span><br><span class="line">    mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>现在我们来逐条分析下</p><ul><li><code>drawtext=</code>：代表了此次渲染为添加文字水印，后面跟着具体的属性，属性之间使用 <code>:</code> 分割</li><li><code>text=&#39;Avengers\: Endgame&#39;:</code>：想要渲染的文字内容，如果想要输入 <code>:</code>，需要使用 <code>\</code> 进行转义</li><li><code>x=700:y=200</code>：分别为水印距视频左侧 700 偏移量，距顶部 200 偏移量，默认为 0</li><li><code>fontsize=24:</code>：字体大小，默认为 16</li><li><code>fontcolor=red:</code>：字体颜色红色，默认为黑色</li></ul><h2><span id="zhong-wen-shui-yin">中文水印</span><a href="#zhong-wen-shui-yin" class="header-anchor"></a></h2><p>这是英文的水印，不过我的需求为中文水印，我第一个反应就是乱码问题，先试一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -y -i mavel4.mp4 \</span><br><span class="line">    -vf <span class="string">"drawtext=\</span></span><br><span class="line"><span class="string">        text='复仇者联盟：终局之战':\</span></span><br><span class="line"><span class="string">        x=700:\</span></span><br><span class="line"><span class="string">        y=200:\</span></span><br><span class="line"><span class="string">        fontsize=24:\</span></span><br><span class="line"><span class="string">        fontcolor=red:\</span></span><br><span class="line"><span class="string">        "</span> \</span><br><span class="line">    mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>果然，都是方块</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel4.png" alt="mavel4"></p><p>这是因为默认的字体文件并不支持中文，此时我们需要使用 <code>fontfile</code> 属性来制定字体文件。</p><p>网上很多博客都直接使用 <code>fontfile=PingFang.ttc:</code> 来指定文件，这多少有点误人子弟，此处应该使用字体文件的<strong><em>绝对地址</em></strong>。</p><p>如何获取 Mac 电脑中字体文件的绝对地址呢，请看我的的这篇文章 <a href="/2019/04/03/mac-fonts-path/">Mac 电脑查看字体文件位置</a></p><p>我选择了苹方字体，绝对地址为 <code>/System/Library/Fonts/PingFang.ttc</code>，完整命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -y -i mavel4.mp4 \</span><br><span class="line">    -vf <span class="string">"drawtext=\</span></span><br><span class="line"><span class="string">        fontfile=/System/Library/Fonts/PingFang.ttc:\</span></span><br><span class="line"><span class="string">        text='复仇者联盟：终局之战':\</span></span><br><span class="line"><span class="string">        x=700:\</span></span><br><span class="line"><span class="string">        y=200:\</span></span><br><span class="line"><span class="string">        fontsize=24:\</span></span><br><span class="line"><span class="string">        fontcolor=red:\</span></span><br><span class="line"><span class="string">        "</span> \</span><br><span class="line">    mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>最终渲染效果</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel5.png" alt="mavel5"></p><p>文字水印还有很多参数，大家可以根据自己的需求进行选择，文档地址：<a href="https://ffmpeg.org/ffmpeg-filters.html#drawtext-1" target="_blank" rel="noopener">https://ffmpeg.org/ffmpeg-filters.html#drawtext-1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有给视频加文字水印的需求，第一个想到的肯定是使用 ffmpeg，搜索了下发现网上的博客多是从别人那复制过来的，直接使用多是报错，经过摸索后，终于搞清楚了简单用法，今天简单总结下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ffmpeg" scheme="http://wxnacy.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Python 复制文件的两种方式</title>
    <link href="http://wxnacy.com/2019/04/07/python-copy-command/"/>
    <id>http://wxnacy.com/2019/04/07/python-copy-command/</id>
    <published>2019-04-07T10:48:45.000Z</published>
    <updated>2019-04-07T10:48:45.188Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中实现文件复制，大概分为两种方式<strong>复制函数</strong>和<strong>调用 shell</strong></p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#han-shu-fu-zhi">函数复制</a></li><li><a href="#diao-yong-shell">调用 shell</a></li><li><a href="#xiao-lu-dui-bi">效率对比</a></li></ul><!-- tocstop --></div><h2><span id="han-shu-fu-zhi">函数复制</span><a href="#han-shu-fu-zhi" class="header-anchor"></a></h2><p><code>shutil</code> 模块中有几个可以实现复制的方法</p><p>其实 <code>copy()</code> 方法是最常用到的，它相当于 <code>cp -P</code> 命令，可以复制文件的内容和权限。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># shutil.copy(源文件, 目标文件) 目标文件可以是目录</span></span><br><span class="line">shutil.copy(<span class="string">'test.sh'</span>, <span class="string">'test_copy.sh'</span>)</span><br><span class="line">shutil.copy(<span class="string">'test.sh'</span>, <span class="string">'/tmp'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x  1 wxnacy  wheel     90 Apr  6 19:05 test.sh</span><br><span class="line">-rwxr-xr-x  1 wxnacy  wheel     90 Apr  6 19:09 test_copy.sh</span><br></pre></td></tr></table></figure><p><code>copy()</code> 方法中调用了 <code>copyfile()</code> <code>copymode()</code> 两个方法。</p><ul><li><code>copyfile()</code> 负责复制文件内容，但是目标文件不能是目录，并且必须可以写入</li><li><code>copymode()</code> 负责复制文件权限</li></ul><p><code>copyfile()</code> 方法中又调用了低级方法 <code>copyfileobj()</code></p><p><code>copyfileobj()</code> 方法可以假定了一个可选参数（缓冲区大小），你可以用来设置缓冲区长度。这是复制过程中保存在内存中的字节数。系统使用的默认大小是 16 KB。</p><p>还有个 <code>copy2()</code> 方法，它类似 <code>copy()</code>，但是它可以在复制数据时获取元数据中添加的访问和修改时间。</p><p>几个方法就功能而言 <code>copy2() &gt; copy() &gt; copyfile()</code>，相对应的功能和耗时是成正比的，所以我建议一般情况下可以使用 <code>copy()</code> 方法，如果大批量复制操作，并且没有特殊权限，比如图片，那么还是使用 <code>copyfile()</code> 更好一点。</p><h2><span id="diao-yong-shell">调用 shell</span><a href="#diao-yong-shell" class="header-anchor"></a></h2><p>还有一个万能的方式是直接调用 shell 命令。</p><p>现在使用 <code>subprocess</code> 模块代替其他调用 shell 的模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"></span><br><span class="line">cmds = shlex.split(<span class="string">"cp test.sh test_popen.sh"</span>)</span><br><span class="line">p = subprocess.Popen(cmds)</span><br><span class="line">p.communicate()</span><br></pre></td></tr></table></figure><p><code>Popen()</code> 方法的第一个参数为执行的命令，在 Unix 系统中，如果该参数为字符串，那它只能是一个可执行文件，如果想要传参，则必须以数组的形式传入，<code>shlex.split()</code> 方法可以将复杂的命令转换为数组的形式。</p><p>在 Windows 系统中可以使用字符串传入命令行，并且需要使用 <code>copy source_file target_file</code> 命令。</p><h2><span id="xiao-lu-dui-bi">效率对比</span><a href="#xiao-lu-dui-bi" class="header-anchor"></a></h2><p>最后对比下他们的速度，执行 100 次时间如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">copy_file time    0.022215532000000003</span><br><span class="line">copy time         0.059561121999999994</span><br><span class="line">copy2 time        0.07728823600000001</span><br><span class="line">popen time        0.37018151000000005</span><br></pre></td></tr></table></figure><p>大概是 <code>subprocess</code> 模块会生成子进程的原因，速度慢了很多，在这种情况下，复制操作优选依然是 <code>copy()</code> <code>copyfile()</code> 方法。</p><ul><li><a href="https://www.techbeamers.com/python-copy-file/" target="_blank" rel="noopener">How to Copy a File in Python – 9 Different Ways to do It!</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中实现文件复制，大概分为两种方式&lt;strong&gt;复制函数&lt;/strong&gt;和&lt;strong&gt;调用 shell&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 操作剪切板</title>
    <link href="http://wxnacy.com/2019/04/06/python-clipboard/"/>
    <id>http://wxnacy.com/2019/04/06/python-clipboard/</id>
    <published>2019-04-06T09:59:15.000Z</published>
    <updated>2019-04-06T09:59:15.248Z</updated>
    
    <content type="html"><![CDATA[<p>Python 操作剪切板，需要调用系统的 C 动态库，或者使用自带的命令行。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#shi-yong-pbcopy-he-pbpaste">使用 pbcopy 和 pbpaste</a></li><li><a href="#shi-yong-pyperclip-mo-kuai">使用 pyperclip 模块</a></li></ul><!-- tocstop --></div><p>Windows 系统可以动态调用 <code>ctypes</code> 库，具体操作步骤可以看看这篇文章：<a href="https://www.jianshu.com/p/430f4af2cb06" target="_blank" rel="noopener">https://www.jianshu.com/p/430f4af2cb06</a></p><p>下面我们主要来说下 Mac 系统的操作方式。</p><h2><span id="shi-yong-pbcopy-he-pbpaste">使用 pbcopy 和 pbpaste</span><a href="#shi-yong-pbcopy-he-pbpaste" class="header-anchor"></a></h2><p>在 Mac 系统中可以使用 <code>pbcopy</code> 和 <code>pbpaste</code> 来实现复制粘贴操作，这两个命令都是系统自带的。</p><p><code>pbcopy</code> 接收管道输入的文字，并复制到剪切板。<code>pbpaste</code> 直接输出剪切板的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'我爱你中国'</span> | pbcopy</span><br><span class="line">$ pbpaste</span><br><span class="line">我爱你中国</span><br></pre></td></tr></table></figure><p>使用起来还是很方便的，接下来是 Python 中如何调用。</p><p>使用 <code>subprocess</code> 模块下的 <code>Popen</code> 方法，可以很方便的操作管道的输入输出信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 在 Mac 系统中使用剪切板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_clipboard</span><span class="params">(data: str)</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">'pbcopy'</span>], stdin=subprocess.PIPE)</span><br><span class="line">    p.stdin.write(data.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    p.stdin.close()</span><br><span class="line">    p.communicate()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_from_clipboard</span><span class="params">()</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">'pbpaste'</span>], stdout=subprocess.PIPE)</span><br><span class="line">    p.wait()</span><br><span class="line">    byte_data = p.stdout.read()</span><br><span class="line">    p.stdout.close()</span><br><span class="line">    <span class="keyword">return</span> byte_data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    set_clipboard(<span class="string">'我爱你中国'</span>)</span><br><span class="line">    print(get_from_clipboard())</span><br><span class="line"></span><br><span class="line"><span class="comment"># python clipboard.py</span></span><br><span class="line"><span class="comment"># 我爱你中国</span></span><br></pre></td></tr></table></figure><h2><span id="shi-yong-pyperclip-mo-kuai">使用 pyperclip 模块</span><a href="#shi-yong-pyperclip-mo-kuai" class="header-anchor"></a></h2><p>如果你的系统需要适应各个平台，并且需要比较高的稳定性，那还是直接使用第三方模块 <a href="https://github.com/asweigart/pyperclip" target="_blank" rel="noopener">pyperclip</a> 比较方便。</p><p>它的源码地址为：<a href="https://github.com/asweigart/pyperclip/blob/master/src/pyperclip/__init__.py" target="_blank" rel="noopener">https://github.com/asweigart/pyperclip/blob/master/src/pyperclip/__init__.py</a></p><p>其实他就是整合了上述的方法，只是应该了这么多人的使用，已经非常稳定，使用方法也更简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pyperclip</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pyperclip.copy(<span class="string">'The text to be copied to the clipboard.'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pyperclip.paste()</span><br><span class="line"><span class="string">'The text to be copied to the clipboard.'</span></span><br></pre></td></tr></table></figure><p><code>Windows</code> 和 <code>Mac</code> 平台可以直接使用。</p><p><code>Linux</code> 需要 <code>xclip</code> <code>xsel</code> <code>gtk</code> <code>PyQt4</code> 依赖包，可以根据平台通过 <code>apt</code> 或 <code>yum</code> 进行安装。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 操作剪切板，需要调用系统的 C 动态库，或者使用自带的命令行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Expect 设置变量和读取环境变量</title>
    <link href="http://wxnacy.com/2019/04/05/expect-variables/"/>
    <id>http://wxnacy.com/2019/04/05/expect-variables/</id>
    <published>2019-04-05T12:34:00.000Z</published>
    <updated>2019-04-05T12:34:00.928Z</updated>
    
    <content type="html"><![CDATA[<p>Expect 中设置变量跟 Bash 稍有不同</p><a id="more"></a><p><strong>Bash</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=wxnacy</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span>  <span class="comment"># wxnacy</span></span><br></pre></td></tr></table></figure><p><strong>Expect</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name wxnacy</span><br><span class="line">puts <span class="variable">$name</span>  <span class="comment"># wxnacy</span></span><br></pre></td></tr></table></figure><p>边境变量也是如此</p><p><strong>Bash</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span>      <span class="comment"># /Users/wxnacy</span></span><br></pre></td></tr></table></figure><p><strong>Expect</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="variable">$env</span>(HOME) <span class="comment"># /Users/wxnacy</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Expect 中设置变量跟 Bash 稍有不同&lt;/p&gt;
    
    </summary>
    
    
      <category term="expect" scheme="http://wxnacy.com/tags/expect/"/>
    
  </entry>
  
  <entry>
    <title>Zsh 加载速度优化</title>
    <link href="http://wxnacy.com/2019/04/04/zsh-speed-optimization/"/>
    <id>http://wxnacy.com/2019/04/04/zsh-speed-optimization/</id>
    <published>2019-04-04T05:59:45.000Z</published>
    <updated>2019-04-04T05:59:45.051Z</updated>
    
    <content type="html"><![CDATA[<p>用 Zsh 也有几年的时间，期间各种添加配置，导致了每次启动都巨慢无比。我也换了 <a href="https://fishshell.com/" target="_blank" rel="noopener">fish</a> 用过几天，虽然速度很快，补全功能超爽，但是它最大的问题是不兼容 bash，那还玩个毛，我的开发环境极度依赖 bash 脚本，没办法了，Zsh 还是要接着用的，但是优化速度成了一个大问题。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>通过 <code>time</code> 分析 <code>zsh</code> 加载速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ time zsh -i -c <span class="built_in">exit</span></span><br><span class="line">5.52 real         3.56 user         2.09 sys</span><br></pre></td></tr></table></figure><p>这里的 <code>real</code> 代表的是执行 <code>zsh</code> 时真实的加载速度，好家伙，这个时间真是够受的。</p><p>我们再来看下无配置加载速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ time zsh --no-rcs -i -c <span class="built_in">exit</span></span><br><span class="line">0.00 real         0.00 user         0.00 sys</span><br></pre></td></tr></table></figure><p>我们当然不可能优化到这个速度，但这是我们的目标。</p><p>网上优化的方法，通常是使用懒加载，这是很优雅的解决方式，也很有效，但还是那句话，<strong><em>好的东西也并不一定适用于所有人</em></strong>。</p><p>关于懒加载，大家可以看看这篇文章 <a href="https://best33.com/283.moe" target="_blank" rel="noopener">zshrc 启动速度分析和优化</a>，里面梳理了怎样分析 <code>zshrc</code> 中每条语句的加载速度，从而我们可以针对性的优化。</p><p>如果懒加载可以解决你的问题，那现在已经可以关闭网页，然后优化你的配置了。</p><p>下面我先来说说懒加载的缺点，比如 <code>nvm</code> 的配置就很浪费时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span>  ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span>  <span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure><p>我们进行懒加载配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">nvm</span></span>() &#123;</span><br><span class="line">    <span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">    [ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">    [ -s <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span>  ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span>  <span class="comment"># This loads nvm bash_completion</span></span><br><span class="line">    nvm <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样再次执行测速会发现优化了很多，是不是很兴奋呢？先别着急。</p><p>懒加载配置后，启动 <code>zsh</code> 时虽然提升了速度，但是想要使用 <code>node</code> 命令，需要先执行 <code>nvm</code> 实时加载上述的配置，这似乎没什么，不使用不加载，这不挺好吗？</p><p>先来说说我的环境，我的开发环境极度依赖脚本，如果使用了懒加载，那每个启动脚本前都要先套上一个无用的 <code>nvm</code> 命令，这多少有点不伦不类，并且这对于我来说好像并没有起到加速的效果。</p><p>并且有些功能懒加载并不正常，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;HOME&#125;</span>/.pyenv"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># https://github.com/pyenv/pyenv#basic-github-checkout</span></span><br><span class="line">    <span class="built_in">export</span> PYENV_ROOT=<span class="string">"<span class="variable">$HOME</span>/.pyenv"</span></span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$&#123;PYENV_ROOT&#125;</span>/bin:<span class="variable">$&#123;PATH&#125;</span>"</span></span><br><span class="line">    <span class="comment"># config for vim plugin YouComplateMe</span></span><br><span class="line">    <span class="built_in">export</span> PYENV_VIRTUALENV_DISABLE_PROMPT=1</span><br><span class="line">    <span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv init -)</span>"</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv virtualenv-init -)</span>"</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>pyenv</code> 用懒加载并不能正常使用，可能是我用的不对，但我也不想在纠结这个件事，我在想是不是可以换一条路。</p><p>我在 <a href="/2018/10/08/zsh-startup-files/">Zsh 配置文件加载顺序</a>一文中介绍了 Zsh 配置文件的生命周期。</p><p>当打开新的 Terminal 时，配置加载顺序为 <code>~/.zshenv</code> <code>~/.zprofile</code> <code>~/.zshrc</code> <code>~/.zlogin</code></p><p>执行 <code>zsh</code> 时，配置加载顺序为 <code>~/.zshenv</code> <code>~/.zshrc</code></p><p>除了 <code>~/.zshrc</code> 我们发现了一个有意思的配置 <code>~/.zprofile</code>，它只在启动 Terminal 时才会加载，那我把不常变动并且耗时长的配置写在这里面不就行了。</p><p>这样不管是执行 <code>zsh</code>，还是 <code>source ~/.zshrc</code> 速度都得到了改善，这个看似自欺欺人的变动，却恰好能满足我的要求。</p><p>我使用 tmux 来管理窗口，每次开机后恢复一次 tmux 缓存窗口即可，知道下次重启电脑，我可能都不会在新建 Terminal 了，这样对于我来说就已经大大的优化的 <code>zsh</code> 速度。</p><p>最后我过滤了现在的配置文件，去掉了些无用的配置后，速度如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; time zsh -i -c <span class="built_in">exit</span></span><br><span class="line">0.23 real         0.13 user         0.08 sys</span><br></pre></td></tr></table></figure><p>OK！终于可以愉快的使用 Zsh 了。</p><ul><li><a href="https://wxnacy.com/2018/10/08/zsh-startup-files/">Zsh 配置文件加载顺序</a></li><li><a href="http://blog.xebia.com/profiling-zsh-shell-scripts/" target="_blank" rel="noopener">Profiling zsh shell scripts</a></li><li><a href="https://frederic-hemberger.de/articles/speed-up-initial-zsh-startup-with-lazy-loading/" target="_blank" rel="noopener">Speed up initial zsh startup with lazy-loading</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 Zsh 也有几年的时间，期间各种添加配置，导致了每次启动都巨慢无比。我也换了 &lt;a href=&quot;https://fishshell.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fish&lt;/a&gt; 用过几天，虽然速度很快，补全功能超爽，但是它最大的问题是不兼容 bash，那还玩个毛，我的开发环境极度依赖 bash 脚本，没办法了，Zsh 还是要接着用的，但是优化速度成了一个大问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zsh" scheme="http://wxnacy.com/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>Mac 电脑查看字体文件位置</title>
    <link href="http://wxnacy.com/2019/04/03/mac-fonts-path/"/>
    <id>http://wxnacy.com/2019/04/03/mac-fonts-path/</id>
    <published>2019-04-03T05:51:06.000Z</published>
    <updated>2019-04-03T05:51:06.814Z</updated>
    
    <content type="html"><![CDATA[<p>首先直接给出 Mac 电脑中字体文件的位置 <code>/System/Library/Fonts</code></p><a id="more"></a><p>在 Terminal 中使用命令打开该目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ open /System/Library/Fonts</span><br></pre></td></tr></table></figure><p>打开后是这样的</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/mac-font3_770.png" alt="mac1"></p><p>文件名全部都是英文的，如果你对字体不熟悉，那要寻找中文字体几乎是不可能的。</p><p>这时候我们需要通过<code>字体册</code>来查看</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/mac-font1_509.png" alt="mac2"></p><p>从字体册的左侧选择中文，并从右侧想要选择的字体上右键点击，并点击<code>在访达中查看</code>，还是很受不了这个翻译。</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/mac-font2_884.png" alt="mac3"></p><p>随后直接可以在 <code>Finder</code> 中定位该字体。</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/mac-font3_770.png" alt="mac4"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先直接给出 Mac 电脑中字体文件的位置 &lt;code&gt;/System/Library/Fonts&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mac" scheme="http://wxnacy.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>bpython 强大的自动补全 Python Shell 工具</title>
    <link href="http://wxnacy.com/2019/04/02/bpython/"/>
    <id>http://wxnacy.com/2019/04/02/bpython/</id>
    <published>2019-04-02T01:48:16.000Z</published>
    <updated>2019-04-02T01:48:16.437Z</updated>
    
    <content type="html"><![CDATA[<p>提到 Python Shell 工具，要说 ipython 排老二，那没有哪位能排第一，它的功能强大是毋庸置疑的，然后强大归强大，这并不代表能适合所有人。</p><a id="more"></a><p>比如说我，我编写程序，最讲究的效率，自动补全和快速输入是必要的。但是 ipython 却远远满足不了我，如果你也用 <code>Vim + YouCompleteMe</code> 应该可以理解我。也许你会说，这本来就是 shell 命令工具，还能像 IDE 咋滴，嘿，巧了，今天要说的 <a href="https://bpython-interpreter.org/" target="_blank" rel="noopener">bpython</a> 就是个 shell 工具，但是它也能像 IDE 一样编写代码。</p><p><img src="https://camo.githubusercontent.com/fffc539a28d2465c11b74ff3c06d0b5595037454/687474703a2f2f692e696d6775722e636f6d2f6a66386d4374502e676966" alt="bpython"></p><p>相信你看完这个官方的 demo，已经开始想去了解它了，跟着我一起来吧。</p><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install bpython</span><br></pre></td></tr></table></figure><p><strong>运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ bpython</span><br><span class="line">bpython version 0.17.1 on top of Python 3.7.2 /Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/bin/python3.7</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Welcome to bpython! Press &lt;F1&gt; <span class="keyword">for</span> <span class="built_in">help</span>.</span><br></pre></td></tr></table></figure><p>使用 <code>&lt;F1&gt;</code> 可以查看帮助文档</p><p>我挑一些常用的键位说一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Tab&gt;           <span class="comment"># 出现提示后，进行选择</span></span><br><span class="line">&lt;C<span class="_">-a</span>&gt;           <span class="comment"># 快速跳转行首</span></span><br><span class="line">&lt;C<span class="_">-e</span>&gt;           <span class="comment"># 快速跳转行尾，如果有上次输入记录，则自动输入</span></span><br><span class="line">&lt;C-u&gt;           <span class="comment"># 清空当前行</span></span><br><span class="line">&lt;C-w&gt;           <span class="comment"># 删除前一个单词</span></span><br><span class="line">&lt;C-h&gt;           <span class="comment"># 删除删除前一个字符，免去了手指移动到 backspace 的时间，刚好我在 Vim 中也设置了这个按键</span></span><br><span class="line"></span><br><span class="line">&lt;F1&gt;            <span class="comment"># 帮助文档</span></span><br><span class="line">&lt;F3&gt;            <span class="comment"># 打开配置文件，第一次提示是否生成配置文件</span></span><br><span class="line">&lt;F6&gt;            <span class="comment"># 重新加载 module，这在测试程序时非常有必要</span></span><br><span class="line">&lt;F7&gt;            <span class="comment"># 将当前 shell 中的代码放在临时文件中，并使用 vim 进行编辑</span></span><br><span class="line">&lt;F8&gt;            <span class="comment"># 将当前代码上传到 pastebin 上，并生成一个有效期为 7 天的链接</span></span><br></pre></td></tr></table></figure><p>挑几个重点的说下</p><p><strong>查看文档</strong></p><p>ipython 中可以使用 <code>requests.get?</code> 来查看文档</p><p>而 bpython 会自动出现该方法的文档</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/bpy1.png" alt="wpy1"></p><p><strong>重载 module</strong></p><p>bpython 目前没有启动自动重载的能力，只能通过按键手动重载，不过我们可以修改它的按键，毕竟每次按 <code>&lt;F6&gt;</code> 还是很不方便的。</p><ul><li>进入 <code>bpython</code> 命令，按 <code>&lt;F3&gt;</code> 生成并编辑 <code>config</code> 文件<ul><li>默认配置文件的位置为 <code>~/.config/bpython/config</code>，如果你想修改它的位置，那么启动的时候需要增加参数 <code>bpython --config &lt;config-path&gt;</code></li></ul></li><li><code>&lt;C-r&gt;</code> 是我认为比较舒服的按键，但是它已经被撤销按键占住了，我认为撤销不是常用按键，所以进行了修改，最终配置如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reimport = C-r  <span class="comment"># 重载按键</span></span><br><span class="line">undo = C-q      <span class="comment"># 撤销按键</span></span><br></pre></td></tr></table></figure><ul><li>然后退出 <code>bpython</code>，重新进入即可生效</li></ul><p><strong>上传 pastebin</strong></p><p>这是个比较有意思的功能，假如你想与别人及时分享一段代码，这是很优雅的方式，按下 <code>&lt;F8&gt;</code> 即可将当前命令行中的代码上传并得到一个地址，点击效果如下。</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/bpy2_514.png" alt="bpy2"></p><p>当然 bpython 也不是没有缺点，比如在使用一些第三方模块时，自动补全有时会卡顿，这还是挺影响心情的，不过瑕不掩瑜，它仍然是让我爱不释手的 shell 工具。</p><ul><li><a href="https://github.com/bpython/bpython" target="_blank" rel="noopener">源代码</a></li><li><a href="https://docs.bpython-interpreter.org/configuration.html" target="_blank" rel="noopener">Configuration</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到 Python Shell 工具，要说 ipython 排老二，那没有哪位能排第一，它的功能强大是毋庸置疑的，然后强大归强大，这并不代表能适合所有人。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 中循环语句速度对比</title>
    <link href="http://wxnacy.com/2019/04/01/python-loop-speed-comparison/"/>
    <id>http://wxnacy.com/2019/04/01/python-loop-speed-comparison/</id>
    <published>2019-04-01T05:31:39.000Z</published>
    <updated>2019-04-01T09:08:09.817Z</updated>
    
    <content type="html"><![CDATA[<p>今天来比较下 Python 中循环语句的性能，参赛选手为 <code>while</code> <code>for</code> <code>生成器</code> <code>内置函数</code> <code>列表解析</code></p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: for while generator list_comprehension map 对比速度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_for</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        res.append(abs(i))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_while</span><span class="params">(n)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        res.append(abs(i))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_generator</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''使用生成器'''</span></span><br><span class="line">    res = (abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    res =  list(res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_list_compre</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''使用列表解析'''</span></span><br><span class="line">    res = [abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_map</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''使用内置函数 map'''</span></span><br><span class="line">    <span class="keyword">return</span> list(map(abs, range(n)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMain</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''before each test function'''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''after each test function'''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_func</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">10</span></span><br><span class="line">        <span class="comment"># 我们要求他们生成的结果是一样的</span></span><br><span class="line">        flag = (loop_for(n) == loop_while(n) == loop_generator(n) ==</span><br><span class="line">                loop_list_compre(n) == loop_map(n))</span><br><span class="line">        self.assertTrue(flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_run_time</span><span class="params">(count, func, **kw)</span>:</span></span><br><span class="line">    b = timeit.default_timer()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        func(**kw)</span><br><span class="line">    print(<span class="string">'&#123;&#125; run &#123;&#125; times used &#123;&#125;s'</span>.format(</span><br><span class="line">        func.__name__.ljust(<span class="number">20</span>),</span><br><span class="line">        count,</span><br><span class="line">        timeit.default_timer() -b ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    count = <span class="number">1000</span></span><br><span class="line">    n = <span class="number">1000</span></span><br><span class="line">    print_func_run_time(count, loop_for, n = n)</span><br><span class="line">    print_func_run_time(count, loop_while, n = n)</span><br><span class="line">    print_func_run_time(count, loop_generator, n = n)</span><br><span class="line">    print_func_run_time(count, loop_list_compre, n = n)</span><br><span class="line">    print_func_run_time(count, loop_map, n = n)</span><br><span class="line">    unittest.main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># .</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Ran 1 test in 0.000s</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># OK</span></span><br><span class="line"><span class="comment"># loop_for             run 1000 times used 0.14018906400087872s</span></span><br><span class="line"><span class="comment"># loop_while           run 1000 times used 0.21399457900042762s</span></span><br><span class="line"><span class="comment"># loop_generator       run 1000 times used 0.12857274799898732s</span></span><br><span class="line"><span class="comment"># loop_list_compre     run 1000 times used 0.08585307099929196s</span></span><br><span class="line"><span class="comment"># loop_map             run 1000 times used 0.043123570998432115s</span></span><br></pre></td></tr></table></figure><p>我们以性能好坏来区分，得到的结论</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &gt; 列表解析 &gt; 生成器 &gt; <span class="keyword">for</span> &gt; <span class="keyword">while</span></span><br></pre></td></tr></table></figure><p><code>map</code> 是内置函数，底层由 C 来编写，最快是毫无疑问的。而 <code>while</code> 是纯 Python 实现的，所以性能最差。</p><p>列表解析比生成器要快一些，这里多少有些存疑，因为我们想要返回列表，所以其实 <code>map</code> 和生成器都是在负重前行，我们修改下测试方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_generator</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = (abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_list_compre</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = [abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_map</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> map(abs, range(n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_run_time</span><span class="params">(count, func, **kw)</span>:</span></span><br><span class="line">    b = timeit.default_timer()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        func(**kw)</span><br><span class="line">    print(<span class="string">'&#123;&#125; run &#123;&#125; times used &#123;&#125;s'</span>.format(</span><br><span class="line">        func.__name__.ljust(<span class="number">20</span>),</span><br><span class="line">        count,</span><br><span class="line">        timeit.default_timer() -b ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    count = <span class="number">1000</span></span><br><span class="line">    n = <span class="number">1000</span></span><br><span class="line">    print_func_run_time(count, loop_list_compre, n = n)</span><br><span class="line">    print_func_run_time(count, loop_map, n = n)</span><br><span class="line">    print_func_run_time(count, loop_generator, n = n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loop_list_compre     run 1000 times used 0.08865494900237536s</span></span><br><span class="line"><span class="comment"># loop_map             run 1000 times used 0.0007684140000492334s</span></span><br><span class="line"><span class="comment"># loop_generator       run 1000 times used 0.0009459810025873594s</span></span><br></pre></td></tr></table></figure><p>好了，这次我们不再强制转换 list，而仅仅只是返回一个可迭代的对象，发现 <code>map</code> 依然最快，生成器稍慢，而列表解析竟然慢了近百倍。</p><p>这次我们可以下个结论，处理循环时，我们已经尽可能的使用内置方法，然后根据业务需求来选择使用列表解析和生成器，实在不行了使用 <code>for</code> 循环，而 <code>while</code> 则是尽量不去使用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来比较下 Python 中循环语句的性能，参赛选手为 &lt;code&gt;while&lt;/code&gt; &lt;code&gt;for&lt;/code&gt; &lt;code&gt;生成器&lt;/code&gt; &lt;code&gt;内置函数&lt;/code&gt; &lt;code&gt;列表解析&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Pyenv 安装 Python3.7 报错：zlib not available</title>
    <link href="http://wxnacy.com/2019/03/31/pyenv-zlib-not-available/"/>
    <id>http://wxnacy.com/2019/03/31/pyenv-zlib-not-available/</id>
    <published>2019-03-31T05:30:55.000Z</published>
    <updated>2019-04-01T05:33:15.866Z</updated>
    
    <content type="html"><![CDATA[<p>最近升级 Mac 系统，又手贱升级了 pyenv，结果安装 Python3.7 时报了错</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.7 zipimport.ZipImportError: can<span class="string">'t decompress data; zlib not available</span></span><br></pre></td></tr></table></figure><p>查询了下，发现是因为 Xcode 命令行工具没有安装需要的头，需要手动进行安装，运行如下命令可以解决这个问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xcode-select --install</span><br><span class="line">$ sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target /</span><br></pre></td></tr></table></figure><p>我的环境是</p><ul><li>macOS Mojave 10.14.3</li><li>pyenv 1.2.9</li><li><p>安装 3.7.2 版本</p></li><li><p><a href="https://github.com/pyenv/pyenv/issues/1219" target="_blank" rel="noopener">Install failed, “zlib not available” on macOS Mojave</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近升级 Mac 系统，又手贱升级了 pyenv，结果安装 Python3.7 时报了错&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy 升级报错：Can&#39;t resolve label reference for ORDER BY / GROUP BY ...</title>
    <link href="http://wxnacy.com/2019/03/30/sqlalchemy-error-order-by/"/>
    <id>http://wxnacy.com/2019/03/30/sqlalchemy-error-order-by/</id>
    <published>2019-03-30T09:53:36.000Z</published>
    <updated>2019-03-30T09:53:37.021Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间因为要使用 <code>insert ... on duplicate key update ..</code> 语句的功能，SQLAlchemy 从 1.1.5 升级到了 1.3.1，结果程序报了错</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Can<span class="string">'t resolve label reference for ORDER BY / GROUP BY. Textual SQL expression '</span>rank desc<span class="string">' should be explicitly declared as text('</span>rank desc<span class="string">')</span></span><br></pre></td></tr></table></figure><p>其实一看到这个错误，我就知道是怎么回事了，因为之前的版本其实报过警告，只是当时没有在意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAWarning: Can<span class="string">'t resolve label reference '</span>rank desc<span class="string">'; converting to text() (this warning may be suppressed after 10 occurrences)</span></span><br></pre></td></tr></table></figure><p>它的意思是在未来的版本 <code>order_by(&#39;rank desc&#39;)</code> 写法将不再支持。</p><p>那换个写法就好了。</p><p>我们先来回顾下，老版本 <code>ORDER BY</code> 的几种写法，原始 SQL 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; select * from user order by id desc;</span><br></pre></td></tr></table></figure><p>SQLAlchemy 的写法有三种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种最简单</span></span><br><span class="line">db.session.query(User).order_by(<span class="string">'id desc'</span>).all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种比较符合 SQLAlchemy 语法</span></span><br><span class="line">db.session.query(User).order_by(User.id.desc()).all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种最麻烦</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> desc</span><br><span class="line">db.session.query(User).order_by(desc(User.id)).all()</span><br></pre></td></tr></table></figure><p>既然新版本第一种方式不让用了，那就用第二种好了，OK，正常情况下没有，但是我修改后报了如下错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: <span class="built_in">type</span> object <span class="string">'VisitorLog'</span> has no attribute <span class="string">'rank'</span></span><br></pre></td></tr></table></figure><p>找不到属性？我回看了下代码发现了问题。</p><p>原始 SQL 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; select url, count(url) as rank from visit_log group by url order by rank desc;</span><br></pre></td></tr></table></figure><p>老版本 SQLAlchemy 写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line">cls = VisitLog</span><br><span class="line">res = db.session.query(</span><br><span class="line">    cls.url, func.count(cls.url).label(<span class="string">'rank'</span>)</span><br><span class="line">).group_by(cls.url).order_by(<span class="string">'rank desc'</span>).all()</span><br></pre></td></tr></table></figure><p>新版本理论写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line">cls = VisitLog</span><br><span class="line">res = db.session.query(</span><br><span class="line">    cls.url, func.count(cls.url).label(<span class="string">'rank'</span>)</span><br><span class="line">).group_by(cls.url).order_by(cls.rank.desc).all()</span><br></pre></td></tr></table></figure><p>因为 <code>rank</code> 我是用了 <code>label</code> 方法模拟了 <code>as</code> 功能，所以报错找不到属性也是可以理解的，那这里我们需要将 <code>label</code> 单提出一个变量了，在进行 <code>desc()</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line">cls = VisitLog</span><br><span class="line">rank = func.count(cls.url).label(<span class="string">'rank'</span>)</span><br><span class="line">res = db.session.query(</span><br><span class="line">    cls.url, rank</span><br><span class="line">).group_by(cls.url).order_by(rank.desc).all()</span><br></pre></td></tr></table></figure><p>在执行，完美解决</p><p>这套逻辑同样适用于 <code>GROUP BY</code> 语法</p><ul><li><a href="https://docs.sqlalchemy.org/en/latest/core/sqlelement.html#sqlalchemy.sql.expression.desc" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://stackoverflow.com/questions/15555920/python-sqlalchemy-label-usage" target="_blank" rel="noopener">python-sqlalchemy-label-usage</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间因为要使用 &lt;code&gt;insert ... on duplicate key update ..&lt;/code&gt; 语句的功能，SQLAlchemy 从 1.1.5 升级到了 1.3.1，结果程序报了错&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
      <category term="sqlalchemy" scheme="http://wxnacy.com/tags/sqlalchemy/"/>
    
  </entry>
  
  <entry>
    <title>OSSFS 阿里云 OSS 本地挂载工具</title>
    <link href="http://wxnacy.com/2019/03/29/ossfs/"/>
    <id>http://wxnacy.com/2019/03/29/ossfs/</id>
    <published>2019-03-29T01:47:02.000Z</published>
    <updated>2019-03-29T01:47:02.823Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/aliyun/ossfs" target="_blank" rel="noopener">ossfs</a> 能让您在Linux/Mac OS X 系统中把Aliyun OSS bucket 挂载到本地文件 系统中，您能够便捷的通过本地文件系统操作OSS 上的对象，实现数据的共享。</p></blockquote><a id="more"></a><h2><span id="wei-shi-me-xu-yao-yong-dao-zhe-ge-ruan-jian-ni">为什么需要用到这个软件呢？</span><a href="#wei-shi-me-xu-yao-yong-dao-zhe-ge-ruan-jian-ni" class="header-anchor"></a></h2><p>我的情况是这样的，公司微信 h5 的静态文件是放在 OSS 上的，因为代码框架选用的 React，正常情况下地址路由都是交给 <code>index.html</code> 处理的，但是返回的状态码是 404，而微信非常流氓的把 404 状态的地址都转到它自己的页面，使得页面无法正常显示，AWS 的 s3 可以设置 404 状态改为 200，不过 OSS 没有，所以我只能借助 ossfs 的同步功能，在本地加一个 nginx 反向代理，单独处理 404 的请求。</p><p>挂载了 ossfs，OSS 和本地挂在之间可以实现双向同步，这是很方便的。</p><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><p>首先从<a href="https://github.com/aliyun/ossfs/releases" target="_blank" rel="noopener">版本发布页面</a>下载合适的安装包</p><p><strong>Ubuntu 16.04</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/aliyun/ossfs/releases/download/v1.80.5/ossfs_1.80.5_ubuntu16.04_amd64.deb</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install gdebi-core</span><br><span class="line">$ sudo gdebi ossfs_1.80.5_ubuntu16.04_amd64.deb</span><br></pre></td></tr></table></figure><p><strong>CentOS 7</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/aliyun/ossfs/releases/download/v1.80.5/ossfs_1.80.5_centos7.0_x86_64.rpm</span><br><span class="line">$ sudo yum localinstall ossfs_1.80.5_centos7.0_x86_64.rpm</span><br></pre></td></tr></table></figure><h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor"></a></h2><p><strong>配置 bucket 信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> my-bucket:my-access-key-id:my-access-key-secret &gt; /etc/passwd-ossfs  <span class="comment"># 配置 key 和 secret</span></span><br><span class="line">$ chmod 640 /etc/passwd-ossfs   <span class="comment"># 修改文件权限</span></span><br><span class="line">$ ossfs my-bucket local_dir_path -ourl=my-oss-endpoint  <span class="comment"># 将 bucket mount 到本地文件夹</span></span><br></pre></td></tr></table></figure><p>如果机器使用了阿里云 ECS 实例，<code>-ourl</code> 可以使用内网 <code>endpoint</code> 来<strong>避免流量收费</strong>和<strong>提高速度</strong></p><p>挂载命令可以添加 <code>-f -d</code> 参数来让 ossfs 运行在前台并输出debug日志</p><p>你也可以使用 <a href="http://supervisord.org/" target="_blank" rel="noopener">supervisor</a> 来管理 ossfs 进程，方法详见 <a href="https://github.com/aliyun/ossfs/wiki/FAQ#18" target="_blank" rel="noopener">FAQ</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/aliyun/ossfs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ossfs&lt;/a&gt; 能让您在Linux/Mac OS X 系统中把Aliyun OSS bucket 挂载到本地文件 系统中，您能够便捷的通过本地文件系统操作OSS 上的对象，实现数据的共享。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://wxnacy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python 协程库 gevent</title>
    <link href="http://wxnacy.com/2019/03/28/gevent/"/>
    <id>http://wxnacy.com/2019/03/28/gevent/</id>
    <published>2019-03-27T16:01:35.000Z</published>
    <updated>2019-03-28T01:47:16.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/gevent/gevent" target="_blank" rel="noopener">gevent</a> 是一个基于 libev 的并发库。它为各种并发和网络相关的任务提供了整洁的API。</p></blockquote><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#yi-bu-zhi-xing">异步执行</a></li><li><a href="#yin-xing-jiao-chu-zhi-xing-quan">隐形交出执行权</a></li><li><a href="#hou-zi-bu-ding">猴子补丁</a></li><li><a href="#gevent-without-code">gevent without code</a></li></ul><!-- tocstop --></div><p>Python 中多线程的性能极差，替代它的另一种“并发”方式是协程。</p><p>Python 版本中协程一直在不断的进化</p><ul><li><code>yeild</code> python2.x</li><li><code>asynico + yield from</code> python3.4</li><li><code>asynico + await</code> python3.5</li></ul><p>而这个过程中，一直可以拿来就用的三方库就是 gevent</p><p>在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p><blockquote><p>在任何时刻，只有一个协程在运行。</p></blockquote><p>换句话说，协程并不会切换线程或进程（所以性能会比多线程高很多），而是在 IO 阻塞时，可以切换到其他的 Greenlet，等到适当时机再切换回来，这样减少阻塞浪费的时间，使其看起来像是在并发。所以协程可以解决 IO 密集的性能问题，而 CPU 密集则无能为力。</p><h2><span id="yi-bu-zhi-xing">异步执行</span><a href="#yi-bu-zhi-xing" class="header-anchor"></a></h2><p>首先安装 gevent</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install gevent</span><br></pre></td></tr></table></figure><p>我们来模拟程序的阻塞，使用 <code>gevent.sleep(0)</code> 主动让程序交出执行权。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_progress</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'[&#123;&#125;] Greenlet &#123;&#125; Process &#123;&#125; - Thread &#123;&#125;'</span>.format(</span><br><span class="line">        time.time(), gevent.getcurrent(), os.getpid(), threading.current_thread().ident))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print_func_progress()</span><br><span class="line">    print(<span class="string">'Running in foo'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'Explicit context switch to foo again'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print_func_progress()</span><br><span class="line">    print(<span class="string">'Explicit context to bar'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'Implicit context switch back to bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    gevent.joinall([</span><br><span class="line">        gevent.spawn(foo),</span><br><span class="line">        gevent.spawn(bar),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1553694796.1719072] Greenlet &lt;Greenlet at 0x10e9a4930: foo&gt; Process 2022 - Thread 4683818432</span></span><br><span class="line"><span class="comment"># Running in foo</span></span><br><span class="line"><span class="comment"># [1553694796.171974] Greenlet &lt;Greenlet at 0x10e9a4a60: bar&gt; Process 2022 - Thread 4683818432</span></span><br><span class="line"><span class="comment"># Explicit context to bar</span></span><br><span class="line"><span class="comment"># Explicit context switch to foo again</span></span><br><span class="line"><span class="comment"># Implicit context switch back to bar</span></span><br></pre></td></tr></table></figure><p>从打印结果中，可以看到无论是进程 <code>Process</code>，还是线程 <code>Thread</code>，整个过程都是没有变化的，所以再次确定了协程是单线程运行的。并且在运行过程中，协程在两个方法间切换，以减少阻塞浪费的时间。</p><h2><span id="yin-xing-jiao-chu-zhi-xing-quan">隐形交出执行权</span><a href="#yin-xing-jiao-chu-zhi-xing-quan" class="header-anchor"></a></h2><p>当我们的程序受限于网络的 IO 阻塞时，gevent 才能真正发挥实力，它提供了方法，可以隐形的交出上下文执行权，这样我们可以在不改变程序结构的情况下来实现协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent.monkey</span><br><span class="line">gevent.monkey.patch_socket()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_run_time</span><span class="params">(count, func, **kw)</span>:</span></span><br><span class="line">    b = timeit.default_timer()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        func(**kw)</span><br><span class="line">    print(func.__name__, <span class="string">'run &#123;&#125; times used &#123;&#125;s'</span>.format(count,</span><br><span class="line">        timeit.default_timer() -b ))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(pid)</span>:</span></span><br><span class="line">    print(<span class="string">'pid &#123;&#125; begin request url'</span>, pid)</span><br><span class="line">    response = requests.get(<span class="string">'http://baidu.com'</span>)</span><br><span class="line">    print(<span class="string">'pid &#123;&#125; get response status &#123;&#125;'</span>, pid, response.status_code)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronous</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">        fetch(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asynchronous</span><span class="params">()</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">        threads.append(gevent.spawn(fetch, i))</span><br><span class="line">    gevent.joinall(threads)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Synchronous:'</span>)</span><br><span class="line">print_func_run_time(<span class="number">1</span>, synchronous)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Asynchronous:'</span>)</span><br><span class="line">print_func_run_time(<span class="number">1</span>, asynchronous)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Synchronous:</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 0</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 0 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 1</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 1 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 2</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 2 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 3</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 3 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 4</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 4 200</span></span><br><span class="line"><span class="comment"># synchronous run 1 times used 0.13507633499102667s</span></span><br><span class="line"><span class="comment"># Asynchronous:</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 0</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 1</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 2</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 3</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; begin request url 4</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 0 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 4 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 3 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 1 200</span></span><br><span class="line"><span class="comment"># pid &#123;&#125; get response status &#123;&#125; 2 200</span></span><br><span class="line"><span class="comment"># asynchronous run 1 times used 0.03902721201302484s</span></span><br></pre></td></tr></table></figure><p>从结果中我们可以看到，使用 gevent 执行的程序，性能比顺序执行好了很多倍，而在功能函数中，我们也并没有主动交出执行权，这一些都归功于猴子补丁 <code>gevent.monkey</code></p><h2><span id="hou-zi-bu-ding">猴子补丁</span><a href="#hou-zi-bu-ding" class="header-anchor"></a></h2><p>猴子补丁(monkey patching) 得以让 gevent 变得更加强大。上面的代码中我们用到了 <code>gevent.monkey.patch_socket()</code>，它修改了 Python 的 socket 标准库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> socket</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>socket.socket</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">socket</span>.<span class="title">socket</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">from</span> <span class="title">gevent</span> <span class="title">import</span> <span class="title">monkey</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">monkey</span>.<span class="title">patch_socket</span><span class="params">()</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">socket</span>.<span class="title">socket</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">gevent</span>.<span class="title">_socket3</span>.<span class="title">socket</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>Python的运行环境允许我们在运行时修改大部分的对象，包括模块，类甚至函数。所以猴子补丁的实现原理很简单，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.__name__</span><br><span class="line"><span class="string">'json'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">patch_json</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    json.__name__ = <span class="string">'wjson'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>patch_json()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.__name__</span><br><span class="line"><span class="string">'wjson'</span></span><br></pre></td></tr></table></figure><p>在这种情况下，gevent能够 修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。通常情况下我们只需要调用 <code>gevent.monkey.patch_all()</code>，它可以修改所有可以兼容的模块</p><p><code>patch_all()</code> 方法语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_all</span><span class="params">(socket=True, dns=True, time=True, select=True, thread=True, os=True, ssl=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              httplib=False, # Deprecated, to be removed.</span></span></span><br><span class="line"><span class="function"><span class="params">              subprocess=True, sys=False, aggressive=True, Event=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              builtins=True, signal=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              queue=True,</span></span></span><br><span class="line"><span class="function"><span class="params">              **kwargs)</span>:</span></span><br></pre></td></tr></table></figure><p>如果不想修改某个模块，直接传参即可，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch_all(socket=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>或者在该方法之后导入，让原始模块覆盖掉 monkey 的修改即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>monkey.patch_all()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> select</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select.select</span><br><span class="line">&lt;function select at <span class="number">0x100e40f28</span>&gt;</span><br></pre></td></tr></table></figure><h2><span id="gevent-without-code">gevent without code</span><a href="#gevent-without-code" class="header-anchor"></a></h2><p>猴子补丁如此厉害，好像可以不用主动写 gevent 代码就可以实现。其实真的可以不用任何 gevent 代码，就可以让程序实现协程，只需要使用可以调用 gevent 的容器来启动程序即可。</p><p>我们来使用 gunicorn 来启动一个 Flask 程序。</p><p>如果你不了解 gunicorn，可以看我的这篇文章<a href="/2017/08/15/python-2017-08-15-gunicorn-run/">使用 gunicorn 启动你的项目</a></p><p>安装模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install gunicorn</span><br><span class="line">$ pip install flask</span><br></pre></td></tr></table></figure><p>编辑文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch gevent_without_code.py</span><br><span class="line">$ vim gevent_without_code.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">print(socket.socket)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/for')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"for"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/bar')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><p>不使用 gevent 启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gunicorn gevent_without_code:app</span><br><span class="line"></span><br><span class="line">[2019-03-27 23:06:53 +0800] [53872] [INFO] Starting gunicorn 19.7.1</span><br><span class="line">[2019-03-27 23:06:53 +0800] [53872] [INFO] Listening at: http://127.0.0.1:8000 (53872)</span><br><span class="line">[2019-03-27 23:06:53 +0800] [53872] [INFO] Using worker: sync</span><br><span class="line">[2019-03-27 23:06:53 +0800] [53932] [INFO] Booting worker with pid: 53932</span><br><span class="line">&lt;class <span class="string">'socket.socket'</span>&gt;</span><br><span class="line">[2019-03-27 23:06:56 +0800] [53872] [INFO] Handling signal: winch</span><br></pre></td></tr></table></figure><p>gunicorn 默认启动一个 8000 端口的 web 程序，我们有两个接口 <code>/for</code> 强制睡眠 4 秒钟，<code>/bar</code> 直接返回结果</p><p>这时候我们先访问 <code>/for</code> 在访问 <code>/bar</code> 会发生阻塞</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/gevent1.gif" alt="gevent1"></p><p><code>/bar</code> 需要等待 <code>/for</code> 返回结果后才能执行，这显然不是一个健康的程序。我们试试使用 gevent。</p><p><code>&lt;ctrl&gt; + c</code> 停掉程序，重新启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gunicorn gevent_without_code:app -k gevent</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63766] [INFO] Starting gunicorn 19.7.1</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63766] [INFO] Listening at: http://127.0.0.1:8000 (63766)</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63766] [INFO] Using worker: gevent</span><br><span class="line">[2019-03-27 23:16:41 +0800] [63826] [INFO] Booting worker with pid: 63826</span><br><span class="line">&lt;class <span class="string">'gevent._socket3.socket'</span>&gt;</span><br></pre></td></tr></table></figure><p>再次访问两个接口，效果非常明显</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/gevent2.gif" alt="gevent2"></p><p>当 <code>/for</code> 阻塞时，gevent 直接跳过执行 <code>/bar</code>，等阻塞过后，在继续执行 <code>/for</code>。</p><p>这里我们一句 gevent 代码都没写，那它是什么实现的呢？</p><p>如果你留意刚才的启动日志，会发现我们代码有句 <code>print(socket.socket)</code>，在使用 gevent 前后是有不同的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;class <span class="string">'socket.socket'</span>&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&lt;class <span class="string">'gevent._socket3.socket'</span>&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>就像我们上面讲到的那样，gevent 在这里隐形的调用了 <code>gevent.monkey.patch_all()</code> 方法，使得相关的程序都自动变成了协程可调用的状态。</p><p>不管你代码写的怎么样，用 gevent 来启动你的项目吧，一定会让你觉得物有所值。</p><ul><li><a href="https://github.com/wxnacy/study/tree/master/python/gevent_demo" target="_blank" rel="noopener">本文 demo 源码</a></li><li><a href="https://github.com/gevent/gevent" target="_blank" rel="noopener">gevent 源码</a></li><li><a href="http://hhkbp2.github.io/gevent-tutorial/" target="_blank" rel="noopener">gevent 程序员指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gevent/gevent&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gevent&lt;/a&gt; 是一个基于 libev 的并发库。它为各种并发和网络相关的任务提供了整洁的API。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 访问中文文档</title>
    <link href="http://wxnacy.com/2019/03/27/python-doc-zh/"/>
    <id>http://wxnacy.com/2019/03/27/python-doc-zh/</id>
    <published>2019-03-27T06:42:32.000Z</published>
    <updated>2019-03-27T07:11:12.743Z</updated>
    
    <content type="html"><![CDATA[<p>今天使用中文 Google 时，以外发现了 Python 的中文文档，地址： <a href="https://docs.python.org/zh-cn" target="_blank" rel="noopener">https://docs.python.org/zh-cn</a></p><a id="more"></a><p>它会默认跳转到 Python 3.7 的文档</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/python-doc-zh_1411_705.png" alt="python"></p><p>有意思的是，如果使用地址：<a href="https://docs.python.org" target="_blank" rel="noopener">https://docs.python.org</a> 打开文档，左上角是看不到 <code>zh-cn</code> 选项的，大概是官方认为还没到直接开发的地步，因为确实很多东西还没做好。</p><p>比如搜索功能，现在还是只能搜索英文，如何的中文信息都搜索不到。</p><p>很多文档也还保留了大量的英文内容。</p><p>不过这不影响，一些基础模块的查看，毕竟有和没有是两个概念，这对很多初学者也是很重要的。</p><!-- 现在文档有 `2.7` `3.5` `3.6` `3.7` `3.8` 多个版本 --><p>文档左侧可以跳转其他版本，但是有个坑，直接点过去依然进入的是英文页面，我们需要<br>修改下地址，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.python.org/3.6/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.python.org/zh-cn/3.6/</span><br></pre></td></tr></table></figure><p>但是 <code>3.5</code> 版本修改后是 404，说明官方还完全没有开始这个版本的翻译工作，这里也是希望官方可以尽快完善。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天使用中文 Google 时，以外发现了 Python 的中文文档，地址： &lt;a href=&quot;https://docs.python.org/zh-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/zh-cn&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 计时器 timeit</title>
    <link href="http://wxnacy.com/2019/03/26/python-timeit/"/>
    <id>http://wxnacy.com/2019/03/26/python-timeit/</id>
    <published>2019-03-26T14:10:02.000Z</published>
    <updated>2019-03-26T14:10:02.111Z</updated>
    
    <content type="html"><![CDATA[<p>网上很多帖子讨论 Python 中计时用 <code>time.clock()</code> 还是用 <code>time.time()</code>。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#time-clock-vs-time-time">time.clock() vs time.time()</a></li><li><a href="#timeit">timeit</a></li><li><a href="#ming-ling-xing-yu-fa">命令行语法</a></li></ul><!-- tocstop --></div><h2><span id="time-clock-vs-time-time">time.clock() vs time.time()</span><a href="#time-clock-vs-time-time" class="header-anchor"></a></h2><ul><li><code>time.clock()</code> 计算的是 CPU 的时间，在 windows 平台上精度比较高</li><li><code>time.time()</code> 计算的是程序的运行时间，会受到机器负载的影响，除了 windows 以外的平台精度比较高</li></ul><p>所以我们可以按照平台来使用不同的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.platform == <span class="string">"win32"</span>:</span><br><span class="line">    <span class="comment"># On Windows, the best timer is time.clock()</span></span><br><span class="line">    default_timer = time.clock</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># On most other platforms the best timer is time.time()</span></span><br><span class="line">    default_timer = time.time</span><br></pre></td></tr></table></figure><p>或者呢，直接使用 <code>timeit</code> 模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">b = timeit.default_timer()</span><br><span class="line"><span class="comment"># to some</span></span><br><span class="line">e = timeit.default_timer()</span><br><span class="line">print(e - b)</span><br></pre></td></tr></table></figure><p><code>timeit.default_timer()</code> 可以自动选择当前平台适合的计时器，因为它的源代码就是上面那段判断代码。</p><p>下面我们重点来介绍下 <code>timeit</code> 模块</p><p><code>timeit</code> 模块提供了一种简单的方法来计算一小段Python代码。 它既有命令行界面，也有可调用界面。 它避免了许多用于测量执行时间的常见陷阱。</p><h2><span id="timeit">timeit</span><a href="#timeit" class="header-anchor"></a></h2><p><strong>命令行使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m timeit <span class="string">'"-".join(str(n) for n in range(100))'</span></span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">40.3</span> usec per loop</span><br></pre></td></tr></table></figure><p>默认情况下，命令行对小段代码，重复执行三个循环，每个循环执行 10000 次，其中最好的用了 40.3 秒</p><p><strong>代码块中使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># attribute is missing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"""\</span></span><br><span class="line"><span class="string"><span class="meta">... </span>try:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    str.__nonzero__</span></span><br><span class="line"><span class="string"><span class="meta">... </span>except AttributeError:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    pass</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(s)</span><br><span class="line"><span class="number">0.5832341330096824</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(s, number=<span class="number">1000</span>)</span><br><span class="line"><span class="number">0.000628526002401486</span></span><br></pre></td></tr></table></figure><p><code>number</code> 不指定时，默认为 <code>default_number = 1000000</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.repeat(s)</span><br><span class="line">[<span class="number">0.5949273270089179</span>, <span class="number">0.6405833000026178</span>, <span class="number">0.5868908820120851</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.repeat(s, repeat=<span class="number">4</span>)</span><br><span class="line">[<span class="number">0.5963048749981681</span>, <span class="number">0.5834796829876723</span>, <span class="number">0.5749933830084046</span>, <span class="number">0.5814367970015155</span>]</span><br></pre></td></tr></table></figure><p>增加重复次数，使用 <code>repeat()</code> 方法，不指定 <code>repeat</code> 时，默认 <code>default_repeat = 3</code></p><h2><span id="ming-ling-xing-yu-fa">命令行语法</span><a href="#ming-ling-xing-yu-fa" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m timeit [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement ...]</span><br></pre></td></tr></table></figure><ul><li><code>-n N, --number=N</code> 执行 <code>statement</code> 的次数</li><li><code>-r N, --repeat=N</code> 循环的重复次数，默认：3</li><li><code>-s S, --setup=S</code> 最初要执行的语句，默认：pass</li><li><code>-t, --time</code> 使用 <code>time.time()</code> 计时，在 windows 以外平台默认使用该模式</li><li><code>-c, --clock</code> 使用 <code>time.clock()</code> 计时，在 windows 平台默认使用该模式</li><li><code>-v, --verbose</code> 打印原始计时结果，得到更多数字精度</li><li><code>-h, --help</code> 帮助信息</li></ul><p>当 <code>-n</code> 不指定时，程序会自动执行 10 的倍数，使执行时间不少于 0.2 秒</p><p><code>-s</code> 可以执行一段前置代码，这在很多场景是很有用的</p><p><strong>命令行中使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m timeit -s <span class="string">'text = "sample string"; char = "g"'</span>  <span class="string">'char in text'</span></span><br><span class="line">10000000 loops, best of 3: 0.0877 usec per loop</span><br></pre></td></tr></table></figure><p><strong>代码块中使用</strong></p><p>在代码快中，这个参数更有用处，我们不必把代码都写在字符串中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Stupid test function"""</span></span><br><span class="line">    L = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        L.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> timeit</span><br><span class="line">    print(timeit.timeit(<span class="string">"test()"</span>, setup=<span class="string">"from __main__ import test"</span>))</span><br></pre></td></tr></table></figure><ul><li>文档：<a href="https://docs.python.org/2/library/timeit.html" target="_blank" rel="noopener">https://docs.python.org/2/library/timeit.html</a></li><li>源代码：<a href="https://github.com/python/cpython/blob/2.7/Lib/timeit.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/2.7/Lib/timeit.py</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上很多帖子讨论 Python 中计时用 &lt;code&gt;time.clock()&lt;/code&gt; 还是用 &lt;code&gt;time.time()&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>adb 如何连接夜神模拟器</title>
    <link href="http://wxnacy.com/2019/03/25/adb-connect-yeshen/"/>
    <id>http://wxnacy.com/2019/03/25/adb-connect-yeshen/</id>
    <published>2019-03-25T07:16:27.000Z</published>
    <updated>2019-03-25T07:23:11.548Z</updated>
    
    <content type="html"><![CDATA[<p>夜神模拟器无法自动出现在 <code>adb devices</code> 列表中，需要先打开开发者模式</p><a id="more"></a><p>步骤如下：</p><ul><li>点击<code>设置</code> -》<code>关于平板电脑</code> -》连续点击 5 次版本号，进入开发者模式</li><li>重新进入设置，滑到最下边，进入开发者模式，并打开 USB 调试模式</li><li>链接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb connect 127.0.0.1:62001</span><br></pre></td></tr></table></figure><ul><li>查看</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;夜神模拟器无法自动出现在 &lt;code&gt;adb devices&lt;/code&gt; 列表中，需要先打开开发者模式&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wxnacy.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 Redis watch 完成秒杀活动防止超卖 demo</title>
    <link href="http://wxnacy.com/2019/03/17/python-redis-watch/"/>
    <id>http://wxnacy.com/2019/03/17/python-redis-watch/</id>
    <published>2019-03-17T02:49:48.000Z</published>
    <updated>2019-03-17T02:49:48.511Z</updated>
    
    <content type="html"><![CDATA[<p>在做类似抢购活动的程序，我们通常会使用“乐观锁”思路，既保证库存不会超卖，也能够应付大并发的情况，Redis 中 watch 就可以实现“乐观锁”。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>Redis 中的事务 <code>multi/exec</code> 可以保证数据的原子性，但不能像 Mysql 那样在事务中出错回滚数据，而用 <code>watch</code> 来监听数据，就可以实现类似的功能。</p><p>先用 <code>watch</code> 监听后，在接下来事务的过程，如果数据被修改，则在执行 <code>exec</code> 时，则会报错，我们可以根据业务选择重试和返回结果。</p><p>Python 中通过管道 Pipeline 来实现 Redis 事务相关操作。</p><p><strong>初始化线程池</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接池</span></span><br><span class="line">pool = redis.ConnectionPool(host = <span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 初始化 redis</span></span><br><span class="line">r = redis.Redis(connection_pool = pool)</span><br></pre></td></tr></table></figure><p><strong>初始化管道</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe = r.pipeline()</span><br></pre></td></tr></table></figure><p><strong>使用事务</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">KEY = <span class="string">'count'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pipe.watch(KEY)         <span class="comment"># 监听库存</span></span><br><span class="line">    pipe.multi()            <span class="comment"># 开始事务</span></span><br><span class="line">    pipe.set(KEY, <span class="number">2</span>)        <span class="comment"># 执行操作</span></span><br><span class="line">    pipe.execute()          <span class="comment"># 执行事务</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 事务执行过程中，如果数据被修改，则抛出异常，程序可以选择重试或退出</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    pipe.reset()            <span class="comment"># 重置管道，为重试做准备</span></span><br></pre></td></tr></table></figure><p>通过这些操作，我们可以先实现一个防止商品超卖的 demo。</p><p>代码位置 <a href="https://github.com/wxnacy/study/blob/master/python/redis_demo/watch_demo.py" target="_blank" rel="noopener">watch_demo.py</a></p><p><strong>运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ python watch_demo.py</span><br><span class="line">用户 0 抢购成功，商品剩余 9</span><br><span class="line">用户 1 抢购成功，商品剩余 8</span><br><span class="line">用户 2 抢购失败，重试一次</span><br><span class="line">用户 3 抢购成功，商品剩余 7</span><br><span class="line">用户 5 抢购失败，重试一次</span><br><span class="line">用户 4 抢购失败，重试一次</span><br><span class="line">用户 2 抢购失败，重试一次</span><br><span class="line">用户 6 抢购失败，重试一次</span><br><span class="line">用户 7 抢购失败，重试一次</span><br><span class="line">用户 9 抢购失败，重试一次</span><br><span class="line">用户 8 抢购成功，商品剩余 6</span><br><span class="line">用户 10 抢购成功，商品剩余 5</span><br><span class="line">用户 5 抢购成功，商品剩余 4</span><br><span class="line">用户 12 抢购失败，重试一次</span><br><span class="line">用户 6 抢购失败，重试一次</span><br><span class="line">用户 13 抢购成功，商品剩余 3</span><br><span class="line">用户 11 抢购失败，重试一次</span><br><span class="line">用户 14 抢购失败，重试一次</span><br><span class="line">用户 2 抢购失败，重试一次</span><br><span class="line">用户 4 抢购失败，重试一次</span><br><span class="line">用户 9 抢购成功，商品剩余 2</span><br><span class="line">用户 7 抢购失败，重试一次</span><br><span class="line">用户 12 抢购成功，商品剩余 1</span><br><span class="line">用户 2 抢购停止，商品卖完</span><br><span class="line">用户 6 抢购失败，重试一次</span><br><span class="line">用户 14 抢购失败，重试一次</span><br><span class="line">用户 4 抢购停止，商品卖完</span><br><span class="line">用户 11 抢购成功，商品剩余 0</span><br><span class="line">用户 7 抢购停止，商品卖完</span><br><span class="line">用户 6 抢购停止，商品卖完</span><br><span class="line">用户 14 抢购停止，商品卖完</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做类似抢购活动的程序，我们通常会使用“乐观锁”思路，既保证库存不会超卖，也能够应付大并发的情况，Redis 中 watch 就可以实现“乐观锁”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
      <category term="redis" scheme="http://wxnacy.com/tags/redis/"/>
    
  </entry>
  
</feed>
