<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-04-24T05:31:54.732Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 如何给屏幕打印信息加上颜色</title>
    <link href="http://wxnacy.com/2019/04/24/python-print-color/"/>
    <id>http://wxnacy.com/2019/04/24/python-print-color/</id>
    <published>2019-04-24T05:31:54.000Z</published>
    <updated>2019-04-24T05:31:54.732Z</updated>
    
    <content type="html"><![CDATA[<p>以前写过 <a href="/2018/09/07/go-fmt-color/">Go 如何给屏幕打印信息加上颜色</a>，想当然的以为 Python 也一样，结果被打脸，他们的配置还是有一些区别的。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#yu-fa">语法</a></li><li><a href="#gong-ju-hua">工具化</a></li></ul><!-- tocstop --></div><h2><span id="yu-fa">语法</span><a href="#yu-fa" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'\033[显示方式;字体色;背景色m文本\033[0m'</span>)</span><br><span class="line"><span class="comment"># 三种设置都可以忽略不写，都不写则为默认输出</span></span><br></pre></td></tr></table></figure><p>配置如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字体 背景 颜色</span></span><br><span class="line"><span class="comment"># ---------------------------------------</span></span><br><span class="line"><span class="comment"># 30  40  黑色</span></span><br><span class="line"><span class="comment"># 31  41  红色</span></span><br><span class="line"><span class="comment"># 32  42  绿色</span></span><br><span class="line"><span class="comment"># 33  43  黄色</span></span><br><span class="line"><span class="comment"># 34  44  蓝色</span></span><br><span class="line"><span class="comment"># 35  45  紫红色</span></span><br><span class="line"><span class="comment"># 36  46  青蓝色</span></span><br><span class="line"><span class="comment"># 37  47  白色</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 显示方式</span></span><br><span class="line"><span class="comment"># -------------------------</span></span><br><span class="line"><span class="comment">#  0  终端默认设置</span></span><br><span class="line"><span class="comment">#  1  高亮显示</span></span><br><span class="line"><span class="comment">#  4  使用下划线</span></span><br><span class="line"><span class="comment">#  5  闪烁</span></span><br><span class="line"><span class="comment">#  7  反白显示</span></span><br><span class="line"><span class="comment">#  8  不可见</span></span><br></pre></td></tr></table></figure><p>举几个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高亮显示，字体紫红色，背景白色</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[1;35;47m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor1.png" alt="1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认显示，字体紫红色，背景白色</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[35;47m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor2.png" alt="2"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认显示，字体紫红色，背景默认</span></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">print(<span class="string">f'\033[35m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pycolor3.png" alt="3"></p><p>往往我们更关注字体颜色，几个字体颜色效果如下，我用的 iTerm2 的深色背景，效果会有点偏差</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/output-color.png" alt="4"></p><p>如果你想看所有组合的颜色，可以查看这篇文章 <a href="https://www.cnblogs.com/journeyonmyway/p/4317108.html" target="_blank" rel="noopener">Go语言在Linux环境下输出彩色字符</a></p><h2><span id="gong-ju-hua">工具化</span><a href="#gong-ju-hua" class="header-anchor"></a></h2><p>这个语法看起来还是很别扭的，平常使用我们可以封装起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    BLACK = <span class="number">30</span></span><br><span class="line">    RED = <span class="number">31</span></span><br><span class="line">    GREEN = <span class="number">32</span></span><br><span class="line">    YELLOW = <span class="number">33</span></span><br><span class="line">    BLUE = <span class="number">34</span></span><br><span class="line">    MAGENTA = <span class="number">35</span></span><br><span class="line">    CYAN = <span class="number">36</span></span><br><span class="line">    WHITE = <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_color</span><span class="params">(text: str, fg: Color = Color.BLACK.value)</span>:</span></span><br><span class="line">    print(<span class="string">f'\033[<span class="subst">&#123;fg&#125;</span>m<span class="subst">&#123;text&#125;</span>\033[0m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印红色文字</span></span><br><span class="line">print_color(<span class="string">'Hello World'</span>, fg = Color.RED.value)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前写过 &lt;a href=&quot;/2018/09/07/go-fmt-color/&quot;&gt;Go 如何给屏幕打印信息加上颜色&lt;/a&gt;，想当然的以为 Python 也一样，结果被打脸，他们的配置还是有一些区别的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Redis get 报错 a key holding the wrong kind of value</title>
    <link href="http://wxnacy.com/2019/04/23/redis-error-wrong-kind/"/>
    <id>http://wxnacy.com/2019/04/23/redis-error-wrong-kind/</id>
    <published>2019-04-23T07:45:17.000Z</published>
    <updated>2019-04-23T07:56:25.497Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现使用 <code>redis-cli</code> 命令来获取数据报错，如下</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p>比较费解，因为线上程序并没有报错，时间紧迫也没有多关注，今天有时间感觉搜索了下。</p><p>这个错误是因为对 <code>key</code> 的 <code>value</code> 使用了错误的操作，比如 <code>lpush</code> 的数据只能使用 <code>lrange</code> 获取数据，使用 <code>get</code> 就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush test_key 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get test_key</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; lrange test_key 0 1</span><br><span class="line">1) <span class="string">"1"</span></span><br></pre></td></tr></table></figure><p>同样的使用 <code>set</code> 报错的数据，在使用 <code>lpush</code> 就会报错。</p><p>因为是很久之前写的代码，已经忘记了是用 <code>lpush</code> 保存的数据，所以在命令行中使用 <code>get</code> 自然报错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现使用 &lt;code&gt;redis-cli&lt;/code&gt; 命令来获取数据报错，如下&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://wxnacy.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Vim 执行 Shell 命令（2）</title>
    <link href="http://wxnacy.com/2019/04/18/vim-in-shell/"/>
    <id>http://wxnacy.com/2019/04/18/vim-in-shell/</id>
    <published>2019-04-18T14:08:20.000Z</published>
    <updated>2019-04-18T14:34:35.327Z</updated>
    
    <content type="html"><![CDATA[<p>前两天我写了在 Vim 中执行 Shell 命令，传送门 <a href="/2019/04/15/vim-run-shell/">Vim 执行 Shell 命令（1）</a></p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#ctrl-z"><code>&lt;ctrl-z&gt;</code></a></li><li><a href="#shell">:shell</a></li></ul><!-- tocstop --></div><p>今天我们来说如何在 Vim 和 Shell 间切换。</p><h2><span id="lt-ctrl-z-gt"><code>&lt;ctrl-z&gt;</code></span><a href="#lt-ctrl-z-gt" class="header-anchor"></a></h2><p>使用 <code>&lt;ctrl-z&gt;</code> 可以将当前 Vim 挂起，然后回到 Shell 模式，可以执行任何命令后，再使用 <code>fg</code> 或者 <code>fg %vim</code> 返回 Vim。</p><p>如果连续挂起多个，可以使用 <code>fg %1</code> 或者 <code>fg %vim filename</code> 回到 Vim。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell5.gif" alt="1"></p><p>这种方式来回切换多少有点不方便，直接使用 command 模式要更方便一点。</p><h2><span id="shell">:shell</span><a href="#shell" class="header-anchor"></a></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">sh</span>[ell]</span><br></pre></td></tr></table></figure><p>输入该命令即可进入 Shell 环境，然后使用 <code>&lt;ctrl-d&gt;</code> 即可返回 Vim。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell6.gif" alt="2"></p><p>这个流程显得顺畅很多，另外我们可以使用映射来做到只用 <code>&lt;ctrl-d&gt;</code> 来回切换。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">noremap</span> <span class="symbol">&lt;c-d&gt;</span> :<span class="keyword">sh</span><span class="symbol">&lt;cr&gt;</span>  <span class="string">" 修改映射"</span></span><br></pre></td></tr></table></figure><p>这样虽然方便，但 <code>&lt;ctrl-d&gt;</code> 本来是向下翻半页，很挺常用的，是否要更换这个映射还有待斟酌。</p><p>因为 <code>:sh</code> 是主动进入 Shell 环境，所以它可以指定命令，比如你想使用 <code>fish</code> 则可以这样</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">shell</span>=/usr/local/bin/fish</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell7.gif" alt="3"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天我写了在 Vim 中执行 Shell 命令，传送门 &lt;a href=&quot;/2019/04/15/vim-run-shell/&quot;&gt;Vim 执行 Shell 命令（1）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Python 获取当前作用域全部参数的内置方法 locals()</title>
    <link href="http://wxnacy.com/2019/04/17/python-locals/"/>
    <id>http://wxnacy.com/2019/04/17/python-locals/</id>
    <published>2019-04-17T10:23:31.000Z</published>
    <updated>2019-04-17T13:38:29.682Z</updated>
    
    <content type="html"><![CDATA[<p>在写程序时，经常会碰见传递过多参数的情况。先看一个例子</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(id, name, age, **kw)</span>:</span></span><br><span class="line">    amount = <span class="number">1</span></span><br><span class="line">    duration = <span class="number">10</span></span><br><span class="line">    func2(id = id, name = name, age = age, amount = amount, **kw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(**kw)</span>:</span></span><br><span class="line">    print(kw)</span><br></pre></td></tr></table></figure><p>在 <code>func1()</code> 给 <code>func2()</code> 传递参数，一个一个的写真的很痛苦，写一次还好，关键是到处都有这种情况。</p><p>可不可以将想要的参数打包直接传递过去呢？</p><p>内置方法 <code>locals()</code> 就可以达到这个效果，它可以实时收集当前作用域的参数，并返回一个字典。</p><p>先在全局范围内看看有哪些参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(locals())</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python locals_demo.py</span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader object at 0x102c75860&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;, <span class="string">'__file__'</span>: <span class="string">'locals_demo.py'</span>, <span class="string">'__cached__'</span>: None&#125;</span><br></pre></td></tr></table></figure><p>可能你到没注意到一个空文件里都有这么多的内置参数。</p><p><code>locals()</code> 收集参数是实时进行的，比如我们定义一个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(locals())</span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    print(locals())</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python locals_demo.py</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader object at 0x1083d5860&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;, <span class="string">'__file__'</span>: <span class="string">'locals_demo.py'</span>, <span class="string">'__cached__'</span>: None&#125;</span><br><span class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader object at 0x1083d5860&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;, <span class="string">'__file__'</span>: <span class="string">'locals_demo.py'</span>, <span class="string">'__cached__'</span>: None, <span class="string">'name'</span>: <span class="string">'wxnacy'</span>&#125;</span><br></pre></td></tr></table></figure><p>第二次打印的结果中，就多出了刚刚定义的参数 <code>name</code></p><p>在方法中使用也是如此</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(**kw)</span>:</span></span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    print(locals())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    func(url = <span class="string">'https://wxnacy.com'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python locals_demo.py</span><br><span class="line">&#123;<span class="string">'kw'</span>: &#123;<span class="string">'url'</span>: <span class="string">'https://wxnacy.com'</span>&#125;, <span class="string">'name'</span>: <span class="string">'wxnacy'</span>&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>locals()</code> 方法的值是动态变的，所以我们可以先用变量储存起来，并且记得去掉不需要的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(id, age, **kw)</span>:</span></span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    args = locals()</span><br><span class="line">    args.pop(<span class="string">'name'</span>)</span><br><span class="line">    print(args)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(id, age, **kw)</span>:</span></span><br><span class="line">    args = locals()</span><br><span class="line">    name = <span class="string">'wxnacy'</span></span><br><span class="line">    print(args)</span><br></pre></td></tr></table></figure><p>现在再来回顾下开始的问题，这下解决方式简单了很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(id, name, age, **kw)</span>:</span></span><br><span class="line">    amount = <span class="number">1</span></span><br><span class="line">    args = locals()</span><br><span class="line">    duration = <span class="number">10</span></span><br><span class="line">    func2(**args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(**kw)</span>:</span></span><br><span class="line">    print(kw)</span><br></pre></td></tr></table></figure><p>喔噢，我爱 Python。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写程序时，经常会碰见传递过多参数的情况。先看一个例子&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用 ffmpeg 分离视频流和音频流</title>
    <link href="http://wxnacy.com/2019/04/16/ffmpeg-split-video-audio/"/>
    <id>http://wxnacy.com/2019/04/16/ffmpeg-split-video-audio/</id>
    <published>2019-04-16T14:41:36.000Z</published>
    <updated>2019-04-16T15:19:45.363Z</updated>
    
    <content type="html"><![CDATA[<p>通常情况下，我们提到“视频”会有两个要素，声音和画面。但其实严格意义上说视频中含有<strong>视频流</strong>和<strong>音频流</strong>，如果一个视频只有视频流，那么就只有画面没有声音，反之亦然。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>我有听英语电影原声的习惯，但是总是放视频很不方便，网上的资源又不是太称心如意，就想着自己动手来分离，我首先想到的是 ffmpeg。</p><p>我们先来看看视频中的这两个流</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/ffsplit1_713.png" alt="1"></p><p>执行该命令可以直接查看视频的信息，其中就有刚才的提到的<strong>视频流（Video: h264）</strong>和<strong>音频流（Audio: aac）</strong></p><p>使用参数 <code>-vcodec copy -an</code> 和 <code>-acodec copy -vn</code> 可以分离出视频流和音频流。</p><p><strong>分离视频</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 -vcodec copy -an mav.mp4</span><br></pre></td></tr></table></figure><p>等待转码成功后，观看 <code>mav.mp4</code> 发现已经没有声音了，查看发现只有一个流</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/ffsplit2_667.png" alt="2"></p><p><strong>分离音频</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 -acodec copy -vn m.m4a</span><br></pre></td></tr></table></figure><p>再次查看音频流信息</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/ffsplit3_702.png" alt="3"></p><p>网上很多博客都是直接甩一个类似这样的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 -acodec copy -vn m.mp3</span><br></pre></td></tr></table></figure><p>如果你执行的话，多半会报错，因为查看视频信息，很可能像例子中的音频流一样是 aac 格式的，什么是 aac 格式呢</p><blockquote><p>高级音频编码（英语：Advanced Audio Coding，AAC），出现于1997年，为一种基于MPEG-2的有损数字音频压缩的专利音频编码标准，由Fraunhofer IIS、杜比实验室、AT&amp;T、Sony、Nokia等公司共同开发。2000年，MPEG-4标准在原本的基础上加上了PNS（Perceptual Noise Substitution）等技术，并提供了多种扩展工具。为了区别于传统的MPEG-2 AAC又称为MPEG-4 AAC。其作为MP3的后继者而被设计出来，在相同的比特率之下，AAC相较于MP3通常可以达到更好的声音质量[2]。</p></blockquote><p>关键是下面这句</p><blockquote><p>AAC 被YouTube、iPhone、iPod、 iPad、 任天堂DSi、任天堂3DS、iTunes、DivX、PlayStation 3和多款Nokia 40系列、Sony Ericsson手机采用为默认的音频编码格式，并且被PlayStation Vita、Wii、Sony Walkman MP3系列及随后的Android、BlackBerry等移动操作系统支持。</p></blockquote><p>也就是说，现在很多视频的音频流都将是这个格式，那直接分离 <code>mp3</code> 格式的音频自然会报错。</p><p>那我就是想要 <code>mp3</code> 的音频该怎么办呢？</p><p>再来一次转码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i m.m4a m.mp3</span><br></pre></td></tr></table></figure><p>或者直接将视频转码为 <code>mp3</code> 格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i mavel4.mp4 m.mp3</span><br></pre></td></tr></table></figure><ul><li><a href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E9%9F%B3%E8%A8%8A%E7%B7%A8%E7%A2%BC#%E7%9B%B8%E8%BC%83%E6%96%BCMP3%E7%9A%84%E6%94%B9%E9%80%B2" target="_blank" rel="noopener">高级音频编码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常情况下，我们提到“视频”会有两个要素，声音和画面。但其实严格意义上说视频中含有&lt;strong&gt;视频流&lt;/strong&gt;和&lt;strong&gt;音频流&lt;/strong&gt;，如果一个视频只有视频流，那么就只有画面没有声音，反之亦然。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ffmpeg" scheme="http://wxnacy.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Vim 执行 Shell 命令（1）</title>
    <link href="http://wxnacy.com/2019/04/15/vim-run-shell/"/>
    <id>http://wxnacy.com/2019/04/15/vim-run-shell/</id>
    <published>2019-04-15T13:50:52.000Z</published>
    <updated>2019-04-18T14:36:00.164Z</updated>
    
    <content type="html"><![CDATA[<p>Vim 编写程序时，无须退出 Vim 或者新建 Terminal 窗口即可执行 Shell 命令。</p><a id="more"></a><p>在 Mac 环境开发时，可以使用 Tmux 搭配 Vim，一个窗口编写，一个窗口执行。然而线上环境往往不能安装过于复杂的开发环境，那每次都反复的进入退出很是让人烦躁，其实 Vim 中可以直接运行 Shell 命令。</p><div class="toc"><!-- toc --><ul><li><a href="#zhi-xing">执行</a></li><li><a href="#du-qu">读取</a></li><li><a href="#xie-ru">写入</a></li><li><a href="#ti-huan">替换</a></li></ul><!-- tocstop --></div><h2><span id="zhi-xing">执行</span><a href="#zhi-xing" class="header-anchor"></a></h2><p><strong>语法</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!command</span><br></pre></td></tr></table></figure><p><code>command</code> 可以是任何一个 Shell 命令，回车执行后，会在 Shell 中显示结果，再次回车返回 Vim。先来看个动图</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell1.gif" alt="1"></p><h2><span id="du-qu">读取</span><a href="#du-qu" class="header-anchor"></a></h2><p>该模式下还可以直接把执行结果，读取到 Vim 中，这是很神奇的功能。</p><p><strong>语法</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r !command</span><br></pre></td></tr></table></figure><p>执行该命令后，Shell 命令结果会自动复制到当前行的下面</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell2.gif" alt="2"></p><p>前面输入数字，可以复制到第 N 行的下面，比如第二行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="number">2</span>r !command</span><br></pre></td></tr></table></figure><h2><span id="xie-ru">写入</span><a href="#xie-ru" class="header-anchor"></a></h2><p>能读取，就能写入，使用 <code>w</code> 可以将制定行数的文本通过管道传给想要执行的命令</p><p><strong>语法</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:n1, n2w !command</span><br></pre></td></tr></table></figure><p>比如我们想要将第 7 到 10 行的内容传给 <code>wc</code> 命令，获取行数，单词数和字符数。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="number">7</span>, <span class="number">10</span><span class="keyword">w</span> !wc</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell3.gif" alt="3"></p><h2><span id="ti-huan">替换</span><a href="#ti-huan" class="header-anchor"></a></h2><p>最后要说的是替换，它好像将上边两种命令结合一般，这次直接输入行数范围即可</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:n1, n2 !wc</span><br></pre></td></tr></table></figure><p>还是上面的例子，我们重新执行一次</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/vim-shell4.gif" alt="4"></p><p>最后提一句 <code>:!!</code> 可以执行上一次执行的命令，没错，就像 Shell 中一样。</p><p>直接在 Vim 中执行 Shell 命令，只是一种方式，我们还可以直接切换到 Shell 模式在执行复杂的操作。</p><p>不过今天先到这里，想要学好 Vim，一次输入太多知识不是个好习惯，还需要大量的练习来巩固它，下一章我们再来探讨怎样切换 Shell 环境。</p><p>传送门 <a href="/2019/04/18/vim-in-shell/">Vim 执行 Shell 命令（2）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vim 编写程序时，无须退出 Vim 或者新建 Terminal 窗口即可执行 Shell 命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://wxnacy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>使用 goss 构建 Github 图床</title>
    <link href="http://wxnacy.com/2019/04/14/goss/"/>
    <id>http://wxnacy.com/2019/04/14/goss/</id>
    <published>2019-04-14T11:40:58.000Z</published>
    <updated>2019-04-15T02:47:47.696Z</updated>
    
    <content type="html"><![CDATA[<p>写个人博客也快两年了，在博客里放图片一直是个老大难的问题，微博一类的三方图床不爱用，总觉得不极客，使用 OSS 的话多少跟技术沾些边，要是直接使用 linux 服务器搭建的话，又太麻烦，因为需要处理的事情太多了，从图床的角度来说，稳定性还是很重要的。</p><a id="more"></a><p>抽个空就会想想这个事情，好歹想出来使用 Github 来做图床，但是这就算是跟技术沾边了？我慢慢来说。</p><div class="toc"><!-- toc --><ul><li><a href="#ru-he-shi-yong-github-tu-chuang">如何使用 Github 图床</a></li><li><a href="#shi-yong-goss-gou-jian-tu-chuang">使用 goss 构建图床</a><ul><li><a href="#shi-yong">使用</a></li></ul></li></ul><!-- tocstop --></div><h2><span id="ru-he-shi-yong-github-tu-chuang">如何使用 Github 图床</span><a href="#ru-he-shi-yong-github-tu-chuang" class="header-anchor"></a></h2><p>使用 Github 构建图床是很投机的一件事，和使用微博的方式类似，不过更加自由。</p><p><strong>首先创建一个新的仓库当做图床</strong></p><p>仓库地址为 <a href="https://github.com/wxnacy/image" target="_blank" rel="noopener">https://github.com/wxnacy/image</a></p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/goss1_762.png" alt="goss1"></p><p><strong>然后上传一个图片</strong></p><p>图片的网页地址为 <a href="https://github.com/wxnacy/image/blob/master/blog/mavel5.png" target="_blank" rel="noopener">https://github.com/wxnacy/image/blob/master/blog/mavel5.png</a></p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/goss2_1005.png" alt="goss2"></p><p><strong>找到图片网址</strong></p><p>然后点击右侧的 <code>Download</code>，网页就会跳转到图片的下载地址，也就是图片链接。</p><p>下载地址为 <a href="https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel5.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel5.png</a></p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/goss3_987.png" alt="goss3"></p><p>通过这个规律，我就可以在上传完图片后，根据图片地址规则拼接出我们想要的图片链接。</p><p>然后这个方式并不酷。</p><h2><span id="shi-yong-goss-gou-jian-tu-chuang">使用 goss 构建图床</span><a href="#shi-yong-goss-gou-jian-tu-chuang" class="header-anchor"></a></h2><p>身为一个程序员，用这样的方式进行上传、拼接地址，这个过程一点都不酷。我希望的是更极致，更方便的方式，所以 <a href="https://github.com/wxnacy/goss" target="_blank" rel="noopener">goss</a> 诞生了。</p><p>goss 全称 Github Object Storage System，也就是 Github 版本的 OSS。</p><p>它使用仓库代替 bucket，使用文件 path 代替 key，这样每个仓库都是一个独立的图床。</p><p>goss 自带一套很方便的命令行工具来操作仓库和文件，下面简单的使用几个命令，走一下增删改查的流程。</p><h3><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor"></a></h3><p><strong>安装</strong></p><p>目前仅支持 pip 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install goss              <span class="comment"># 安装</span></span><br><span class="line">$ pip install --upgrade goss    <span class="comment"># 更新</span></span><br></pre></td></tr></table></figure><p><strong>登陆</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli login</span><br></pre></td></tr></table></figure><p>根据命令行提示输入 Github 用户名密码即可，执行一次后会记录在本地，如果想要更换用户再次执行即可。</p><p><strong><em>goss 会在登陆成功后自动获取用户提交信息的 name 和 email，无需像 Git 一样再去手动配置</em></strong></p><p><strong>创建仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli repo test_goss -m post</span><br><span class="line"></span><br><span class="line">[INFO] Create repository</span><br><span class="line">[INFO] Url : https://github.com/wxnacy/test_goss</span><br><span class="line">[INFO] Waiting...</span><br><span class="line">[INFO] Create README.md</span><br><span class="line">[INFO] Url : https://github.com/wxnacy/test_goss/blob/master/README.md</span><br><span class="line">[INFO] Waiting...</span><br><span class="line">Success!</span><br></pre></td></tr></table></figure><p>等待命令行执行成功后，仓库创建成功，如图</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/goss4_1000.png" alt="goss4"></p><p><strong>上传图片</strong></p><p>上传操纵，单独有个命令为 <code>goss</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ goss -r test_goss -p <span class="built_in">test</span>/ goss1.png</span><br><span class="line"></span><br><span class="line">[INFO] Upload file</span><br><span class="line">[INFO] Source   : goss1.png</span><br><span class="line">[INFO] Path     : <span class="built_in">test</span>/goss1.png</span><br><span class="line">[INFO] HtmlUrl  : https://github.com/wxnacy/test_goss/blob/master/<span class="built_in">test</span>/goss1.png</span><br><span class="line">[INFO] DownUrl  : https://raw.githubusercontent.com/wxnacy/test_goss/master/<span class="built_in">test</span>/goss1.png</span><br><span class="line">[INFO] Now you can use it with &lt;Ctrl-v&gt; and <span class="built_in">wait</span> <span class="keyword">for</span> the upload to succeed.</span><br><span class="line">[INFO] Waiting...</span><br><span class="line">Success!</span><br></pre></td></tr></table></figure><p>在日志中会打印出图片的下载地址，然后我们并不需要手动复制，在等待上传的 <code>Waiting...</code> 阶段，我们可以直接使用 <code>&lt;ctrl-v&gt;</code> 来在文本中直接黏贴图片链接，并且继续编写文章，等图片上传完成后，该链接自动生效。</p><p>这也是 goss 最最方便的地方，只需要执行一条命令，剩下的不需要再去管。</p><p>参数部分</p><ul><li><code>-r</code> 仓库名称，如果不想每次手动输入，可以使用 <code>goss-cli config repo.name &lt;name&gt;</code> 来进行配置</li><li><code>-p</code> 文件重命名，如果以 <code>/</code> 结尾，代表以原文件名上传到该目录中</li></ul><p><strong>查看文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli file <span class="built_in">test</span>/goss1.png -r test_goss</span><br><span class="line"></span><br><span class="line">[INFO] Query file</span><br><span class="line">[INFO] Owner    : wxnacy</span><br><span class="line">[INFO] Repo     : test_goss</span><br><span class="line">[INFO] Path     : <span class="built_in">test</span>/goss1.png</span><br><span class="line">[INFO] Waiting...</span><br><span class="line">Path    : <span class="built_in">test</span>/goss1.png</span><br><span class="line">Type    : file</span><br><span class="line">Size    : 183122</span><br><span class="line">Sha     : dad2a5a0cdfd8fe0b979d3345f72bdcb98b0ecb6</span><br><span class="line">HtmlUrl : https://github.com/wxnacy/test_goss/blob/master/<span class="built_in">test</span>/goss1.png</span><br><span class="line">DownUrl : https://raw.githubusercontent.com/wxnacy/test_goss/master/<span class="built_in">test</span>/goss1.png</span><br><span class="line">[INFO] Now you can use it with &lt;Ctrl-v&gt; and <span class="built_in">wait</span> <span class="keyword">for</span> the upload to succeed.</span><br><span class="line">More details see : https://api.github.com/repos/wxnacy/test_goss/contents/<span class="built_in">test</span>/goss1.png?ref=master</span><br><span class="line">Success!</span><br></pre></td></tr></table></figure><p><strong>删除文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli file <span class="built_in">test</span>/goss1.png -r test_goss -m delete</span><br></pre></td></tr></table></figure><p>先你应该发现了，命令中的正删改查的方式来源于 RESTFul 风格。</p><p><code>--method/-m</code> 参数</p><ul><li><code>post</code> 新建</li><li><code>get</code> 查看，默认</li><li><code>delete</code> 删除</li></ul><p><strong>删除仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli repo test_goss -m delete</span><br></pre></td></tr></table></figure><p>现在这个命令应该慎用，因为这是彻彻底底的删除，除非你真的想删除一些老项目，否则最好不要用这个命令。</p><p>今天只是简单介绍下使用 goss 来构建图床，goss 本身会有很多功能，我也会不断的进行更新，你可以使用帮助命令来获取更多的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage: goss-cli [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">  Github Object Storage System</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -v, --version  Show the version</span><br><span class="line">  -d, --debug    Run <span class="keyword">in</span> debug</span><br><span class="line">  --<span class="built_in">help</span>         Show this message and <span class="built_in">exit</span>.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  config  Get/Create/Update goss config</span><br><span class="line">  file    Get/Delete/Download your file If you want to upload file.</span><br><span class="line">  login   Log <span class="keyword">in</span> to the github account</span><br><span class="line">  repo    Get/Create your repositorys</span><br></pre></td></tr></table></figure><p>子命令也可以查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ goss-cli file --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage: goss-cli file [OPTIONS] [PATH]</span><br><span class="line"></span><br><span class="line">  Get/Delete/Download your file</span><br><span class="line"></span><br><span class="line">  If you want to upload file. Please use <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line">      goss &lt;filepath&gt; --repo=&lt;repository-name&gt;</span><br><span class="line"></span><br><span class="line">  More usage see : goss --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -m, --method TEXT  GET/POST/PUT/DELETE <span class="keyword">for</span> repository. Default is GET</span><br><span class="line">  -o, --orga TEXT    If want create organization repository. Is required</span><br><span class="line">  -D, --download     Download file</span><br><span class="line">  -y, --yes          All questions answered yes</span><br><span class="line">  -O, --output TEXT  Download name. Default is file name</span><br><span class="line">  -r, --repo TEXT    Repository name  [required]</span><br><span class="line">  --<span class="built_in">help</span>             Show this message and <span class="built_in">exit</span>.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写个人博客也快两年了，在博客里放图片一直是个老大难的问题，微博一类的三方图床不爱用，总觉得不极客，使用 OSS 的话多少跟技术沾些边，要是直接使用 linux 服务器搭建的话，又太麻烦，因为需要处理的事情太多了，从图床的角度来说，稳定性还是很重要的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://wxnacy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux tar 打包命令</title>
    <link href="http://wxnacy.com/2019/04/13/linux-tar/"/>
    <id>http://wxnacy.com/2019/04/13/linux-tar/</id>
    <published>2019-04-13T01:52:28.000Z</published>
    <updated>2019-04-14T02:50:03.915Z</updated>
    
    <content type="html"><![CDATA[<p>在 Github 打标签的时候，它会自动归档两种压缩格式的文件 <code>.zip</code> 和 <code>.tar.gz</code>，如图</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/tar_944.png" alt="tar"></p><p><code>zip</code> 格式的压缩和解压可以参看我这篇文章 <a href="/2018/09/19/zip-unzip/">Linux zip 和 unzip 命令</a></p><p>今天我主要来说一下 <code>tar</code> 打包命令。</p><div class="toc"><!-- toc --><ul><li><a href="#da-bao-jie-bao">打包解包</a></li><li><a href="#ya-suo-jie-ya-gz-ge-shi">压缩解压 .gz 格式</a></li><li><a href="#ya-suo-jie-ya-bz2-ge-shi">压缩解压 .bz2 格式</a></li><li><a href="#geng-duo-yu-fa">更多语法</a></li></ul><!-- tocstop --></div><p>首先要强调的是 <code>tar</code> 是打包命令，本身不压缩，需要调用 <code>gzip</code> 压缩命令才可以生成 <code>.gz</code> 后缀的压缩文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tar cvf pm2.log.tar pm2.log       <span class="comment"># 打包</span></span><br><span class="line">$ tar zcvf pm2.log.tar.gz pm2.log   <span class="comment"># 打包，并压缩</span></span><br><span class="line">$ zip pm2.zip pm2.log               <span class="comment"># 使用 zip 压缩</span></span><br><span class="line">$ ll</span><br><span class="line">-rw-r--r--    1 wxnacy  staff  259615701 Apr 13 06:37 pm2.log</span><br><span class="line">-rw-r--r--    1 wxnacy  staff  259617280 Apr 13 09:47 pm2.log.tar</span><br><span class="line">-rw-r--r--    1 wxnacy  staff    7746015 Apr 13 09:48 pm2.log.tar.gz</span><br><span class="line">-rw-r--r--    1 wxnacy  staff    7763656 Apr 13 09:51 pm2.zip</span><br></pre></td></tr></table></figure><p>从结果来看，只是打包命令的话，不但不压缩，本身比原文件还要大一点，调用压缩命令后，压缩比很明显，并且比 <code>zip</code> 的压缩比要高，所以在文件压缩时，我们可以优先使用 <code>tar</code> 打包并压缩。</p><h2><span id="da-bao-jie-bao">打包解包</span><a href="#da-bao-jie-bao" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar cvf &lt;filename&gt;.tar &lt;filename|dirname&gt;     <span class="comment"># 打包</span></span><br><span class="line">$ tar xvf &lt;filename&gt;.tar                        <span class="comment"># 解包</span></span><br></pre></td></tr></table></figure><h2><span id="ya-suo-jie-ya-gz-ge-shi">压缩解压 .gz 格式</span><a href="#ya-suo-jie-ya-gz-ge-shi" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar zcvf &lt;filename&gt;.tar.gz &lt;filename|dirname&gt;     <span class="comment"># 压缩</span></span><br><span class="line">$ tar zxvf &lt;filename&gt;.tar.gz                        <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><h2><span id="ya-suo-jie-ya-bz2-ge-shi">压缩解压 .bz2 格式</span><a href="#ya-suo-jie-ya-bz2-ge-shi" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar jcvf &lt;filename&gt;.tar.bz2 &lt;filename|dirname&gt;     <span class="comment"># 压缩</span></span><br><span class="line">$ tar jxvf &lt;filename&gt;.tar.bz2                        <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><h2><span id="geng-duo-yu-fa">更多语法</span><a href="#geng-duo-yu-fa" class="header-anchor"></a></h2><p>必要参数有如下：</p><ul><li><code>-A</code> 新增压缩文件到已存在的压缩</li><li><code>-B</code> 设置区块大小</li><li><code>-c</code> 建立新的压缩文件</li><li><code>-d</code> 记录文件的差别</li><li><code>-r</code> 添加文件到已经压缩的文件</li><li><code>-u</code> 添加改变了和现有的文件到已经存在的压缩文件</li><li><code>-x</code> 从压缩的文件中提取文件</li><li><code>-t</code> 显示压缩文件的内容</li><li><code>-z</code> 支持gzip解压文件</li><li><code>-j</code> 支持bzip2解压文件</li><li><code>-Z</code> 支持compress解压文件</li><li><code>-v</code> 显示操作过程</li><li><code>-l</code> 文件系统边界设置</li><li><code>-k</code> 保留原有文件不覆盖</li><li><code>-m</code> 保留文件不被覆盖</li><li><code>-W</code> 确认压缩文件的正确性</li></ul><p>可选参数如下：</p><ul><li><code>-b</code> 设置区块数目</li><li><code>-C</code> 切换到指定目录</li><li><code>-f</code> 指定压缩文件</li><li><code>--help</code> 显示帮助信息</li><li><code>--version</code> 显示版本信息</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Github 打标签的时候，它会自动归档两种压缩格式的文件 &lt;code&gt;.zip&lt;/code&gt; 和 &lt;code&gt;.tar.gz&lt;/code&gt;，如图&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 如何打印不换行进度条</title>
    <link href="http://wxnacy.com/2019/04/12/python-single-line-progress/"/>
    <id>http://wxnacy.com/2019/04/12/python-single-line-progress/</id>
    <published>2019-04-12T14:36:10.000Z</published>
    <updated>2019-04-12T14:48:11.317Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中打印不换行进度条，可以说是简单透顶，使用内置方法 <code>print</code> 直接打印即可</p><a id="more"></a><p>先看下效果</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/python_progress.gif" alt="image"></p><p>大部分时间我们使用 <code>print</code> 是不带多与参数的，但是它有个带有默认值的参数 <code>end</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">''</span>, end=<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p>默认情况下 <code>end=&#39;\n&#39;</code>，表示打印完毕后进行换行。</p><p><code>\r</code> 则表示将光标移动到行首</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">''</span>, end=<span class="string">'\r'</span>)     <span class="comment"># 简而言之，这样就可以起到不换行的效果</span></span><br></pre></td></tr></table></figure><p>完整代码请见 <a href="https://github.com/wxnacy/study/blob/master/python/simple/single_line_progress.py" target="_blank" rel="noopener">single_line_progress.py</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中打印不换行进度条，可以说是简单透顶，使用内置方法 &lt;code&gt;print&lt;/code&gt; 直接打印即可&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 操作 ini 配置文件</title>
    <link href="http://wxnacy.com/2019/04/11/python-configparser/"/>
    <id>http://wxnacy.com/2019/04/11/python-configparser/</id>
    <published>2019-04-11T03:25:49.000Z</published>
    <updated>2019-04-11T03:25:49.336Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中使用 <code>configparser</code> 模块来操作 ini 文件。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>假如想要生成 <code>example.ini</code> 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ServerAliveInterval = 45</span><br><span class="line">Compression = yes</span><br><span class="line">CompressionLevel = 9</span><br><span class="line">ForwardX11 = yes</span><br><span class="line"></span><br><span class="line">[bitbucket.org]</span><br><span class="line">User = hg</span><br><span class="line"></span><br><span class="line">[topsecret.server.com]</span><br><span class="line">Port = 50022</span><br><span class="line">ForwardX11 = no</span><br></pre></td></tr></table></figure><p><strong>写入操作</strong></p><p><code>configparser.ConfigParser()</code> 方法生成实例，配置和读取内容都可以按照 <code>dict</code> 的方式进行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> configparser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config = configparser.ConfigParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'DEFAULT'</span>] = &#123;<span class="string">'ServerAliveInterval'</span>: <span class="string">'45'</span>,</span><br><span class="line"><span class="meta">... </span>                     <span class="string">'Compression'</span>: <span class="string">'yes'</span>,</span><br><span class="line"><span class="meta">... </span>                     <span class="string">'CompressionLevel'</span>: <span class="string">'9'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>] = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>][<span class="string">'User'</span>] = <span class="string">'hg'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'topsecret.server.com'</span>] = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret = config[<span class="string">'topsecret.server.com'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'Port'</span>] = <span class="string">'50022'</span>     <span class="comment"># mutates the parser</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'ForwardX11'</span>] = <span class="string">'no'</span>  <span class="comment"># same here</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'DEFAULT'</span>][<span class="string">'ForwardX11'</span>] = <span class="string">'yes'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'example.ini'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> configfile:</span><br><span class="line"><span class="meta">... </span>  config.write(configfile)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>读取操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>config = configparser.ConfigParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.sections()</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.read(<span class="string">'example.ini'</span>)</span><br><span class="line">[<span class="string">'example.ini'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.sections()</span><br><span class="line">[<span class="string">'bitbucket.org'</span>, <span class="string">'topsecret.server.com'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'bitbucket.org'</span> <span class="keyword">in</span> config</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'bytebong.com'</span> <span class="keyword">in</span> config</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>][<span class="string">'User'</span>]</span><br><span class="line"><span class="string">'hg'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'DEFAULT'</span>][<span class="string">'Compression'</span>]</span><br><span class="line"><span class="string">'yes'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret = config[<span class="string">'topsecret.server.com'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'ForwardX11'</span>]</span><br><span class="line"><span class="string">'no'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>topsecret[<span class="string">'Port'</span>]</span><br><span class="line"><span class="string">'50022'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> config[<span class="string">'bitbucket.org'</span>]:</span><br><span class="line"><span class="meta">... </span>    print(key)</span><br><span class="line">user</span><br><span class="line">compressionlevel</span><br><span class="line">serveraliveinterval</span><br><span class="line">compression</span><br><span class="line">forwardx11</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>][<span class="string">'ForwardX11'</span>]</span><br><span class="line"><span class="string">'yes'</span></span><br></pre></td></tr></table></figure><p><strong>修改操作</strong></p><p>因为此处配置的写入是覆盖模式，所以如果想要修改文件，需要判断下文件是否存在，存在的话，先加载文件内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">config</span><span class="params">(filepath, section, **data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    filepath: 配置文件地址</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    conf = configparser.ConfigParser()</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(filepath):</span><br><span class="line">        conf.read(filepath)</span><br><span class="line"></span><br><span class="line">    conf[section] = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        conf.write(f)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.python.org/3/library/configparser.html" target="_blank" rel="noopener">configparser</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中使用 &lt;code&gt;configparser&lt;/code&gt; 模块来操作 ini 文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 如何创建文件</title>
    <link href="http://wxnacy.com/2019/04/09/python-create-file/"/>
    <id>http://wxnacy.com/2019/04/09/python-create-file/</id>
    <published>2019-04-09T10:02:33.000Z</published>
    <updated>2019-04-10T10:03:15.091Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中可以使用 <code>open()</code> 内置方法来创建和打开文件。</p><a id="more"></a><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(file, [mode])</span><br></pre></td></tr></table></figure><p>Mode:</p><ul><li><code>x</code> 创建文件，如果文件已经存在会报错。</li><li><code>w</code> 创建可写文件，写入内容覆盖文件。</li><li><code>r</code> 获取可读文件，默认模式。</li><li><code>a</code> 打开一个可追加文件，广告默认在文尾。</li><li><code>t</code> 打开一个 text 模式，默认模式</li><li><code>b</code> 打开一个二进制模式</li></ul><p><strong>创建文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test'</span>, <span class="string">'x'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test'</span>, <span class="string">'x'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    f = open(<span class="string">'/tmp/test'</span>, <span class="string">'x'</span>)</span><br><span class="line">FileExistsError: [Errno <span class="number">17</span>] File exists: <span class="string">'/tmp/test'</span></span><br></pre></td></tr></table></figure><p><strong>创建可写文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hw'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p><strong>创建可追加文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hw'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">'hwhw'</span></span><br></pre></td></tr></table></figure><p><strong>获取可读文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">'hwhw'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/tmp/test1'</span>, <span class="string">'rb'</span>)    <span class="comment"># 以二进制打开</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b'hwhw'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.guru99.com/reading-and-writing-files-in-python.htm" target="_blank" rel="noopener">Python File Handling: Create, Open, Append, Read, Write</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中可以使用 &lt;code&gt;open()&lt;/code&gt; 内置方法来创建和打开文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Mac 系统中使用 ffmpeg 给视频添加文字水印</title>
    <link href="http://wxnacy.com/2019/04/08/ffmpeg-drawtext/"/>
    <id>http://wxnacy.com/2019/04/08/ffmpeg-drawtext/</id>
    <published>2019-04-08T06:16:42.000Z</published>
    <updated>2019-04-08T06:16:42.408Z</updated>
    
    <content type="html"><![CDATA[<p>最近有给视频加文字水印的需求，第一个想到的肯定是使用 ffmpeg，搜索了下发现网上的博客多是从别人那复制过来的，直接使用多是报错，经过摸索后，终于搞清楚了简单用法，今天简单总结下。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#ying-wen-shui-yin">英文水印</a></li><li><a href="#zhong-wen-shui-yin">中文水印</a></li></ul><!-- tocstop --></div><p>先来看个例子，我希望在如下的视频右侧加上文字水印，如下</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel33.png" alt="mavel3"></p><h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor"></a></h2><p>首先需要安装最新版本的 ffmpeg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install ffmpeg</span><br></pre></td></tr></table></figure><h2><span id="ying-wen-shui-yin">英文水印</span><a href="#ying-wen-shui-yin" class="header-anchor"></a></h2><p>运行下面的命令，即可达到上图效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -y -i mavel4.mp4 -vf <span class="string">"drawtext=text='Avengers\: Endgame':x=700:y=200:fontsize=24:fontcolor=red"</span> mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>参数含义</p><ul><li><code>-i</code>：需要渲染的视频，<code>mavel4.mp4</code> 为视频源</li><li><code>-vf</code>：后面跟着需要的具体渲染效果，后面的参数需要使用双引号包裹起来</li><li><code>mavel4_drawtext.mp4</code>：就是最后输出的文件名</li><li><code>-y</code>：对一切提示回答 <code>yes</code></li></ul><p><code>-vf</code> 后面的参数比较复杂，我们先将命令行折行美化下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -y -i mavel4.mp4 \</span><br><span class="line">    -vf <span class="string">"drawtext=\</span></span><br><span class="line"><span class="string">        text='Avengers\: Endgame':\</span></span><br><span class="line"><span class="string">        x=700:\</span></span><br><span class="line"><span class="string">        y=200:\</span></span><br><span class="line"><span class="string">        fontsize=24:\</span></span><br><span class="line"><span class="string">        fontcolor=red:\</span></span><br><span class="line"><span class="string">        "</span> \</span><br><span class="line">    mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>现在我们来逐条分析下</p><ul><li><code>drawtext=</code>：代表了此次渲染为添加文字水印，后面跟着具体的属性，属性之间使用 <code>:</code> 分割</li><li><code>text=&#39;Avengers\: Endgame&#39;:</code>：想要渲染的文字内容，如果想要输入 <code>:</code>，需要使用 <code>\</code> 进行转义</li><li><code>x=700:y=200</code>：分别为水印距视频左侧 700 偏移量，距顶部 200 偏移量，默认为 0</li><li><code>fontsize=24:</code>：字体大小，默认为 16</li><li><code>fontcolor=red:</code>：字体颜色红色，默认为黑色</li></ul><h2><span id="zhong-wen-shui-yin">中文水印</span><a href="#zhong-wen-shui-yin" class="header-anchor"></a></h2><p>这是英文的水印，不过我的需求为中文水印，我第一个反应就是乱码问题，先试一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -y -i mavel4.mp4 \</span><br><span class="line">    -vf <span class="string">"drawtext=\</span></span><br><span class="line"><span class="string">        text='复仇者联盟：终局之战':\</span></span><br><span class="line"><span class="string">        x=700:\</span></span><br><span class="line"><span class="string">        y=200:\</span></span><br><span class="line"><span class="string">        fontsize=24:\</span></span><br><span class="line"><span class="string">        fontcolor=red:\</span></span><br><span class="line"><span class="string">        "</span> \</span><br><span class="line">    mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>果然，都是方块</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel4.png" alt="mavel4"></p><p>这是因为默认的字体文件并不支持中文，此时我们需要使用 <code>fontfile</code> 属性来制定字体文件。</p><p>网上很多博客都直接使用 <code>fontfile=PingFang.ttc:</code> 来指定文件，这多少有点误人子弟，此处应该使用字体文件的<strong><em>绝对地址</em></strong>。</p><p>如何获取 Mac 电脑中字体文件的绝对地址呢，请看我的的这篇文章 <a href="/2019/04/03/mac-fonts-path/">Mac 电脑查看字体文件位置</a></p><p>我选择了苹方字体，绝对地址为 <code>/System/Library/Fonts/PingFang.ttc</code>，完整命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -y -i mavel4.mp4 \</span><br><span class="line">    -vf <span class="string">"drawtext=\</span></span><br><span class="line"><span class="string">        fontfile=/System/Library/Fonts/PingFang.ttc:\</span></span><br><span class="line"><span class="string">        text='复仇者联盟：终局之战':\</span></span><br><span class="line"><span class="string">        x=700:\</span></span><br><span class="line"><span class="string">        y=200:\</span></span><br><span class="line"><span class="string">        fontsize=24:\</span></span><br><span class="line"><span class="string">        fontcolor=red:\</span></span><br><span class="line"><span class="string">        "</span> \</span><br><span class="line">    mavel4_drawtext.mp4</span><br></pre></td></tr></table></figure><p>最终渲染效果</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/mavel5.png" alt="mavel5"></p><p>文字水印还有很多参数，大家可以根据自己的需求进行选择，文档地址：<a href="https://ffmpeg.org/ffmpeg-filters.html#drawtext-1" target="_blank" rel="noopener">https://ffmpeg.org/ffmpeg-filters.html#drawtext-1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有给视频加文字水印的需求，第一个想到的肯定是使用 ffmpeg，搜索了下发现网上的博客多是从别人那复制过来的，直接使用多是报错，经过摸索后，终于搞清楚了简单用法，今天简单总结下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ffmpeg" scheme="http://wxnacy.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Python 复制文件的两种方式</title>
    <link href="http://wxnacy.com/2019/04/07/python-copy-command/"/>
    <id>http://wxnacy.com/2019/04/07/python-copy-command/</id>
    <published>2019-04-07T10:48:45.000Z</published>
    <updated>2019-04-07T10:48:45.188Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中实现文件复制，大概分为两种方式<strong>复制函数</strong>和<strong>调用 shell</strong></p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#han-shu-fu-zhi">函数复制</a></li><li><a href="#diao-yong-shell">调用 shell</a></li><li><a href="#xiao-lu-dui-bi">效率对比</a></li></ul><!-- tocstop --></div><h2><span id="han-shu-fu-zhi">函数复制</span><a href="#han-shu-fu-zhi" class="header-anchor"></a></h2><p><code>shutil</code> 模块中有几个可以实现复制的方法</p><p>其实 <code>copy()</code> 方法是最常用到的，它相当于 <code>cp -P</code> 命令，可以复制文件的内容和权限。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># shutil.copy(源文件, 目标文件) 目标文件可以是目录</span></span><br><span class="line">shutil.copy(<span class="string">'test.sh'</span>, <span class="string">'test_copy.sh'</span>)</span><br><span class="line">shutil.copy(<span class="string">'test.sh'</span>, <span class="string">'/tmp'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x  1 wxnacy  wheel     90 Apr  6 19:05 test.sh</span><br><span class="line">-rwxr-xr-x  1 wxnacy  wheel     90 Apr  6 19:09 test_copy.sh</span><br></pre></td></tr></table></figure><p><code>copy()</code> 方法中调用了 <code>copyfile()</code> <code>copymode()</code> 两个方法。</p><ul><li><code>copyfile()</code> 负责复制文件内容，但是目标文件不能是目录，并且必须可以写入</li><li><code>copymode()</code> 负责复制文件权限</li></ul><p><code>copyfile()</code> 方法中又调用了低级方法 <code>copyfileobj()</code></p><p><code>copyfileobj()</code> 方法可以假定了一个可选参数（缓冲区大小），你可以用来设置缓冲区长度。这是复制过程中保存在内存中的字节数。系统使用的默认大小是 16 KB。</p><p>还有个 <code>copy2()</code> 方法，它类似 <code>copy()</code>，但是它可以在复制数据时获取元数据中添加的访问和修改时间。</p><p>几个方法就功能而言 <code>copy2() &gt; copy() &gt; copyfile()</code>，相对应的功能和耗时是成正比的，所以我建议一般情况下可以使用 <code>copy()</code> 方法，如果大批量复制操作，并且没有特殊权限，比如图片，那么还是使用 <code>copyfile()</code> 更好一点。</p><h2><span id="diao-yong-shell">调用 shell</span><a href="#diao-yong-shell" class="header-anchor"></a></h2><p>还有一个万能的方式是直接调用 shell 命令。</p><p>现在使用 <code>subprocess</code> 模块代替其他调用 shell 的模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"></span><br><span class="line">cmds = shlex.split(<span class="string">"cp test.sh test_popen.sh"</span>)</span><br><span class="line">p = subprocess.Popen(cmds)</span><br><span class="line">p.communicate()</span><br></pre></td></tr></table></figure><p><code>Popen()</code> 方法的第一个参数为执行的命令，在 Unix 系统中，如果该参数为字符串，那它只能是一个可执行文件，如果想要传参，则必须以数组的形式传入，<code>shlex.split()</code> 方法可以将复杂的命令转换为数组的形式。</p><p>在 Windows 系统中可以使用字符串传入命令行，并且需要使用 <code>copy source_file target_file</code> 命令。</p><h2><span id="xiao-lu-dui-bi">效率对比</span><a href="#xiao-lu-dui-bi" class="header-anchor"></a></h2><p>最后对比下他们的速度，执行 100 次时间如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">copy_file time    0.022215532000000003</span><br><span class="line">copy time         0.059561121999999994</span><br><span class="line">copy2 time        0.07728823600000001</span><br><span class="line">popen time        0.37018151000000005</span><br></pre></td></tr></table></figure><p>大概是 <code>subprocess</code> 模块会生成子进程的原因，速度慢了很多，在这种情况下，复制操作优选依然是 <code>copy()</code> <code>copyfile()</code> 方法。</p><ul><li><a href="https://www.techbeamers.com/python-copy-file/" target="_blank" rel="noopener">How to Copy a File in Python – 9 Different Ways to do It!</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中实现文件复制，大概分为两种方式&lt;strong&gt;复制函数&lt;/strong&gt;和&lt;strong&gt;调用 shell&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 操作剪切板</title>
    <link href="http://wxnacy.com/2019/04/06/python-clipboard/"/>
    <id>http://wxnacy.com/2019/04/06/python-clipboard/</id>
    <published>2019-04-06T09:59:15.000Z</published>
    <updated>2019-04-06T09:59:15.248Z</updated>
    
    <content type="html"><![CDATA[<p>Python 操作剪切板，需要调用系统的 C 动态库，或者使用自带的命令行。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><ul><li><a href="#shi-yong-pbcopy-he-pbpaste">使用 pbcopy 和 pbpaste</a></li><li><a href="#shi-yong-pyperclip-mo-kuai">使用 pyperclip 模块</a></li></ul><!-- tocstop --></div><p>Windows 系统可以动态调用 <code>ctypes</code> 库，具体操作步骤可以看看这篇文章：<a href="https://www.jianshu.com/p/430f4af2cb06" target="_blank" rel="noopener">https://www.jianshu.com/p/430f4af2cb06</a></p><p>下面我们主要来说下 Mac 系统的操作方式。</p><h2><span id="shi-yong-pbcopy-he-pbpaste">使用 pbcopy 和 pbpaste</span><a href="#shi-yong-pbcopy-he-pbpaste" class="header-anchor"></a></h2><p>在 Mac 系统中可以使用 <code>pbcopy</code> 和 <code>pbpaste</code> 来实现复制粘贴操作，这两个命令都是系统自带的。</p><p><code>pbcopy</code> 接收管道输入的文字，并复制到剪切板。<code>pbpaste</code> 直接输出剪切板的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'我爱你中国'</span> | pbcopy</span><br><span class="line">$ pbpaste</span><br><span class="line">我爱你中国</span><br></pre></td></tr></table></figure><p>使用起来还是很方便的，接下来是 Python 中如何调用。</p><p>使用 <code>subprocess</code> 模块下的 <code>Popen</code> 方法，可以很方便的操作管道的输入输出信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 在 Mac 系统中使用剪切板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_clipboard</span><span class="params">(data: str)</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">'pbcopy'</span>], stdin=subprocess.PIPE)</span><br><span class="line">    p.stdin.write(data.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    p.stdin.close()</span><br><span class="line">    p.communicate()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_from_clipboard</span><span class="params">()</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">'pbpaste'</span>], stdout=subprocess.PIPE)</span><br><span class="line">    p.wait()</span><br><span class="line">    byte_data = p.stdout.read()</span><br><span class="line">    p.stdout.close()</span><br><span class="line">    <span class="keyword">return</span> byte_data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    set_clipboard(<span class="string">'我爱你中国'</span>)</span><br><span class="line">    print(get_from_clipboard())</span><br><span class="line"></span><br><span class="line"><span class="comment"># python clipboard.py</span></span><br><span class="line"><span class="comment"># 我爱你中国</span></span><br></pre></td></tr></table></figure><h2><span id="shi-yong-pyperclip-mo-kuai">使用 pyperclip 模块</span><a href="#shi-yong-pyperclip-mo-kuai" class="header-anchor"></a></h2><p>如果你的系统需要适应各个平台，并且需要比较高的稳定性，那还是直接使用第三方模块 <a href="https://github.com/asweigart/pyperclip" target="_blank" rel="noopener">pyperclip</a> 比较方便。</p><p>它的源码地址为：<a href="https://github.com/asweigart/pyperclip/blob/master/src/pyperclip/__init__.py" target="_blank" rel="noopener">https://github.com/asweigart/pyperclip/blob/master/src/pyperclip/__init__.py</a></p><p>其实他就是整合了上述的方法，只是应该了这么多人的使用，已经非常稳定，使用方法也更简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pyperclip</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pyperclip.copy(<span class="string">'The text to be copied to the clipboard.'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pyperclip.paste()</span><br><span class="line"><span class="string">'The text to be copied to the clipboard.'</span></span><br></pre></td></tr></table></figure><p><code>Windows</code> 和 <code>Mac</code> 平台可以直接使用。</p><p><code>Linux</code> 需要 <code>xclip</code> <code>xsel</code> <code>gtk</code> <code>PyQt4</code> 依赖包，可以根据平台通过 <code>apt</code> 或 <code>yum</code> 进行安装。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 操作剪切板，需要调用系统的 C 动态库，或者使用自带的命令行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Expect 设置变量和读取环境变量</title>
    <link href="http://wxnacy.com/2019/04/05/expect-variables/"/>
    <id>http://wxnacy.com/2019/04/05/expect-variables/</id>
    <published>2019-04-05T12:34:00.000Z</published>
    <updated>2019-04-05T12:34:00.928Z</updated>
    
    <content type="html"><![CDATA[<p>Expect 中设置变量跟 Bash 稍有不同</p><a id="more"></a><p><strong>Bash</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=wxnacy</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span>  <span class="comment"># wxnacy</span></span><br></pre></td></tr></table></figure><p><strong>Expect</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name wxnacy</span><br><span class="line">puts <span class="variable">$name</span>  <span class="comment"># wxnacy</span></span><br></pre></td></tr></table></figure><p>边境变量也是如此</p><p><strong>Bash</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span>      <span class="comment"># /Users/wxnacy</span></span><br></pre></td></tr></table></figure><p><strong>Expect</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="variable">$env</span>(HOME) <span class="comment"># /Users/wxnacy</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Expect 中设置变量跟 Bash 稍有不同&lt;/p&gt;
    
    </summary>
    
    
      <category term="expect" scheme="http://wxnacy.com/tags/expect/"/>
    
  </entry>
  
  <entry>
    <title>Zsh 加载速度优化</title>
    <link href="http://wxnacy.com/2019/04/04/zsh-speed-optimization/"/>
    <id>http://wxnacy.com/2019/04/04/zsh-speed-optimization/</id>
    <published>2019-04-04T05:59:45.000Z</published>
    <updated>2019-04-04T05:59:45.051Z</updated>
    
    <content type="html"><![CDATA[<p>用 Zsh 也有几年的时间，期间各种添加配置，导致了每次启动都巨慢无比。我也换了 <a href="https://fishshell.com/" target="_blank" rel="noopener">fish</a> 用过几天，虽然速度很快，补全功能超爽，但是它最大的问题是不兼容 bash，那还玩个毛，我的开发环境极度依赖 bash 脚本，没办法了，Zsh 还是要接着用的，但是优化速度成了一个大问题。</p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><p>通过 <code>time</code> 分析 <code>zsh</code> 加载速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ time zsh -i -c <span class="built_in">exit</span></span><br><span class="line">5.52 real         3.56 user         2.09 sys</span><br></pre></td></tr></table></figure><p>这里的 <code>real</code> 代表的是执行 <code>zsh</code> 时真实的加载速度，好家伙，这个时间真是够受的。</p><p>我们再来看下无配置加载速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ time zsh --no-rcs -i -c <span class="built_in">exit</span></span><br><span class="line">0.00 real         0.00 user         0.00 sys</span><br></pre></td></tr></table></figure><p>我们当然不可能优化到这个速度，但这是我们的目标。</p><p>网上优化的方法，通常是使用懒加载，这是很优雅的解决方式，也很有效，但还是那句话，<strong><em>好的东西也并不一定适用于所有人</em></strong>。</p><p>关于懒加载，大家可以看看这篇文章 <a href="https://best33.com/283.moe" target="_blank" rel="noopener">zshrc 启动速度分析和优化</a>，里面梳理了怎样分析 <code>zshrc</code> 中每条语句的加载速度，从而我们可以针对性的优化。</p><p>如果懒加载可以解决你的问题，那现在已经可以关闭网页，然后优化你的配置了。</p><p>下面我先来说说懒加载的缺点，比如 <code>nvm</code> 的配置就很浪费时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span>  ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span>  <span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure><p>我们进行懒加载配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">nvm</span></span>() &#123;</span><br><span class="line">    <span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">    [ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">    [ -s <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span>  ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span>  <span class="comment"># This loads nvm bash_completion</span></span><br><span class="line">    nvm <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样再次执行测速会发现优化了很多，是不是很兴奋呢？先别着急。</p><p>懒加载配置后，启动 <code>zsh</code> 时虽然提升了速度，但是想要使用 <code>node</code> 命令，需要先执行 <code>nvm</code> 实时加载上述的配置，这似乎没什么，不使用不加载，这不挺好吗？</p><p>先来说说我的环境，我的开发环境极度依赖脚本，如果使用了懒加载，那每个启动脚本前都要先套上一个无用的 <code>nvm</code> 命令，这多少有点不伦不类，并且这对于我来说好像并没有起到加速的效果。</p><p>并且有些功能懒加载并不正常，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;HOME&#125;</span>/.pyenv"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># https://github.com/pyenv/pyenv#basic-github-checkout</span></span><br><span class="line">    <span class="built_in">export</span> PYENV_ROOT=<span class="string">"<span class="variable">$HOME</span>/.pyenv"</span></span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$&#123;PYENV_ROOT&#125;</span>/bin:<span class="variable">$&#123;PATH&#125;</span>"</span></span><br><span class="line">    <span class="comment"># config for vim plugin YouComplateMe</span></span><br><span class="line">    <span class="built_in">export</span> PYENV_VIRTUALENV_DISABLE_PROMPT=1</span><br><span class="line">    <span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv init -)</span>"</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv virtualenv-init -)</span>"</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>pyenv</code> 用懒加载并不能正常使用，可能是我用的不对，但我也不想在纠结这个件事，我在想是不是可以换一条路。</p><p>我在 <a href="/2018/10/08/zsh-startup-files/">Zsh 配置文件加载顺序</a>一文中介绍了 Zsh 配置文件的生命周期。</p><p>当打开新的 Terminal 时，配置加载顺序为 <code>~/.zshenv</code> <code>~/.zprofile</code> <code>~/.zshrc</code> <code>~/.zlogin</code></p><p>执行 <code>zsh</code> 时，配置加载顺序为 <code>~/.zshenv</code> <code>~/.zshrc</code></p><p>除了 <code>~/.zshrc</code> 我们发现了一个有意思的配置 <code>~/.zprofile</code>，它只在启动 Terminal 时才会加载，那我把不常变动并且耗时长的配置写在这里面不就行了。</p><p>这样不管是执行 <code>zsh</code>，还是 <code>source ~/.zshrc</code> 速度都得到了改善，这个看似自欺欺人的变动，却恰好能满足我的要求。</p><p>我使用 tmux 来管理窗口，每次开机后恢复一次 tmux 缓存窗口即可，知道下次重启电脑，我可能都不会在新建 Terminal 了，这样对于我来说就已经大大的优化的 <code>zsh</code> 速度。</p><p>最后我过滤了现在的配置文件，去掉了些无用的配置后，速度如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; time zsh -i -c <span class="built_in">exit</span></span><br><span class="line">0.23 real         0.13 user         0.08 sys</span><br></pre></td></tr></table></figure><p>OK！终于可以愉快的使用 Zsh 了。</p><ul><li><a href="https://wxnacy.com/2018/10/08/zsh-startup-files/">Zsh 配置文件加载顺序</a></li><li><a href="http://blog.xebia.com/profiling-zsh-shell-scripts/" target="_blank" rel="noopener">Profiling zsh shell scripts</a></li><li><a href="https://frederic-hemberger.de/articles/speed-up-initial-zsh-startup-with-lazy-loading/" target="_blank" rel="noopener">Speed up initial zsh startup with lazy-loading</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 Zsh 也有几年的时间，期间各种添加配置，导致了每次启动都巨慢无比。我也换了 &lt;a href=&quot;https://fishshell.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fish&lt;/a&gt; 用过几天，虽然速度很快，补全功能超爽，但是它最大的问题是不兼容 bash，那还玩个毛，我的开发环境极度依赖 bash 脚本，没办法了，Zsh 还是要接着用的，但是优化速度成了一个大问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zsh" scheme="http://wxnacy.com/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>Mac 电脑查看字体文件位置</title>
    <link href="http://wxnacy.com/2019/04/03/mac-fonts-path/"/>
    <id>http://wxnacy.com/2019/04/03/mac-fonts-path/</id>
    <published>2019-04-03T05:51:06.000Z</published>
    <updated>2019-04-03T05:51:06.814Z</updated>
    
    <content type="html"><![CDATA[<p>首先直接给出 Mac 电脑中字体文件的位置 <code>/System/Library/Fonts</code></p><a id="more"></a><p>在 Terminal 中使用命令打开该目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ open /System/Library/Fonts</span><br></pre></td></tr></table></figure><p>打开后是这样的</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/mac-font3_770.png" alt="mac1"></p><p>文件名全部都是英文的，如果你对字体不熟悉，那要寻找中文字体几乎是不可能的。</p><p>这时候我们需要通过<code>字体册</code>来查看</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/mac-font1_509.png" alt="mac2"></p><p>从字体册的左侧选择中文，并从右侧想要选择的字体上右键点击，并点击<code>在访达中查看</code>，还是很受不了这个翻译。</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/mac-font2_884.png" alt="mac3"></p><p>随后直接可以在 <code>Finder</code> 中定位该字体。</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/mac-font3_770.png" alt="mac4"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先直接给出 Mac 电脑中字体文件的位置 &lt;code&gt;/System/Library/Fonts&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mac" scheme="http://wxnacy.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>bpython 强大的自动补全 Python Shell 工具</title>
    <link href="http://wxnacy.com/2019/04/02/bpython/"/>
    <id>http://wxnacy.com/2019/04/02/bpython/</id>
    <published>2019-04-02T01:48:16.000Z</published>
    <updated>2019-04-02T01:48:16.437Z</updated>
    
    <content type="html"><![CDATA[<p>提到 Python Shell 工具，要说 ipython 排老二，那没有哪位能排第一，它的功能强大是毋庸置疑的，然后强大归强大，这并不代表能适合所有人。</p><a id="more"></a><p>比如说我，我编写程序，最讲究的效率，自动补全和快速输入是必要的。但是 ipython 却远远满足不了我，如果你也用 <code>Vim + YouCompleteMe</code> 应该可以理解我。也许你会说，这本来就是 shell 命令工具，还能像 IDE 咋滴，嘿，巧了，今天要说的 <a href="https://bpython-interpreter.org/" target="_blank" rel="noopener">bpython</a> 就是个 shell 工具，但是它也能像 IDE 一样编写代码。</p><p><img src="https://camo.githubusercontent.com/fffc539a28d2465c11b74ff3c06d0b5595037454/687474703a2f2f692e696d6775722e636f6d2f6a66386d4374502e676966" alt="bpython"></p><p>相信你看完这个官方的 demo，已经开始想去了解它了，跟着我一起来吧。</p><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install bpython</span><br></pre></td></tr></table></figure><p><strong>运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ bpython</span><br><span class="line">bpython version 0.17.1 on top of Python 3.7.2 /Users/wxnacy/.pyenv/versions/3.7.2/Python.framework/Versions/3.7/bin/python3.7</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Welcome to bpython! Press &lt;F1&gt; <span class="keyword">for</span> <span class="built_in">help</span>.</span><br></pre></td></tr></table></figure><p>使用 <code>&lt;F1&gt;</code> 可以查看帮助文档</p><p>我挑一些常用的键位说一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Tab&gt;           <span class="comment"># 出现提示后，进行选择</span></span><br><span class="line">&lt;C<span class="_">-a</span>&gt;           <span class="comment"># 快速跳转行首</span></span><br><span class="line">&lt;C<span class="_">-e</span>&gt;           <span class="comment"># 快速跳转行尾，如果有上次输入记录，则自动输入</span></span><br><span class="line">&lt;C-u&gt;           <span class="comment"># 清空当前行</span></span><br><span class="line">&lt;C-w&gt;           <span class="comment"># 删除前一个单词</span></span><br><span class="line">&lt;C-h&gt;           <span class="comment"># 删除删除前一个字符，免去了手指移动到 backspace 的时间，刚好我在 Vim 中也设置了这个按键</span></span><br><span class="line"></span><br><span class="line">&lt;F1&gt;            <span class="comment"># 帮助文档</span></span><br><span class="line">&lt;F3&gt;            <span class="comment"># 打开配置文件，第一次提示是否生成配置文件</span></span><br><span class="line">&lt;F6&gt;            <span class="comment"># 重新加载 module，这在测试程序时非常有必要</span></span><br><span class="line">&lt;F7&gt;            <span class="comment"># 将当前 shell 中的代码放在临时文件中，并使用 vim 进行编辑</span></span><br><span class="line">&lt;F8&gt;            <span class="comment"># 将当前代码上传到 pastebin 上，并生成一个有效期为 7 天的链接</span></span><br></pre></td></tr></table></figure><p>挑几个重点的说下</p><p><strong>查看文档</strong></p><p>ipython 中可以使用 <code>requests.get?</code> 来查看文档</p><p>而 bpython 会自动出现该方法的文档</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/bpy1.png" alt="wpy1"></p><p><strong>重载 module</strong></p><p>bpython 目前没有启动自动重载的能力，只能通过按键手动重载，不过我们可以修改它的按键，毕竟每次按 <code>&lt;F6&gt;</code> 还是很不方便的。</p><ul><li>进入 <code>bpython</code> 命令，按 <code>&lt;F3&gt;</code> 生成并编辑 <code>config</code> 文件<ul><li>默认配置文件的位置为 <code>~/.config/bpython/config</code>，如果你想修改它的位置，那么启动的时候需要增加参数 <code>bpython --config &lt;config-path&gt;</code></li></ul></li><li><code>&lt;C-r&gt;</code> 是我认为比较舒服的按键，但是它已经被撤销按键占住了，我认为撤销不是常用按键，所以进行了修改，最终配置如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reimport = C-r  <span class="comment"># 重载按键</span></span><br><span class="line">undo = C-q      <span class="comment"># 撤销按键</span></span><br></pre></td></tr></table></figure><ul><li>然后退出 <code>bpython</code>，重新进入即可生效</li></ul><p><strong>上传 pastebin</strong></p><p>这是个比较有意思的功能，假如你想与别人及时分享一段代码，这是很优雅的方式，按下 <code>&lt;F8&gt;</code> 即可将当前命令行中的代码上传并得到一个地址，点击效果如下。</p><p><img src="https://wxnacy-img.oss-cn-beijing.aliyuncs.com/blog/bpy2_514.png" alt="bpy2"></p><p>当然 bpython 也不是没有缺点，比如在使用一些第三方模块时，自动补全有时会卡顿，这还是挺影响心情的，不过瑕不掩瑜，它仍然是让我爱不释手的 shell 工具。</p><ul><li><a href="https://github.com/bpython/bpython" target="_blank" rel="noopener">源代码</a></li><li><a href="https://docs.bpython-interpreter.org/configuration.html" target="_blank" rel="noopener">Configuration</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到 Python Shell 工具，要说 ipython 排老二，那没有哪位能排第一，它的功能强大是毋庸置疑的，然后强大归强大，这并不代表能适合所有人。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 中循环语句速度对比</title>
    <link href="http://wxnacy.com/2019/04/01/python-loop-speed-comparison/"/>
    <id>http://wxnacy.com/2019/04/01/python-loop-speed-comparison/</id>
    <published>2019-04-01T05:31:39.000Z</published>
    <updated>2019-04-01T09:08:09.817Z</updated>
    
    <content type="html"><![CDATA[<p>今天来比较下 Python 中循环语句的性能，参赛选手为 <code>while</code> <code>for</code> <code>生成器</code> <code>内置函数</code> <code>列表解析</code></p><a id="more"></a><div class="toc"><br><br><!-- toc --><!-- tocstop --></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: for while generator list_comprehension map 对比速度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_for</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        res.append(abs(i))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_while</span><span class="params">(n)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        res.append(abs(i))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_generator</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''使用生成器'''</span></span><br><span class="line">    res = (abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    res =  list(res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_list_compre</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''使用列表解析'''</span></span><br><span class="line">    res = [abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_map</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''使用内置函数 map'''</span></span><br><span class="line">    <span class="keyword">return</span> list(map(abs, range(n)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMain</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''before each test function'''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''after each test function'''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_func</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">10</span></span><br><span class="line">        <span class="comment"># 我们要求他们生成的结果是一样的</span></span><br><span class="line">        flag = (loop_for(n) == loop_while(n) == loop_generator(n) ==</span><br><span class="line">                loop_list_compre(n) == loop_map(n))</span><br><span class="line">        self.assertTrue(flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_run_time</span><span class="params">(count, func, **kw)</span>:</span></span><br><span class="line">    b = timeit.default_timer()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        func(**kw)</span><br><span class="line">    print(<span class="string">'&#123;&#125; run &#123;&#125; times used &#123;&#125;s'</span>.format(</span><br><span class="line">        func.__name__.ljust(<span class="number">20</span>),</span><br><span class="line">        count,</span><br><span class="line">        timeit.default_timer() -b ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    count = <span class="number">1000</span></span><br><span class="line">    n = <span class="number">1000</span></span><br><span class="line">    print_func_run_time(count, loop_for, n = n)</span><br><span class="line">    print_func_run_time(count, loop_while, n = n)</span><br><span class="line">    print_func_run_time(count, loop_generator, n = n)</span><br><span class="line">    print_func_run_time(count, loop_list_compre, n = n)</span><br><span class="line">    print_func_run_time(count, loop_map, n = n)</span><br><span class="line">    unittest.main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># .</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Ran 1 test in 0.000s</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># OK</span></span><br><span class="line"><span class="comment"># loop_for             run 1000 times used 0.14018906400087872s</span></span><br><span class="line"><span class="comment"># loop_while           run 1000 times used 0.21399457900042762s</span></span><br><span class="line"><span class="comment"># loop_generator       run 1000 times used 0.12857274799898732s</span></span><br><span class="line"><span class="comment"># loop_list_compre     run 1000 times used 0.08585307099929196s</span></span><br><span class="line"><span class="comment"># loop_map             run 1000 times used 0.043123570998432115s</span></span><br></pre></td></tr></table></figure><p>我们以性能好坏来区分，得到的结论</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &gt; 列表解析 &gt; 生成器 &gt; <span class="keyword">for</span> &gt; <span class="keyword">while</span></span><br></pre></td></tr></table></figure><p><code>map</code> 是内置函数，底层由 C 来编写，最快是毫无疑问的。而 <code>while</code> 是纯 Python 实现的，所以性能最差。</p><p>列表解析比生成器要快一些，这里多少有些存疑，因为我们想要返回列表，所以其实 <code>map</code> 和生成器都是在负重前行，我们修改下测试方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_generator</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = (abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_list_compre</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = [abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_map</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> map(abs, range(n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func_run_time</span><span class="params">(count, func, **kw)</span>:</span></span><br><span class="line">    b = timeit.default_timer()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        func(**kw)</span><br><span class="line">    print(<span class="string">'&#123;&#125; run &#123;&#125; times used &#123;&#125;s'</span>.format(</span><br><span class="line">        func.__name__.ljust(<span class="number">20</span>),</span><br><span class="line">        count,</span><br><span class="line">        timeit.default_timer() -b ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    count = <span class="number">1000</span></span><br><span class="line">    n = <span class="number">1000</span></span><br><span class="line">    print_func_run_time(count, loop_list_compre, n = n)</span><br><span class="line">    print_func_run_time(count, loop_map, n = n)</span><br><span class="line">    print_func_run_time(count, loop_generator, n = n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loop_list_compre     run 1000 times used 0.08865494900237536s</span></span><br><span class="line"><span class="comment"># loop_map             run 1000 times used 0.0007684140000492334s</span></span><br><span class="line"><span class="comment"># loop_generator       run 1000 times used 0.0009459810025873594s</span></span><br></pre></td></tr></table></figure><p>好了，这次我们不再强制转换 list，而仅仅只是返回一个可迭代的对象，发现 <code>map</code> 依然最快，生成器稍慢，而列表解析竟然慢了近百倍。</p><p>这次我们可以下个结论，处理循环时，我们已经尽可能的使用内置方法，然后根据业务需求来选择使用列表解析和生成器，实在不行了使用 <code>for</code> 循环，而 <code>while</code> 则是尽量不去使用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来比较下 Python 中循环语句的性能，参赛选手为 &lt;code&gt;while&lt;/code&gt; &lt;code&gt;for&lt;/code&gt; &lt;code&gt;生成器&lt;/code&gt; &lt;code&gt;内置函数&lt;/code&gt; &lt;code&gt;列表解析&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Pyenv 安装 Python3.7 报错：zlib not available</title>
    <link href="http://wxnacy.com/2019/03/31/pyenv-zlib-not-available/"/>
    <id>http://wxnacy.com/2019/03/31/pyenv-zlib-not-available/</id>
    <published>2019-03-31T05:30:55.000Z</published>
    <updated>2019-04-01T05:33:15.866Z</updated>
    
    <content type="html"><![CDATA[<p>最近升级 Mac 系统，又手贱升级了 pyenv，结果安装 Python3.7 时报了错</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.7 zipimport.ZipImportError: can<span class="string">'t decompress data; zlib not available</span></span><br></pre></td></tr></table></figure><p>查询了下，发现是因为 Xcode 命令行工具没有安装需要的头，需要手动进行安装，运行如下命令可以解决这个问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xcode-select --install</span><br><span class="line">$ sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target /</span><br></pre></td></tr></table></figure><p>我的环境是</p><ul><li>macOS Mojave 10.14.3</li><li>pyenv 1.2.9</li><li><p>安装 3.7.2 版本</p></li><li><p><a href="https://github.com/pyenv/pyenv/issues/1219" target="_blank" rel="noopener">Install failed, “zlib not available” on macOS Mojave</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近升级 Mac 系统，又手贱升级了 pyenv，结果安装 Python3.7 时报了错&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
</feed>
