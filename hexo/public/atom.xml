<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温欣爸比的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wxnacy.com/"/>
  <updated>2019-08-20T06:34:54.439Z</updated>
  <id>http://wxnacy.com/</id>
  
  <author>
    <name>温欣爸比</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 获取当前文件的模块对象</title>
    <link href="http://wxnacy.com/2019/08/20/python-current-module/"/>
    <id>http://wxnacy.com/2019/08/20/python-current-module/</id>
    <published>2019-08-20T06:26:10.000Z</published>
    <updated>2019-08-20T06:34:54.439Z</updated>
    
    <content type="html"><![CDATA[<p>根据<a href="https://www.python.org/dev/peps/pep-3130/" target="_blank" rel="noopener">官方</a>文档可以得到这样的用法</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">mod = sys.modules[__name__]</span><br></pre></td></tr></table></figure><p>这个特性可以应用在什么场景呢？当模块中的方法有什么共同特性时，我们可以配合 <code>getattr</code> 方法来进行动态调用，而不必编写复杂的判断语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_size</span><span class="params">(size: int)</span>:</span></span><br><span class="line">    <span class="string">'''格式化大小'''</span></span><br><span class="line">    unit = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">'B'</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">'K'</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">'M'</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">'G'</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">'T'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1024</span> ** i &lt;= size &lt; <span class="number">1024</span> ** ( i + <span class="number">1</span> ):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                size = size / <span class="number">1024</span> ** i</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&#123;:0.1f&#125;&#123;&#125;'</span>.format( size, unit[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125;B'</span>.format(size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    module = sys.modules[__name__]</span><br><span class="line">    args = sys.argv[<span class="number">1</span>:]</span><br><span class="line">    func_name = args[<span class="number">0</span>]</span><br><span class="line">    func = getattr(module, func_name)</span><br><span class="line">    res = func(int(args[<span class="number">1</span>]))</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用方法</span></span><br><span class="line">    <span class="comment"># $ python utils.py format_size 1024</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据&lt;a href=&quot;https://www.python.org/dev/peps/pep-3130/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方&lt;/a&gt;文档可以得到这样的用法&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 Pillow 包实现图片叠加</title>
    <link href="http://wxnacy.com/2019/08/15/pillow-overlay/"/>
    <id>http://wxnacy.com/2019/08/15/pillow-overlay/</id>
    <published>2019-08-15T09:39:29.000Z</published>
    <updated>2019-08-15T09:55:25.261Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">Pillow</a> 包实现图片叠加非常简单</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#jian-dan-shi-yong">简单使用</a></li><li><a href="#xiang-mu-zhong-shi-yong">项目中使用</a></li></ul><!-- tocstop --></div><h2><span id="jian-dan-shi-yong">简单使用</span><a href="#jian-dan-shi-yong" class="header-anchor"></a></h2><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install Pillow</span><br></pre></td></tr></table></figure><p><strong>简单实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">big_image =Image.open(<span class="string">'big.jpg'</span>)</span><br><span class="line">small_image=Image.open(<span class="string">'small.jpg'</span>)</span><br><span class="line"><span class="comment"># small_image.thumbnail((400,400))  可以实现压缩</span></span><br><span class="line">big_image.paste(small_image,(<span class="number">157</span>, <span class="number">45</span>))</span><br><span class="line">big_image.show()</span><br></pre></td></tr></table></figure><p><strong>原图</strong></p><p><img src="https://wxnacy.com/images/rss.png" alt="1"><br><img src="https://wxnacy.com/images/mp.jpg" alt="2"></p><p><strong>叠加效果</strong></p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/pillow_overlay.png" alt="3"></p><h2><span id="xiang-mu-zhong-shi-yong">项目中使用</span><a href="#xiang-mu-zhong-shi-yong" class="header-anchor"></a></h2><p>在 web 项目中往往我们不会使用本地图片，大多是对网络图片进行处理，再传到线上，所以首先需要能解析网络图片，其次处理后需要拿到图片二进制，再进行上传处理。</p><p>这套逻辑的代码在 <a href="https://github.com/wxnacy/study/blob/master/python/pillow_demo/overlay.py" target="_blank" rel="noopener">https://github.com/wxnacy/study/blob/master/python/pillow_demo/overlay.py</a></p><p>这里复制一份</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># Description: 图片叠加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_image</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">'''通过地址获取 image 对象'''</span></span><br><span class="line">    image = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> path.startswith(<span class="string">'http'</span>):</span><br><span class="line">        res = requests.get(path)</span><br><span class="line">        image = Image.open(io.BytesIO(res.content))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        image = Image.open(path)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image2bytes</span><span class="params">(image)</span>:</span></span><br><span class="line">    <span class="string">'''图片转二进制'''</span></span><br><span class="line">    img_bytes = io.BytesIO()</span><br><span class="line">    image.save(img_bytes, image.format)</span><br><span class="line">    <span class="keyword">return</span> img_bytes.getvalue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overlay</span><span class="params">(big_path, small_path, width, height, small_thumbnail=<span class="params">()</span>)</span>:</span></span><br><span class="line">    <span class="string">'''叠加'''</span></span><br><span class="line">    big_image = get_image(big_path)</span><br><span class="line">    small_image = get_image(small_path)</span><br><span class="line">    <span class="keyword">if</span> small_thumbnail:</span><br><span class="line">        small_image.thumbnail(small_thumbnail)</span><br><span class="line">    big_image.paste(small_image,(width, height))</span><br><span class="line">    big_image.show()    <span class="comment"># 显示图片</span></span><br><span class="line">    <span class="comment">#  big_image.save('/Users/wxnacy/Downloads/pillow_overlay.png')  # 保存</span></span><br><span class="line">    <span class="comment"># 或者返回图片的二进制</span></span><br><span class="line">    <span class="keyword">return</span> image2bytes(big_image)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    overlay(<span class="string">'https://wxnacy.com/images/rss.png'</span>,</span><br><span class="line">            <span class="string">'https://wxnacy.com/images/mp.jpg'</span>, <span class="number">157</span>, <span class="number">45</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/python-pillow/Pillow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pillow&lt;/a&gt; 包实现图片叠加非常简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 配置国内仓库</title>
    <link href="http://wxnacy.com/2019/08/12/docker-use-china-mirrors/"/>
    <id>http://wxnacy.com/2019/08/12/docker-use-china-mirrors/</id>
    <published>2019-08-12T13:38:08.000Z</published>
    <updated>2019-08-12T13:38:08.706Z</updated>
    
    <content type="html"><![CDATA[<p>类似这种需要下载包的一般都要配置个国内的仓库源，同时使用默认的国外仓库，真的很慢。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>以阿里云仓库为例，配置方式很简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://4qqg0972.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类似这种需要下载包的一般都要配置个国内的仓库源，同时使用默认的国外仓库，真的很慢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 开始慢查询日志</title>
    <link href="http://wxnacy.com/2019/08/01/mysql-slow-query-log/"/>
    <id>http://wxnacy.com/2019/08/01/mysql-slow-query-log/</id>
    <published>2019-08-01T09:09:32.000Z</published>
    <updated>2019-08-01T09:09:32.556Z</updated>
    
    <content type="html"><![CDATA[<p>项目长期运行过程中，Mysql 慢查询的监控是必不可少的一步日常工作，今天来说下配置过程。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#pei-zhi">配置</a></li><li><a href="#fen-xi-gong-ju">分析工具</a></li></ul><!-- tocstop --></div><h2><span id="pei-zhi">配置</span><a href="#pei-zhi" class="header-anchor"></a></h2><p>先来查看默认慢查询日志开启状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%slow_query_log%&quot;;</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| Variable_name       | Value                                |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                  |</span><br><span class="line">| slow_query_log_file | /var/lib/mysql/1bcb14797cd4-slow.log |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><ul><li><code>slow_query_log</code> 是否开启慢查询日志，默认关闭</li><li><code>slow_query_log_file</code> 慢查询日志的默认位置，系统自动生成的文件名。自定义的日志名最好符合 <code>*-slow.log</code> 格式，后面会讲到原因。</li></ul><p>因为慢查询日志本身比较耗性能，所以默认是关闭的，在需要的时候我们需要手动打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log=1;</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br></pre></td></tr></table></figure><p>该命令可以全局开启该功能，但是如果 Mysql 服务重启则会还原默认值，想要持久化，需要修改配置文件，然后重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 开启慢查询日志</span></span><br><span class="line">slow_query_log=1</span><br><span class="line"><span class="comment"># 设置慢查询日志位置</span></span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow.log</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart mysql</span><br></pre></td></tr></table></figure><p>修改 <code>slow_query_log_file</code> 时需要注意，文件的目录位置必须已存在，否则会报错，慢查询日志功能自动关闭。</p><p>另外还一些其他的参数可以修改，方法跟上面的一样。</p><ul><li><code>long_query_time</code> 慢查询阈值，当查询时间多于设定的阈值时记录日志。默认 10 秒。</li><li><code>log_queries_not_using_indexes</code> 未使用索引的查询也被记录到慢查询日志中（可选项）。</li><li><code>log_output</code> 日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</li></ul><h2><span id="fen-xi-gong-ju">分析工具</span><a href="#fen-xi-gong-ju" class="header-anchor"></a></h2><p>Mysql 提供了慢查询日志的分析工具 mysqldumpslow，这要比自己查看日志文件要方便的多。</p><p>下面是几个常用的参数</p><ul><li><code>-s</code> 是表示按照何种方式排序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c: 访问计数</span><br><span class="line">l: 锁定时间</span><br><span class="line">r: 返回记录</span><br><span class="line">t: 查询时间</span><br><span class="line">al:平均锁定时间</span><br><span class="line">ar:平均返回记录数</span><br><span class="line">at:平均查询时间</span><br></pre></td></tr></table></figure><ul><li><code>-t</code> 是top n的意思，即为返回前面多少条的数据</li><li><code>-g</code> 后边可以写一个正则匹配模式，大小写不敏感的</li></ul><p>更多的参数可以查看帮助文档 <code>mysqldumpslow --help</code></p><p>举个例子，查看记录最多的 10 个 sql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldumpslow -s r -t 10</span><br><span class="line">Can<span class="string">'t find '</span>/var/lib/mysql/*-slow.log<span class="string">'</span></span><br></pre></td></tr></table></figure><p>如果我们自定义了日志文件，并且格式比较随意，那默认会报找不到文件的错误。</p><p>如果你的日志文件已经自定义为其它格式，那也可以通过传入文件名的方式分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldumpslow -s r -t 10 /var/lib/mysql/some-name.log</span><br></pre></td></tr></table></figure><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html" target="_blank" rel="noopener">The Slow Query Log</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldumpslow.html" target="_blank" rel="noopener">mysqldumpslow — Summarize Slow Query Log Files</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目长期运行过程中，Mysql 慢查询的监控是必不可少的一步日常工作，今天来说下配置过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://wxnacy.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Ansible 在 Vagrant 中使用</title>
    <link href="http://wxnacy.com/2019/07/31/ansible-vagrant-host/"/>
    <id>http://wxnacy.com/2019/07/31/ansible-vagrant-host/</id>
    <published>2019-07-31T09:38:41.000Z</published>
    <updated>2019-07-31T09:38:41.202Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible 在 Vagrant 中使用的难点在于获取 ssh 登录需要的配置信息。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>在默认 <code>Vagrantfile</code> 中我们找不到这些信息，此时需要通过 <code>vagrant ssh-config</code> 命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh-config</span><br><span class="line">Host default</span><br><span class="line">  HostName 127.0.0.1</span><br><span class="line">  User vagrant</span><br><span class="line">  Port 2222</span><br><span class="line">  UserKnownHostsFile /dev/null</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  PasswordAuthentication no</span><br><span class="line">  IdentityFile /Users/wxnacy/.vagrant.d/boxes/wxnacy-VAGRANTSLASH-ubuntu1804/0/virtualbox/vagrant_private_key</span><br><span class="line">  IdentitiesOnly yes</span><br><span class="line">  LogLevel FATAL</span><br></pre></td></tr></table></figure><p>啊，让我费解的 <code>IdentityFile</code> 文件终于露出来，关键就是这个文件。</p><p>接下来我们只需要配置 Ansible 的 hosts 文件，<code>/etc/ansible/hosts</code> 中添加，或者创建独立的 <code>hosts</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vagrant]</span><br><span class="line">127.0.0.1 ansible_ssh_user=vagrant ansible_ssh_port=2222 ansible_ssh_private_key_file=/Users/wxnacy/.vagrant.d/boxes/wxnacy-VAGRANTSLASH-ubuntu1804/0/virtualbox/vagrant_private_key</span><br></pre></td></tr></table></figure><p>最后查看是否能正常连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ansible all -m <span class="built_in">command</span> -a <span class="string">'who'</span> --inventory-file=hosts</span><br><span class="line">127.0.0.1 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">vagrant  pts/0        Jul 30 07:35 (10.0.2.2)</span><br><span class="line">vagrant  pts/1        Jul 30 06:19 (10.0.2.2)</span><br></pre></td></tr></table></figure><p>如果新建其他位置的 <code>hosts</code> 文件，需要 <code>--inventory-file, -i</code> 指定文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ansible 在 Vagrant 中使用的难点在于获取 ssh 登录需要的配置信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vagrant" scheme="http://wxnacy.com/tags/vagrant/"/>
    
      <category term="ansible" scheme="http://wxnacy.com/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Python 报错 f-string expression part cannot include a backslash</title>
    <link href="http://wxnacy.com/2019/07/30/python-f-string-error1/"/>
    <id>http://wxnacy.com/2019/07/30/python-f-string-error1/</id>
    <published>2019-07-30T07:02:15.000Z</published>
    <updated>2019-07-30T07:02:15.722Z</updated>
    
    <content type="html"><![CDATA[<p>Python 3.6 版本新增加的 <code>f-string</code> 语句非常简洁，其中可以直接在字符串中使用表达式，可以让代码写起来非常方便。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>不过也要了解它的一些特性，不然就可能会报一个错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f'say <span class="subst">&#123;<span class="string">"\t"</span> * n&#125;</span>'</span></span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span></span><br><span class="line">SyntaxError: f-string expression part cannot include a backslash</span><br></pre></td></tr></table></figure><p>好像也没有用错，确实应该这样写的，错误翻译过来是 <code>f-string</code> 的表达式中不能出现反斜杠。</p><p>那记住这一点，以后写起来注意下就好了，有两个方法解决。</p><p><strong>外部计算</strong></p><p>将表达式挪到外部计算好后在传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tables = <span class="string">"\t"</span> * n</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f'say <span class="subst">&#123;tables&#125;</span>'</span></span><br><span class="line"><span class="string">'say \t\t'</span></span><br></pre></td></tr></table></figure><p><strong>使用 format </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'say &#123;&#125;'</span>.format(<span class="string">'\t'</span> * n)</span><br><span class="line"><span class="string">'say \t\t'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 3.6 版本新增加的 &lt;code&gt;f-string&lt;/code&gt; 语句非常简洁，其中可以直接在字符串中使用表达式，可以让代码写起来非常方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 容器的一些操作</title>
    <link href="http://wxnacy.com/2019/07/27/docker-container-cmd/"/>
    <id>http://wxnacy.com/2019/07/27/docker-container-cmd/</id>
    <published>2019-07-27T13:22:38.000Z</published>
    <updated>2019-07-27T13:22:38.096Z</updated>
    
    <content type="html"><![CDATA[<p>整理自<a href="https://yeasy.gitbooks.io/docker_practice/container/" target="_blank" rel="noopener">操作 Docker 容器</a>，为了方便查看简化整理为一篇。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#qi-dong-rong-qi">启动容器</a></li><li><a href="#jin-ru-rong-qi">进入容器</a></li><li><a href="#dao-chu-he-dao-ru">导出和导入</a></li><li><a href="#ting-zhi-rong-qi">停止容器</a></li><li><a href="#shan-chu">删除</a></li></ul><!-- tocstop --></div><h2><span id="qi-dong-rong-qi">启动容器</span><a href="#qi-dong-rong-qi" class="header-anchor"></a></h2><p><strong>新建并启动</strong></p><p>启动容器并执行命令后，如果命令进程退出，该容器也会立马终止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:bionic <span class="built_in">echo</span> <span class="string">'hello world'</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>在全部容器列表中可以查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">7c4a4cea19aa        ubuntu:bionic       <span class="string">"echo 'hello world'"</span>   3 minutes ago       Exited (0) 7 seconds ago                       elegant_brahmagupta</span><br></pre></td></tr></table></figure><p>使用 <code>-it</code> 参数可以进入交互模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu:bionic /bin/bash</span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># ls</span></span><br><span class="line">bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  etc  lib   media  opt  root  sbin  sys  usr</span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。</p><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p><strong>启动已终止容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>以刚才的交互模式容器为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a                    <span class="comment"># 1</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED              STATUS                          PORTS               NAMES</span><br><span class="line">7c4a4cea19aa        ubuntu:bionic       <span class="string">"echo 'hello world'"</span>   About a minute ago   Exited (0) About a minute ago                       elegant_brahmagupta</span><br><span class="line">82a4d9031d1c        ubuntu:bionic       <span class="string">"/bin/bash"</span>            2 minutes ago        Exited (0) About a minute ago                       tender_jennings</span><br><span class="line"></span><br><span class="line">$ docker container start 82a4d9031d1c       <span class="comment"># 2</span></span><br><span class="line">82a4d9031d1c</span><br><span class="line"></span><br><span class="line">$ docker container ls                       <span class="comment"># 3</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">82a4d9031d1c        ubuntu:bionic       <span class="string">"/bin/bash"</span>            3 minutes ago       Up 7 seconds                                        tender_jennings</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 82a4d9031d1c /bin/bash    <span class="comment"># 4</span></span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># ps                     # 5</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">   25 pts/1    00:00:00 bash</span><br><span class="line">   34 pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure><ul><li><code>1</code> 查看所有转态的容器</li><li><code>2</code> 启动执行 <code>/bin/bash</code> 命令的容器</li><li><code>3</code> 查看当前运行的容器</li><li><code>4</code> 启动容器的交互模式</li><li><code>5</code> 查看容器中的进程</li></ul><p>通过最后一步可以得知，容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p><strong>后台守护运行</strong></p><p>使用 <code>-d</code> 参数即可将容器在后台运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs -f &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>即可实时查看最新日志</p><h2><span id="jin-ru-rong-qi">进入容器</span><a href="#jin-ru-rong-qi" class="header-anchor"></a></h2><p>前面我们试过使用 <code>run</code> 命令配合 <code>-it</code> 参数来进入交互模式，进入容器的交互模式也是类似，不过这里需要 <code>exec</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it ubuntu:bionic /bin/bash</span><br><span class="line">root@82a4d9031d1c:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>使用完毕，使用 <code>exit</code> 退出即可，容器的运行状态不会影响。</p><p>还有一个命令也可以进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach &lt;id|name&gt;</span><br></pre></td></tr></table></figure><p>但是该模式下使用 <code>exit</code> 退出时，容器也会跟着停止，所以并不实用，了解即可。</p><h2><span id="dao-chu-he-dao-ru">导出和导入</span><a href="#dao-chu-he-dao-ru" class="header-anchor"></a></h2><p><strong>导出</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">82a4d9031d1c        ubuntu:bionic       <span class="string">"/bin/bash"</span>            3 minutes ago       Up 7 seconds                                        tender_jennings</span><br><span class="line">$ docker <span class="built_in">export</span> 82a4d9031d1c &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>将容器快照导出到本地</p><p><strong>导入容器镜像</strong></p><p>使用本地文件导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | docker import demo/ubuntu:v1.0</span><br></pre></td></tr></table></figure><p>使用网络地址导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz demo/ubuntu:v1.0</span><br></pre></td></tr></table></figure><p>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h2><span id="ting-zhi-rong-qi">停止容器</span><a href="#ting-zhi-rong-qi" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop &lt;id|name&gt;       <span class="comment"># 停止容器</span></span><br><span class="line">$ docker container start &lt;id|name&gt;      <span class="comment"># 启动容器</span></span><br><span class="line">$ docker container restart &lt;id|name&gt;    <span class="comment"># 重启容器</span></span><br></pre></td></tr></table></figure><h2><span id="shan-chu">删除</span><a href="#shan-chu" class="header-anchor"></a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭已经停止的容器</span></span><br><span class="line">$ docker container rm &lt;id:name&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</span></span><br><span class="line">$ docker container rm -f &lt;id:name&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭全部终止状态的容器</span></span><br><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理自&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/container/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;操作 Docker 容器&lt;/a&gt;，为了方便查看简化整理为一篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 改变镜像下载目录</title>
    <link href="http://wxnacy.com/2019/07/26/docker-change-store-dir/"/>
    <id>http://wxnacy.com/2019/07/26/docker-change-store-dir/</id>
    <published>2019-07-26T07:16:22.000Z</published>
    <updated>2019-07-26T07:16:22.830Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 占用储存空间很大的部分在于下载的镜像，因为 Docker 包括容器、镜像等存储数据都默认保存在 <code>/var/lib/docker</code> 目录下，如果系统磁盘空间比较小的话就会很麻烦，我想将目录改为挂载的扩充磁盘上。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>先停止 Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br></pre></td></tr></table></figure><p>确认没有 Docker 进程在跑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps faux | grep docker</span><br></pre></td></tr></table></figure><p>假设新的目录为 <code>/data/docker</code>，先将数据复制到新的目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp -r /var/lib/docker /data/docker</span><br></pre></td></tr></table></figure><p>然后将该目录软连接到 <code>/var/lib/docker</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -sf /data/docker /var/lib/docker</span><br></pre></td></tr></table></figure><p>启动 Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>最后查看镜像列表是否正常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker image ls</span><br></pre></td></tr></table></figure><p>这样软连接的方式是比较灵活的，不会改变我们熟知的存储目录。官方论坛中也有修改配置文件来全局修改存储位置的方法，感兴趣的同学可以点击下方链接进入。</p><ul><li><a href="https://forums.docker.com/t/how-do-i-change-the-docker-image-installation-directory/1169/1" target="_blank" rel="noopener">How do I change the Docker image installation directory?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 占用储存空间很大的部分在于下载的镜像，因为 Docker 包括容器、镜像等存储数据都默认保存在 &lt;code&gt;/var/lib/docker&lt;/code&gt; 目录下，如果系统磁盘空间比较小的话就会很麻烦，我想将目录改为挂载的扩充磁盘上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 报错 Please provide a source image with `from` prior to commit</title>
    <link href="http://wxnacy.com/2019/07/22/docker-before-from-use-args/"/>
    <id>http://wxnacy.com/2019/07/22/docker-before-from-use-args/</id>
    <published>2019-07-22T01:38:03.000Z</published>
    <updated>2019-07-22T01:38:03.405Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 openresty 的 <a href="https://hub.docker.com/r/openresty/openresty/" target="_blank" rel="noopener">docker</a> 版本时，需要重构镜像，本地测试通过，但服务器上报错。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please provide a <span class="built_in">source</span> image with `from` prior to commit</span><br></pre></td></tr></table></figure><p>Google 后发现问题出在这里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG RESTY_IMAGE_BASE=<span class="string">"ubuntu"</span></span><br><span class="line">ARG RESTY_IMAGE_TAG=<span class="string">"bionic"</span></span><br><span class="line"></span><br><span class="line">FROM <span class="variable">$&#123;RESTY_IMAGE_BASE&#125;</span>:<span class="variable">$&#123;RESTY_IMAGE_TAG&#125;</span></span><br></pre></td></tr></table></figure><p>在老版本中是不支持 <code>FROM</code> 前使用 <code>ARG</code> 的，这个问题在 <a href="https://github.com/moby/moby/pull/31352" target="_blank" rel="noopener">docker 17.05.0-ce</a> 版本中得到了修改，而服务器上的版本比较老，所以才报错，只要升级版本即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 openresty 的 &lt;a href=&quot;https://hub.docker.com/r/openresty/openresty/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;docker&lt;/a&gt; 版本时，需要重构镜像，本地测试通过，但服务器上报错。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://wxnacy.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant 使用 root 账号登录</title>
    <link href="http://wxnacy.com/2019/07/18/vagrant-root-login/"/>
    <id>http://wxnacy.com/2019/07/18/vagrant-root-login/</id>
    <published>2019-07-18T09:42:57.000Z</published>
    <updated>2019-07-18T09:42:57.127Z</updated>
    
    <content type="html"><![CDATA[<p>Vagrant 想要使用 root 身份登录要稍微麻烦一点。网上的文章大多是从一个地方抄过来的，并且还没抄对，所以我在这里总结一篇正确做法。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#xiu-gai-sshd-pei-zhi">修改 sshd 配置</a></li><li><a href="#xiu-gai-vagrantfile">修改 Vagrantfile</a></li><li><a href="#shi-yong-gong-si-yao-deng-lu">使用公私钥登录</a></li></ul><!-- tocstop --></div><h2><span id="xiu-gai-sshd-pei-zhi">修改 sshd 配置</span><a href="#xiu-gai-sshd-pei-zhi" class="header-anchor"></a></h2><p>首先以默认身份登录，并修改 <code>sshd</code> 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh</span><br><span class="line">$ sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>做如下变动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PermitRootLogin prohibit-password</span></span><br><span class="line">PermitRootLogin yes             <span class="comment"># 允许 root 身份登录</span></span><br><span class="line"><span class="comment"># PasswordAuthentication on</span></span><br><span class="line">PasswordAuthentication yes      <span class="comment"># 可以使用密码登录</span></span><br></pre></td></tr></table></figure><p>重启 <code>sshd</code> 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><h2><span id="xiu-gai-vagrantfile">修改 Vagrantfile</span><a href="#xiu-gai-vagrantfile" class="header-anchor"></a></h2><p>增加如下配置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.ssh.username = <span class="string">'root'</span></span><br><span class="line">config.ssh.password = <span class="string">'root'</span></span><br><span class="line">config.ssh.insert_key = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>然后再次登录即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh</span><br></pre></td></tr></table></figure><p>这里注意，网上大部分给出的例子是设置 <code>config.ssh.insert_key = true</code>，如果你这样设置了，会发现 <code>config.ssh.password</code> 将会失效，每次登录都需要手动输入密码。</p><p>为什么呢？根据<a href="https://www.vagrantup.com/docs/vagrantfile/ssh_settings.html#config-ssh-insert_key" target="_blank" rel="noopener">官网</a>的定义，<code>config.ssh.insert_key</code> 代表了是否使用公私钥来登录虚拟机，如果你想要使用不那么安全的登录方式，比如密码登录，则可以将它设置为 <code>false</code>，它的默认值为 <code>true</code></p><p>了解了这一点，就可以发现手动设置 <code>config.ssh.insert_key=true</code> 是有点蠢的做法。</p><h2><span id="shi-yong-gong-si-yao-deng-lu">使用公私钥登录</span><a href="#shi-yong-gong-si-yao-deng-lu" class="header-anchor"></a></h2><p>使用密码登录的缺点很明显，明文的密码就像只穿一个裤衩就出门一样让人不安，默认的 <code>vagrant</code> 就不需要密码，那它是怎么登录的呢？</p><p>关于怎么使用公私钥登录服务器可以查看这篇文章 <a href="/2017/08/23/linux-2017-08-23-ssh/">Linux SSH 登陆远程服务器和无密码操作</a></p><p>有了这篇文章作为基础，我们来查看下 <code>vagrant</code> 账号是否做了秘钥登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /home/vagrant/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>执行这条命令后会发现文件中包含一条记录，证明了确实使用了秘钥登录。</p><p>下面我们为 <code>root</code> 用户赋予秘钥登录的功能</p><p>首先将电脑的公钥内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>复制到虚拟机中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'公钥内容'</span> &gt;&gt; /home/vagrant/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后修改 <code>Vagrantfile</code> 配置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config.ssh.username = <span class="string">'root'</span>                                <span class="comment"># 使用 root 身份登录</span></span><br><span class="line">config.ssh.private_key_path = <span class="string">'/Users/wxnacy/.ssh/id_rsa'</span>   <span class="comment"># 私钥位置</span></span><br></pre></td></tr></table></figure><p>接下来在登录会发现如 <code>vagrant</code> 账号般顺滑</p><ul><li><a href="https://www.vagrantup.com/docs/vagrantfile/ssh_settings.html#config-ssh-private_key_path" target="_blank" rel="noopener">SSH Settings</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vagrant 想要使用 root 身份登录要稍微麻烦一点。网上的文章大多是从一个地方抄过来的，并且还没抄对，所以我在这里总结一篇正确做法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vagrant" scheme="http://wxnacy.com/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 Requests 模块进行身份验证</title>
    <link href="http://wxnacy.com/2019/07/17/requests-auth/"/>
    <id>http://wxnacy.com/2019/07/17/requests-auth/</id>
    <published>2019-07-17T02:46:27.000Z</published>
    <updated>2019-07-17T02:46:27.152Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">Requests</a> 可以说是 Python 最好用的 http 模块，没有之一。</p><a id="more"></a><p>它对于身份验证有非常方便的使用规则。</p><p><strong>基本身份验证</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'https://api.github.com/user'</span>, auth=HTTPBasicAuth(<span class="string">'user'</span>, <span class="string">'pass'</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p>因为这种验证非常常用，所以也提供了方便的写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'https://api.github.com/user'</span>, auth=(<span class="string">'user'</span>, <span class="string">'pass'</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p><strong>摘要式身份认证</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPDigestAuth</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/digest-auth/auth/user/pass'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(url, auth=HTTPDigestAuth(<span class="string">'user'</span>, <span class="string">'pass'</span>))</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p><strong>OAuth 1</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> requests_oauthlib <span class="keyword">import</span> OAuth1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.twitter.com/1.1/account/verify_credentials.json'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>auth = OAuth1(<span class="string">'YOUR_APP_KEY'</span>, <span class="string">'YOUR_APP_SECRET'</span>,</span><br><span class="line"><span class="meta">... </span>              <span class="string">'USER_OAUTH_TOKEN'</span>, <span class="string">'USER_OAUTH_TOKEN_SECRET'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(url, auth=auth)</span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure><p>更多复杂验证如 OAuth 2，请参看<a href="http://docs.python-requests.org/zh_CN/latest/user/authentication.html?highlight=requests.auth#oauth-2-openid" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/kennethreitz/requests&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Requests&lt;/a&gt; 可以说是 Python 最好用的 http 模块，没有之一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 报错 no resolver defined to resolve</title>
    <link href="http://wxnacy.com/2019/07/16/nginx-no-resolver-defined-to-resolve/"/>
    <id>http://wxnacy.com/2019/07/16/nginx-no-resolver-defined-to-resolve/</id>
    <published>2019-07-16T06:49:25.000Z</published>
    <updated>2019-07-16T06:49:25.476Z</updated>
    
    <content type="html"><![CDATA[<p>起因是使用 <code>ngxin + lua</code> 链接外部机器 Redis 时产生的</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>原因是 Nginx 0.6.18以后的版本中启用了一个resolver指令，在使用变量来构造某个server地址的时候一定要用resolver指令来指定DNS服务器的地址，所以解决这个问题的方法很简单：在nginx的配置文件中的http{}部分添加一行DNS地址即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果机器支持 ipv6，可以去掉对它的支持，免得产生类似错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8 ipv6=off;</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-resty-redis/issues/159" target="_blank" rel="noopener">No resolver defined to resolve</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起因是使用 &lt;code&gt;ngxin + lua&lt;/code&gt; 链接外部机器 Redis 时产生的&lt;/p&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://wxnacy.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Python 对 JSON 中的特殊类型进行 Encoder</title>
    <link href="http://wxnacy.com/2019/07/13/python-json-encoder-decoder/"/>
    <id>http://wxnacy.com/2019/07/13/python-json-encoder-decoder/</id>
    <published>2019-07-13T01:56:59.000Z</published>
    <updated>2019-07-13T02:04:21.229Z</updated>
    
    <content type="html"><![CDATA[<p>Python 处理 JSON 数据时，<code>dumps</code> 函数是经常用到的，当 JSON 数据中有特殊类型时，往往是比较头疼的，因为经常会报这样一个错误。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#zi-ding-yi-bian-ma-lei">自定义编码类</a></li><li><a href="#dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang">单分派装饰器处理对象</a></li></ul><!-- tocstop --></div><h2><span id="zi-ding-yi-bian-ma-lei">自定义编码类</span><a href="#zi-ding-yi-bian-ma-lei" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">USER_DATA = dict(</span><br><span class="line">    id = <span class="number">1</span>, name = <span class="string">'wxnacy'</span>, ts = datetime.now()</span><br><span class="line">)</span><br><span class="line">print(json.dumps(USER_DATA))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/wxnacy/PycharmProjects/study/python/office_module/json_demo/dumps.py"</span>, line 74, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dumps_encoder()</span><br><span class="line">  File <span class="string">"/Users/wxnacy/PycharmProjects/study/python/office_module/json_demo/dumps.py"</span>, line 68, <span class="keyword">in</span> dumps_encoder</span><br><span class="line">    <span class="built_in">print</span>(json.dumps(USER_DATA))</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/__init__.py"</span>, line 231, <span class="keyword">in</span> dumps</span><br><span class="line">    <span class="built_in">return</span> _default_encoder.encode(obj)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 199, <span class="keyword">in</span> encode</span><br><span class="line">    chunks = self.iterencode(o, _one_shot=True)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 257, <span class="keyword">in</span> iterencode</span><br><span class="line">    <span class="built_in">return</span> _iterencode(o, 0)</span><br><span class="line">  File <span class="string">"/Users/wxnacy/.pyenv/versions/3.6.0/Python.framework/Versions/3.6/lib/python3.6/json/encoder.py"</span>, line 180, <span class="keyword">in</span> default</span><br><span class="line">    o.__class__.__name__)</span><br><span class="line">TypeError: Object of <span class="built_in">type</span> <span class="string">'datetime'</span> is not JSON serializable</span><br></pre></td></tr></table></figure><p>原因在于 <code>dumps</code> 函数不知道如何处理 <code>datetime</code> 对象，默认情况下 <code>json</code> 模块使用 <code>json.JSONEncoder</code> 类来进行编码，此时我们需要自定义一下编码类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(x, datetime):</span><br><span class="line">            <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line">        <span class="keyword">return</span> super().default(self, x)</span><br></pre></td></tr></table></figure><p>定义编码类 <code>CustomEncoder</code> 并重写实例的 <code>default</code> 函数，对特殊类型进行处理，其余类型继续使用父类的解析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(x, datetime):</span><br><span class="line">            <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line">        <span class="keyword">return</span> super().default(self, x)</span><br><span class="line"></span><br><span class="line">USER_DATA = dict(</span><br><span class="line">    id = <span class="number">1</span>, name = <span class="string">'wxnacy'</span>, ts = datetime.now()</span><br><span class="line">)</span><br><span class="line">print(json.dumps(USER_DATA, cls=CustomEncoder))</span><br><span class="line"><span class="comment"># &#123;"id": 1, "name": "wxnacy", "ts": 1562938926&#125;</span></span><br></pre></td></tr></table></figure><p>最后整合起来，将类使用 <code>cls</code> 参数传入 <code>dumps</code> 函数即可。</p><p>使用 <code>CustomEncoder</code> 实例的 <code>encode</code> 函数可以对对象进行转码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line">print(CustomEncoder().encode(datetime.now()))</span><br><span class="line"><span class="comment"># 1562939035</span></span><br></pre></td></tr></table></figure><p>在父类源码中，所有的编码逻辑都在 <code>encode</code> 函数中，<code>default</code> 只负责抛出 <code>TypeError</code> 异常，这就是文章开始报错的出处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, o)</span>:</span></span><br><span class="line">    <span class="string">"""Implement this method in a subclass such that it returns</span></span><br><span class="line"><span class="string">    a serializable object for ``o``, or calls the base implementation</span></span><br><span class="line"><span class="string">    (to raise a ``TypeError``).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For example, to support arbitrary iterators, you could</span></span><br><span class="line"><span class="string">    implement default like this::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        def default(self, o):</span></span><br><span class="line"><span class="string">            try:</span></span><br><span class="line"><span class="string">                iterable = iter(o)</span></span><br><span class="line"><span class="string">            except TypeError:</span></span><br><span class="line"><span class="string">                pass</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                return list(iterable)</span></span><br><span class="line"><span class="string">            # Let the base class default method raise the TypeError</span></span><br><span class="line"><span class="string">            return JSONEncoder.default(self, o)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">f'Object of type <span class="subst">&#123;o.__class__.__name__&#125;</span> '</span></span><br><span class="line">                    <span class="string">f'is not JSON serializable'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self, o)</span>:</span></span><br><span class="line">    <span class="string">"""Return a JSON string representation of a Python data structure.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from json.encoder import JSONEncoder</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; JSONEncoder().encode(&#123;"foo": ["bar", "baz"]&#125;)</span></span><br><span class="line"><span class="string">    '&#123;"foo": ["bar", "baz"]&#125;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># This is for extremely simple cases and benchmarks.</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(o, str):</span><br><span class="line">        <span class="keyword">if</span> self.ensure_ascii:</span><br><span class="line">            <span class="keyword">return</span> encode_basestring_ascii(o)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> encode_basestring(o)</span><br><span class="line">    <span class="comment"># This doesn't pass the iterator directly to ''.join() because the</span></span><br><span class="line">    <span class="comment"># exceptions aren't as detailed.  The list call should be roughly</span></span><br><span class="line">    <span class="comment"># equivalent to the PySequence_Fast that ''.join() would do.</span></span><br><span class="line">    chunks = self.iterencode(o, _one_shot=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(chunks, (list, tuple)):</span><br><span class="line">        chunks = list(chunks)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(chunks)</span><br></pre></td></tr></table></figure><h2><span id="dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang">单分派装饰器处理对象</span><a href="#dan-fen-pai-zhuang-shi-qi-chu-li-dui-xiang" class="header-anchor"></a></h2><p><code>CustomEncoder</code> 如果处理的对象种类很多的话，需要写多个 <code>if elif else</code> 来区分，这样并不是不行，但是不够优雅，不够 pythonic</p><p>根据对象的类型不同，而做出不同的处理。刚好有个装饰器可以做到这点，它就是单分派函数 <code>functools.singledispatch</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> encode(x)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> super().default(self, x)</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch             # 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">'Unencode type'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@encode.register(datetime)  # 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(x.timestamp())</span><br><span class="line"></span><br><span class="line"><span class="meta">@encode.register(date)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x.isoformat()</span><br><span class="line"></span><br><span class="line">print(json.dumps(dict(dt = datetime.now(), d = date.today()), cls=CustomEncoder))</span><br><span class="line"><span class="comment"># &#123;"dt": 1562940781, "d": "2019-07-12"&#125;</span></span><br></pre></td></tr></table></figure><ul><li>1 使用 <code>@singledispatch</code> 装饰 <code>encode</code> 函数，是他处理默认类型。同时给他添加一个装饰器构造函数变量。</li><li>2 <a href="mailto:`@encode.register" target="_blank" rel="noopener">`@encode.register</a>()` 是一个装饰器构造函数，接收需要处理的对象类型作为参数。用它装饰的函数不需要名字，<em>_</em> 代替即可。</li></ul><p>最后提一点，<code>json</code> 也可以在命令行中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'&#123;"json": "obj"&#125;'</span> | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"json"</span>: <span class="string">"obj"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">json</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 处理 JSON 数据时，&lt;code&gt;dumps&lt;/code&gt; 函数是经常用到的，当 JSON 数据中有特殊类型时，往往是比较头疼的，因为经常会报这样一个错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 如何安装 Redis</title>
    <link href="http://wxnacy.com/2019/07/12/centos7-install-redis/"/>
    <id>http://wxnacy.com/2019/07/12/centos7-install-redis/</id>
    <published>2019-07-12T09:02:08.000Z</published>
    <updated>2019-07-12T09:06:01.078Z</updated>
    
    <content type="html"><![CDATA[<p>Centos 默认仓库不包含 Redis 安装包，我们可以从 Remi 仓库中来安装。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p><strong>安装 Remi 仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install epel-release yum-utils</span><br><span class="line">$ sudo yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm</span><br><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> remi</span><br></pre></td></tr></table></figure><p><strong>安装 Redis</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y redis</span><br></pre></td></tr></table></figure><p><strong>启动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start redis    <span class="comment"># 启动</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> redis   <span class="comment"># 开机自启</span></span><br></pre></td></tr></table></figure><p><strong>测试是否安装成功</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><ul><li><a href="https://linuxize.com/post/how-to-install-and-configure-redis-on-centos-7/" target="_blank" rel="noopener">How To Install and Configure Redis on CentOS 7</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Centos 默认仓库不包含 Redis 安装包，我们可以从 Remi 仓库中来安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>apt 下载报错 [Could not get lock /var/lib/dpkg/lock-frontend]</title>
    <link href="http://wxnacy.com/2019/07/11/apt-install-error/"/>
    <id>http://wxnacy.com/2019/07/11/apt-install-error/</id>
    <published>2019-07-11T13:15:29.000Z</published>
    <updated>2019-07-11T13:35:24.193Z</updated>
    
    <content type="html"><![CDATA[<p>有两种情况会导致软件安装工具报这种错</p><ul><li><code>Synaptic Package Manager</code> 或 <code>Software Updater</code> 是打开的。</li><li>一些apt命令在终端中运行或者在后台有进程正在运行。</li></ul><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y redis</span><br><span class="line">E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)</span><br><span class="line">E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?</span><br></pre></td></tr></table></figure><p><strong>查看进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep apt</span><br><span class="line">root 1747 0.0 0.0 4628 808 ? Ss 07:06 0:00 /bin/sh /usr/lib/apt/apt.systemd.daily update</span><br><span class="line">root 1769 0.0 0.0 4628 1820 ? S 07:06 0:00 /bin/sh /usr/lib/apt/apt.systemd.daily lock_is_held update</span><br><span class="line">_apt 16225 3.0 0.2 80192 8796 ? S 07:07 0:04 /usr/lib/apt/methods/http</span><br><span class="line">_apt 16226 0.7 0.2 80188 8800 ? S 07:07 0:01 /usr/lib/apt/methods/http</span><br></pre></td></tr></table></figure><p><strong>停掉进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo killall apt apt-get</span><br></pre></td></tr></table></figure><p>这是比较快捷的方式，但是还不够，前两条都无法关闭，只能将 pid 杀死</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">kill</span> -9 &lt;pid&gt;</span><br></pre></td></tr></table></figure><p><strong>删除加锁文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /var/lib/apt/lists/lock</span><br><span class="line">$ sudo rm /var/cache/apt/archives/lock</span><br><span class="line">$ sudo rm /var/lib/dpkg/lock*</span><br></pre></td></tr></table></figure><p><strong>重新配置 dpkg</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg --configure -a</span><br><span class="line">dpkg: error: parsing file <span class="string">'/var/lib/dpkg/updates/0004'</span> near line 0:</span><br><span class="line">newline <span class="keyword">in</span> field name <span class="string">'#padding'</span></span><br></pre></td></tr></table></figure><p>这时候有可能还会出现一个错误，这时要手动删除该文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/dpkg/updates/0004</span><br></pre></td></tr></table></figure><p>再次执行配置命令，然后继续安装软件即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update -y</span><br><span class="line">$ sudo apt install -y redis</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两种情况会导致软件安装工具报这种错&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Synaptic Package Manager&lt;/code&gt; 或 &lt;code&gt;Software Updater&lt;/code&gt; 是打开的。&lt;/li&gt;
&lt;li&gt;一些apt命令在终端中运行或者在后台有进程正在运行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 内存管理之 `*` 运算的陷阱</title>
    <link href="http://wxnacy.com/2019/07/10/python-memory-mul/"/>
    <id>http://wxnacy.com/2019/07/10/python-memory-mul/</id>
    <published>2019-07-10T13:05:49.000Z</published>
    <updated>2019-07-10T13:06:47.677Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中实现了 <code>__mul__</code> 魔法函数的对象，都支持 <code>*</code> 号运算。内置类型更是默认实现了该函数，使用起来也很方便。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>但是对列表对象进行 <code>*</code> 运算时，却不得不注意一个陷阱。</p><p>刚接触这个特性时，美滋滋的以为可以快速的扩展列表，比如这样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>看起来没什么问题，然而实际开发中没这么简单的例子，随便复杂一点，就会出现问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [[]] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[], [], []]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>很显然出现了问题，我只是给索引位置 <code>0</code> 的元素增加了一个子元素，然后所有的元素都改变了。</p><p>出现这个问题的原因是 <code>*</code> 运算复制的不是子元素，而是当前子元素所指对象的引用，所以当改变该对象时，所有引用该对象的元素都会发生改变。</p><p>关于对象引用可以看 <a href="/2019/06/16/python-memory-management">Python 内存管理</a>，里面有更详细的讲解。</p><p>再看一个现象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>] = [<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">2</span>], [<span class="number">1</span>], [<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>这次就想开始那个简单例子一样，结果跟我们预期的一样，这次是为什么呢？</p><p>因为我们没有改变该索引位置的对象，而是让他引向了新的对象 <code>[2]</code>，这样就不影响其他索引位置的对象了。</p><p>那么怎么才能做到扩展列表呢？答案是列表解析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[[], [], []]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="number">0</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[[<span class="number">1</span>], [], []]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中实现了 &lt;code&gt;__mul__&lt;/code&gt; 魔法函数的对象，都支持 &lt;code&gt;*&lt;/code&gt; 号运算。内置类型更是默认实现了该函数，使用起来也很方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 命令行参数模块 argparse</title>
    <link href="http://wxnacy.com/2019/07/08/python-argparse/"/>
    <id>http://wxnacy.com/2019/07/08/python-argparse/</id>
    <published>2019-07-08T13:32:29.000Z</published>
    <updated>2019-07-10T14:19:15.386Z</updated>
    
    <content type="html"><![CDATA[<p>Python 有很多处理命令行参数的外部模块，<a href="https://github.com/pallets/click" target="_blank" rel="noopener">click</a> 是其中的佼佼者，如果你是要完成一个稍微复杂点的项目，我也推荐使用它。但是如果编写一个独立的脚本，我认为方便简洁才是最重要的，也就是能用内置模块就用内置模块。此时了解相应功能的实现方式就尤为重要，何况 <a href="https://docs.python.org/3/howto/argparse.html" target="_blank" rel="noopener">argparse</a> 也真的没有想象中的那么难用。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#chu-shi-hua">初始化</a></li><li><a href="#jie-xi-can-shu">解析参数</a></li><li><a href="#shi-ji-ming-ling-de-li-zi">实际命令的例子</a></li></ul><!-- tocstop --></div><p>直接进入正题，基础用法如下</p><h2><span id="chu-shi-hua">初始化</span><a href="#chu-shi-hua" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># filename: demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'This is a argparse demo'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python demo.py -h</span><br><span class="line">usage: demo.py [-h]</span><br><span class="line"></span><br><span class="line">This is a argparse demo</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>三行代码即可初始化一个命令行参数模块，默认有一个 <code>-h, --help</code> 参数显示帮助信息。</p><p><code>ArgumentParser</code> 函数有如下参数:</p><ul><li><code>prog</code> 程序的名字，默认是argv[0]。若设置，则在帮助信息中，可以使用%(prog)s来作为格式化的引用（修改一处全局受用）。</li><li><code>usage</code> 帮助信息的usage字段，描述程序的各种用法，默认情况下会依据add_argument()来自动生成。</li><li><code>description</code> 一个简单描述程序主要干啥以及怎么用的字符段，默认为空。</li><li><code>epilog</code> optional arguments字符段之后的字符段，默认为空。</li><li><code>parents</code> 继承的父parser，为了避免一些公共的内容重复定义，父parser在初始化时会设置add_help=False，这是为了防止出现父与子parser的-h冲突而抛出异常。</li><li><code>formatter_class</code> 对于help输出进行格式化，除了输出的样式外，如果设置为ArgumentDefaultsHelpFormatter，则会自动在help输出中添加已定义的default值。</li><li><code>prefix_chars</code> options前的字符，默认为’-‘，可以添加其他字符，如’-+’，但是如果没有包括’-‘，那么对应的option如’-h’就无法解析。</li><li><code>fromfile_prefix_chars</code> 有时会使用文件给parse_args()传入参数，为了能够识别文件字符串，如”demo.txt”，需要设置此值，如”@”，那么所有以此字符为开头的字符串都被当作是文件，所以传给parse_args()的参数应该是@demo.txt。在该文件中，一行只能有一个参数。如文件中的’-f\nbar’会被解析成[‘-f’,’bar’]。</li><li><code>argument_default</code> 一般情况下，默认值使用add_argument()来添加，或者使用set_defaults()设置一些键值对来添加。剩下一种情况就是设置此项（此处没看明白是咋回事）。</li><li><code>conflict_handler</code> 解决在add_argument()阶段有冲突的option的依据策略，默认为error即抛出异常。一般情况下遇到冲突是抛出异常即可，但是如果设置了parents，那么需要重写父parser中的规则的时候，就需要将此项设置为resolve，但是重写是精确匹配的，如老规则定义了-h/–help，重写了-h，那么–help还是老规则。</li><li><code>add_help</code> 是否添加-h/–helpoption，默认为True。为False时，是要做parent（其实可以设置子Parser重写）。默认是-h/–help，若prefix_chars中没有包含’-‘，那么就以其中第一个字符作为代替。</li></ul><h2><span id="jie-xi-can-shu">解析参数</span><a href="#jie-xi-can-shu" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: wxnacy(wxnacy@gmail.com)</span></span><br><span class="line"><span class="comment"># filename: demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'This is a argparse demo'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'file'</span>, help=<span class="string">'List file or dir'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-u'</span>, <span class="string">'--user'</span>, help=<span class="string">'Config user name'</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.file)</span><br><span class="line">print(args.user)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python demo.py bashrc -u wxnacy</span><br><span class="line">bashrc</span><br><span class="line">wxnacy</span><br></pre></td></tr></table></figure><p><code>add_argument</code> 函数有如下参数：</p><ul><li><p><code>name or flags</code> 是位置参数，则需要传入名字；要是可选参数，则需要进行定义，如’-f’，’–foo’。</p></li><li><p><code>action</code> 定义传入的参数如何处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">action=&apos;store&apos;，默认取值，保存传入参数。</span><br><span class="line">action=&apos;store_const&apos;，需要添加const，意味着该argument的值不从命令行输入，而是取const的值。</span><br><span class="line">action=&apos;store_true&apos; or action=&apos;store_false&apos;，&apos;store_const&apos;的特殊情形，意味着const的值为True或False。</span><br><span class="line">action=&apos;append&apos;，表示传入的值会作为一个列表的一项，意味着option可以在命令行中多次出现。</span><br><span class="line">action=&apos;append_const&apos;，传入列表的项由const定义，通常用在需要多个argument将值传入一个列表中的场景。</span><br><span class="line">action=&apos;count&apos;，输出argument出现的次数。</span><br><span class="line">action=&apos;help&apos;，已默认添加。</span><br><span class="line">action=&apos;version&apos;，需要定义version，使用时输出版本信息并退出。</span><br><span class="line">自定义，通过定义一个argparse.Action子类来实现。实际上，上面的这些可选项都是通过这种形式定义的。</span><br></pre></td></tr></table></figure></li><li><p><code>nargs</code> ArgumentParser对象通常将一个动作与一个命令行参数关联。nargs关键字参数将一个动作与不同数目的命令行参数关联在一起：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nargs=N，一个选项后可以跟多个参数（action=&apos;append&apos;时，依然是一个选项后跟一个参数，只不过选项可以多次出现），参数的个数必须为N的值，这些参数会生成一个列表，当nargs=1时，会生成一个长度为1的列表。</span><br><span class="line">nargs=?，如果没有在命令行中出现对应的项，则给对应的项赋值为default。特殊的是，对于可选项，如果命令行中出现了此可选项，但是之后没有跟随赋值参数，则此时给此可选项并不是赋值default的值，而是赋值const的值。</span><br><span class="line">nargs=* 位置参数 0 到多个</span><br><span class="line">nargs=+ 位置参数 1 到多个</span><br><span class="line">nargs=argparse.REMAINDER，所有剩余的参数，均转化为一个列表赋值给此项，通常用此方法来将剩余的参数传入另一个parser进行解析。如果nargs没有定义，则可传入参数的数量由action决定，通常情况下为一个，并且不会生成长度为一的列表。</span><br></pre></td></tr></table></figure><ul><li><code>const</code> 一种是定义action=’store_const’或action=’append_const’时使用。一种是定义nargs=’?’时，可选项出现在命令行中，但之后并没有跟随赋值的参数，作为默认值传给此可选项。</li><li><code>default</code> 默认值。<br>  如果是一个字符串，那么Parser解析的时候会将它作为命令行传入值，使用type的值来进行转换类型，但是如果不是的话，就会使用定义的值而不进行类型转换。如果设置了nargs=’?’或nargs=<code>*</code>，那么当没有参数赋值给该项时，会使用default定义的值。<br>而default=argparse.SUPPRESS时，则表示命令行中未出现某一项时，不会对它进行默认赋值。</li><li><code>type</code> 用于类型检查和类型转换。<br>  使用FileType可简化对文件的操作。还可以自定义函数，输入是一个字符串，输出是转换后的字符串。当设置choices的时，类型检查会变得容易，因为只需要在一个范围内比较即可。</li><li><code>choices</code> 给定了取值范围，超出会报错。<br>  当type也有定义时，会先使用type进行类型检查，所以choices中的取值必须符合type的定义，否则在parse_args()时会报错。任何支持in操作符的均可作为choices的赋值，所以字典，列表，集合，等等其他容器均都支持。</li><li><code>required</code> 默认情况下，可选项（前面有’-‘）被认为并不一定需要出现在命令行参数中，但是如果设置了required=True的话，则必须出现。此类设置违背人的常识，应避免使用。</li><li><code>help</code> 帮助信息。<br>  之前提到的%(prog)s可用于此处程序名的格式化，此外，还有%(default)s格式化default的值，%(type)s格式化type的值。<br>设置为argparse.SUPPRESS可不显示帮助信息。</li><li><code>metavar</code> 在Parser生成帮助信息时，需要有字符代表需要传入的值。（这一段和dest相同，使用的就是dest的值）如果是位置参数，则用它本身代替；如果是可选参数，则使用它的大写来代替。使用metavar可替换默认的字符。</li><li><code>dest</code> 大部分的选项都需要通过命令行来给其赋值，这些值的名字通过dest来定义，默认的规则如同metavar中所述。</li></ul><h2><span id="shi-ji-ming-ling-de-li-zi">实际命令的例子</span><a href="#shi-ji-ming-ling-de-li-zi" class="header-anchor"></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls ~/Downloads ~/Documents</span></span><br><span class="line"><span class="comment"># 位置参数 0 或多个</span></span><br><span class="line">parser.add_argument(<span class="string">'files'</span>, nargs=<span class="string">'*'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget https://wxnacy.com</span></span><br><span class="line"><span class="comment"># 位置参数为必传</span></span><br><span class="line">parser.add_argument(<span class="string">'url'</span>, nargs=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget https://wxnacy.com</span></span><br><span class="line"><span class="comment"># 位置参数为必传</span></span><br><span class="line">parser.add_argument(<span class="string">'url'</span>, nargs=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl -X POST &lt;url&gt; -H 'Content-Type: application/json' -H 'Postman-Token: 0871758a-2782-4600-9d1f-e3da3270fd95'</span></span><br><span class="line"><span class="comment"># 可选参数可以叠加</span></span><br><span class="line">parser.add_argument(<span class="string">'-H'</span>, <span class="string">'--headers'</span>, action=<span class="string">'append'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -a</span></span><br><span class="line"><span class="comment"># 可选参数为 bool 类型</span></span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, action=<span class="string">'store_true'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 有很多处理命令行参数的外部模块，&lt;a href=&quot;https://github.com/pallets/click&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;click&lt;/a&gt; 是其中的佼佼者，如果你是要完成一个稍微复杂点的项目，我也推荐使用它。但是如果编写一个独立的脚本，我认为方便简洁才是最重要的，也就是能用内置模块就用内置模块。此时了解相应功能的实现方式就尤为重要，何况 &lt;a href=&quot;https://docs.python.org/3/howto/argparse.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;argparse&lt;/a&gt; 也真的没有想象中的那么难用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux split 分割日志</title>
    <link href="http://wxnacy.com/2019/06/25/linux-split/"/>
    <id>http://wxnacy.com/2019/06/25/linux-split/</id>
    <published>2019-06-25T06:43:11.000Z</published>
    <updated>2019-06-25T07:21:56.093Z</updated>
    
    <content type="html"><![CDATA[<p>split 命令用于将文件平均分割为多个小文件，多用于日志查看。</p><a id="more"></a><div class="toc"><!-- toc --><!-- tocstop --></div><p>先下载一个测试文件 <a href="https://raw.githubusercontent.com/wxnacy/file/master/common/split_test" target="_blank" rel="noopener">split_test</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ split split_test</span><br><span class="line">$ ll</span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 wxnacy  staff  216320 Jun 25 14:52 split_test</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xaa</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xab</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xac</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xad</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xae</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xaf</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xag</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xah</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xai</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   20000 Jun 25 14:54 xaj</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   16320 Jun 25 14:54 xak</span><br></pre></td></tr></table></figure><p>默认 <code>split</code> 会将文件均匀的分割成多个小文件，文件名以 <code>x</code> 开头，剩余字符按字符表排序。</p><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ split [OPTION]... [FILE [PREFIX]]</span><br></pre></td></tr></table></figure><p><code>split</code> 命令有多个参数可供调用</p><p><code>-b</code> 指定输出文件的大小，单位为 byte。<br><code>-d</code> 使用数字作为后缀。<br><code>-l</code> 指定输出文件的行数<br><code>-a</code> 指定后缀的长度</p><p><strong>分割出 100k 的文件</strong></p><p><code>-b</code> 默认单位为 byte，可以指定分割单位，如 <code>K,M,G,T,P,E,Z,Y</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 100k split_test</span><br><span class="line">$ ll</span><br><span class="line">total 856</span><br><span class="line">-rw-r--r--  1 wxnacy  staff  216320 Jun 25 14:52 split_test</span><br><span class="line">-rw-r--r--  1 wxnacy  staff  102400 Jun 25 14:59 xaa</span><br><span class="line">-rw-r--r--  1 wxnacy  staff  102400 Jun 25 14:59 xab</span><br><span class="line">-rw-r--r--  1 wxnacy  staff   11520 Jun 25 14:59 xac</span><br></pre></td></tr></table></figure><p><strong>使用数字为后缀，并指定长度</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 100k -d -a 4 split_test</span><br><span class="line">$ ll</span><br><span class="line">total 424</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 216320 Jun 25 07:12 split_test</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:13 x0000</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:13 x0001</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  11520 Jun 25 07:13 x0002</span><br></pre></td></tr></table></figure><p><strong>指定文件前缀</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 100k -d -a 4 split_test split.</span><br><span class="line">$ ll</span><br><span class="line">total 424</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 216320 Jun 25 07:12 split_test</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:15 split.0000</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 102400 Jun 25 07:15 split.0001</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  11520 Jun 25 07:15 split.0002</span><br></pre></td></tr></table></figure><p><strong>指定行数分割文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ split -l 1000 split_test</span><br><span class="line">$ ll</span><br><span class="line">total 428</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant 216320 Jun 25 07:12 split_test</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xaa</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xab</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xac</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xad</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xae</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xaf</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xag</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xah</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xai</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  20000 Jun 25 07:20 xaj</span><br><span class="line">-rw-rw-r-- 1 vagrant vagrant  16320 Jun 25 07:20 xak</span><br><span class="line"></span><br><span class="line">$ wc -l xaa</span><br><span class="line">1000 xaa</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;split 命令用于将文件平均分割为多个小文件，多用于日志查看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux date 获取指定时间</title>
    <link href="http://wxnacy.com/2019/06/18/date-want-time/"/>
    <id>http://wxnacy.com/2019/06/18/date-want-time/</id>
    <published>2019-06-18T03:07:25.000Z</published>
    <updated>2019-06-19T00:13:44.468Z</updated>
    
    <content type="html"><![CDATA[<p>最近要写一些清洗数据的脚本，需要用到各种日期格式，今天来探讨下使用 <code>date</code> 命令的 <code>-d/--date</code> 参数来获取指定时间。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#shi-jian-chuo">时间戳</a></li><li><a href="#shi-qu">时区</a></li><li><a href="#datestr">datestr</a><ul><li><a href="#shi-jian-chuo-1">时间戳</a></li><li><a href="#shi-jian-ge-shi">时间格式</a></li><li><a href="#next-guan-jian-zi">next 关键字</a></li><li><a href="#ago-guan-jian-zi">ago 关键字</a></li></ul></li></ul><!-- tocstop --></div><p><code>-d/--date</code> 是非常强大且语法很多样复杂的参数，我了解的可能并不全面，想到哪里说到哪，提到的东西只能保证满足日常开发需求。</p><p><strong>本文提到的命令都是在 Linux 环境下进行的，Mac 环境需要下载 <code>GNU</code> 相应的命令。</strong></p><h2><span id="shi-jian-chuo">时间戳</span><a href="#shi-jian-chuo" class="header-anchor"></a></h2><p>将描述转换为 UTC 时间 1970-01-01 以后的时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'@12'</span></span><br><span class="line">Thu Jan  1 00:00:12 UTC 1970</span><br></pre></td></tr></table></figure><p>很明显我们可以用它来做时间戳的格式化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'@1560825826'</span></span><br><span class="line">Tue Jun 18 02:43:46 UTC 2019</span><br></pre></td></tr></table></figure><p>然后可以使用 <code>+FORMAT</code> 将时间转为时间戳</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'2019-06-18 11:36:19'</span> +%s</span><br><span class="line">1560857779</span><br></pre></td></tr></table></figure><h2><span id="shi-qu">时区</span><a href="#shi-qu" class="header-anchor"></a></h2><p>服务器一般默认使用的是 UTC 时区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br><span class="line">Tue Jun 18 03:41:35 UTC 2019</span><br></pre></td></tr></table></figure><p>返回指定时区格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ TZ=<span class="string">"Asia/Shanghai"</span> date</span><br><span class="line">Tue Jun 18 11:28:42 CST 2019</span><br></pre></td></tr></table></figure><p>设置指定时间的时区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'TZ="Asia/Shanghai" 2019-06-18 11:13:59'</span></span><br><span class="line">Tue Jun 18 03:13:59 UTC 2019</span><br></pre></td></tr></table></figure><p>世界时区名称列表 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">List of tz database time zones</a></p><h2><span id="datestr">datestr</span><a href="#datestr" class="header-anchor"></a></h2><p><code>-d/--date</code> 的语法为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ date -d datestr</span><br></pre></td></tr></table></figure><p>前面我们已经简单领略了他的使用方式，下面详细说说他都支持什么格式。</p><h3><span id="shi-jian-chuo">时间戳</span><a href="#shi-jian-chuo" class="header-anchor"></a></h3><p>这里注意一定要前面加上 <code>@</code> 符号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'@12'</span></span><br><span class="line">Thu Jan  1 00:00:12 UTC 1970</span><br></pre></td></tr></table></figure><h3><span id="shi-jian-ge-shi">时间格式</span><a href="#shi-jian-ge-shi" class="header-anchor"></a></h3><p>如果不加 <code>@</code> 会怎么样呢，如果传入的数字默认返回当天的指定小时的时间，取值 [0, 23]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'12'</span></span><br><span class="line">Tue Jun 18 12:00:00 UTC 2019</span><br></pre></td></tr></table></figure><p>更复杂的格式化按照标准格式 <code>YYYY-mm-dd HH:MM:SS</code> 来指定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'2019-06-18 11:58:20'</span></span><br><span class="line">Tue Jun 18 11:58:20 UTC 2019</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'11:20'</span></span><br><span class="line">Tue Jun 18 11:20:00 UTC 2019</span><br></pre></td></tr></table></figure><p>咦？似乎这样的设置没什么意义啊，固定的日子和时间，我为什么要多此一举的用 <code>date</code> 在获取一次。确实，它再搭配一点其他的语句就有很大的用处了。</p><h3><span id="next-guan-jian-zi">next 关键字</span><a href="#next-guan-jian-zi" class="header-anchor"></a></h3><p><code>next</code> 关键字可以让上面的命令更有意义</p><p>获取明天 9 点的时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'9 next day'</span></span><br><span class="line">Wed Jun 19 09:00:00 UTC 2019</span><br></pre></td></tr></table></figure><p>下周</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'9 next week'</span></span><br><span class="line">Wed Jun 25 09:00:00 UTC 2019</span><br></pre></td></tr></table></figure><p>下周一</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'9 next Mon'</span></span><br><span class="line">Wed Jun 24 09:00:00 UTC 2019</span><br></pre></td></tr></table></figure><p>下个月</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'9 next month'</span></span><br><span class="line">Wed Jun 24 09:00:00 UTC 2019</span><br></pre></td></tr></table></figure><p>如你所见，<code>next</code> 后面跟一个符合常理的时间或缩写就可以获取指定时间以后的某个时间，如果去掉 <code>9</code>，则返回的是当前时间以后的时间。</p><p>下一分钟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'next minute'</span></span><br><span class="line">Tue Jun 18 04:13:04 UTC 2019</span><br></pre></td></tr></table></figure><p>总结下 <code>next</code> 后面跟的参数</p><ul><li><code>second[s]</code> <code>minute[s]</code> <code>hour[s]</code> <code>day[s]</code> <code>week[s]</code> <code>month[s]</code> <code>year[s]</code></li><li>星期 <code>Sun[day]</code> <code>Mon[day]</code> <code>Tue[sday]</code> <code>Wed[nesday]</code> <code>Thu[rsday]</code> <code>Fri[day]</code> <code>Sat[urday]</code></li></ul><h3><span id="ago-guan-jian-zi">ago 关键字</span><a href="#ago-guan-jian-zi" class="header-anchor"></a></h3><p>可以获取之后，就可以获取之前的时间，安装英语的语法应该这样的</p><p>一分钟前</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'1 minute ago'</span></span><br><span class="line">Tue Jun 18 06:31:15 UTC 2019</span><br></pre></td></tr></table></figure><p><code>09:00</code> 的一分钟前</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'09:00 minute ago'</span></span><br><span class="line">Tue Jun 18 08:59:00 UTC 2019</span><br></pre></td></tr></table></figure><p>相信不用多举例，你也已经可以明白它的用法了，另外最前面的数字可以为负数，代表的是时间以后。下面两种方式都是获取以后以后的时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ date -d <span class="string">'-1 day ago'</span></span><br><span class="line">Wed Jun 19 06:36:53 UTC 2019</span><br><span class="line"></span><br><span class="line">$ date -d <span class="string">'next day'</span></span><br><span class="line">Wed Jun 19 06:37:00 UTC 2019</span><br></pre></td></tr></table></figure><p>总结下 <code>ago</code> 前可以使用的参数</p><ul><li><code>second[s]</code> <code>minute[s]</code> <code>hour[s]</code> <code>day[s]</code> <code>week[s]</code> <code>month[s]</code> <code>year[s]</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要写一些清洗数据的脚本，需要用到各种日期格式，今天来探讨下使用 &lt;code&gt;date&lt;/code&gt; 命令的 &lt;code&gt;-d/--date&lt;/code&gt; 参数来获取指定时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wxnacy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 内存管理</title>
    <link href="http://wxnacy.com/2019/06/16/python-memory-management/"/>
    <id>http://wxnacy.com/2019/06/16/python-memory-management/</id>
    <published>2019-06-16T07:08:10.000Z</published>
    <updated>2019-07-01T11:39:47.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>要不这样吧，如果编程语言里有个地方你弄不明白，而正好又有个人用了这个功能，那就开枪把他打死。这比学习新特性要容易些，然后过不了多久，那些活下来的程序员就会开始用 0.9.6 版的 Python，而且他们只需要使用这个版本中易于理解的那一小部分就好了（眨眼）。<br>  —— Tim Peters （传奇的核心开发者，“Python 之禅”作者）</p></blockquote><p>今天我们来聊一聊 Python 的内存管理。</p><a id="more"></a><div class="toc"><!-- toc --><ul><li><a href="#dui-xiang-yin-yong">对象引用</a><ul><li><a href="#bian-liang-ding-yi">变量定义</a></li><li><a href="#dong-tai-lei-xing">动态类型</a></li><li><a href="#dui-xiang-yin-yong-1">对象引用</a></li></ul></li><li><a href="#yin-yong-ji-shu">引用计数</a><ul><li><a href="#zeng-jia-yin-yong-ji-shu">增加引用计数</a></li><li><a href="#jian-shao-yin-yong-ji-shu">减少引用计数</a></li></ul></li><li><a href="#huan-cun-chi">缓存池</a><ul><li><a href="#bu-er-zhi">布尔值</a></li><li><a href="#xiao-zheng-shu">小整数</a></li><li><a href="#shou-gui-ju-zi-fu-chuan">守规矩字符串</a></li><li><a href="#xiang-tong-dai-ma-kuai">相同代码块</a></li></ul></li><li><a href="#la-ji-hui-shou">垃圾回收</a><ul><li><a href="#yin-yong-ji-shu-wei-0-de">引用计数为 0 的</a></li><li><a href="#fen-dai-hui-shou">分代回收</a></li><li><a href="#xun-huan-yin-yong">循环引用</a></li></ul></li><li><a href="#can-kao-wen-xian">参考文献</a></li></ul><!-- tocstop --></div><h2><span id="dui-xiang-yin-yong">对象引用</span><a href="#dui-xiang-yin-yong" class="header-anchor"></a></h2><h3><span id="bian-liang-ding-yi">变量定义</span><a href="#bian-liang-ding-yi" class="header-anchor"></a></h3><p>Python 不像多数的编译语言那样，需要对变量进行显示的声明。变量在第一次赋值时自动声明，变量只有被创建和赋值后才能被使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>k</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    k</span><br><span class="line">NameError: name <span class="string">'k'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3><span id="dong-tai-lei-xing">动态类型</span><a href="#dong-tai-lei-xing" class="header-anchor"></a></h3><p>严格来说变量是没有类型的，对象才有类型，变量引用了什么类型的对象，它就是什么类型。</p><p>变量的类型无需声明，是在程序运行时动态确定的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>k = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(k)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; k = "a"</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(k)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="dui-xiang-yin-yong">对象引用</span><a href="#dui-xiang-yin-yong" class="header-anchor"></a></h3><p>如何理解变量是对对象的引用呢？内置函数 <code>id()</code> 可以返回对象的内存地址，我们来看一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">1</span>)</span><br><span class="line"><span class="number">4432996208</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4432996208</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4432996208</span></span><br></pre></td></tr></table></figure><p>给变量 <code>a</code> 赋值 <code>1</code>，又给 <code>b</code> 赋值了 <code>a</code>，此时 <code>b</code> 并没有创建新对象，而是引向了 <code>a</code> 所指向的对象，换句话说 <code>b</code> 是对象的另一个别名。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/memory1.png" alt="1"></p><p>现在考虑一个问题，如果此时将 <code>a</code> 赋值为 <code>2</code>，<code>b</code> 等于多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果明白了上面说的，可以得到 <code>b</code> 依然等于 <code>1</code>，因为 <code>a</code> 和 <code>b</code> 都作为对象 <code>1</code> 的引用变量，现在只是将 <code>a</code> 引向其他对象，<code>b</code> 并不受影响。</p><p><img src="https://raw.githubusercontent.com/wxnacy/image/master/blog/memory2.png" alt="2"></p><p>如果这一点可以理解的话，再看一个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br></pre></td></tr></table></figure><p>这时输出 <code>b</code> 你觉得会返回什么结果呢？</p><p>变量 <code>a</code> 和 <code>b</code> 都引用了列表对象 <code>[1, 2, 3]</code>，<code>a[0] = 4</code> 只是将列表对象索引位置 <code>0</code> 的子对象替换为 <code>4</code>，变量 <code>a</code> 和 <code>b</code> 对它的引用关系都没有改变，所以 <code>b</code> 也等于 <code>[4, 2, 3]</code></p><h2><span id="yin-yong-ji-shu">引用计数</span><a href="#yin-yong-ji-shu" class="header-anchor"></a></h2><p>刚才我们讲 <code>b = a</code> 时，提到此时 <code>b</code> 并没有创建新的对象，而是引用了 <code>a</code> 所引用的对象。</p><p>每个对象都包含一个头部信息，内容为类型标识符和引用计数器(Reference counter)。当对象被创建时 <code>a = [1, 2, 3]</code> 该对象的引用计数设置为 1，当对象有一个新的引用时，引用计数会自动加 1。</p><h3><span id="zeng-jia-yin-yong-ji-shu">增加引用计数</span><a href="#zeng-jia-yin-yong-ji-shu" class="header-anchor"></a></h3><p><code>sys</code> 模块中的 <code>getrefcount()</code> 函数可以获取对象的引用计数。当对象做参数传入该函数时，实际上也创建一个该对象的引用，所以返回值比预期会加 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>对象的引用计数增加，有下面几种情况</p><ul><li>对象被创建</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">114</span></span><br></pre></td></tr></table></figure><p><code>114</code> 这个数字有些过于超出我们的预期，我先按下不表，稍后的缓存池小节我会讲到。</p><ul><li>对象被其他变量引用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">115</span></span><br></pre></td></tr></table></figure><ul><li>对象成为容器对象的一个元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">123</span>, <span class="number">256</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">116</span></span><br></pre></td></tr></table></figure><ul><li>对象作为参数传递给函数（新的本地引用）<code>foo(n)</code></li></ul><h3><span id="jian-shao-yin-yong-ji-shu">减少引用计数</span><a href="#jian-shao-yin-yong-ji-shu" class="header-anchor"></a></h3><p>有增加，就会有减少。对象的引用不会不休止的增加，下面几种情况引用计数会减少</p><ul><li>对象的引用变量被赋值给另一个对象时</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">119</span></span><br></pre></td></tr></table></figure><ul><li>对象的引用变量被显示的销毁</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">118</span></span><br></pre></td></tr></table></figure><p><code>del</code> 语句会产生两个结果</p><ul><li><ul><li>从现在的变量名称空间中删除 <code>b</code></li></ul></li><li><ul><li>对象 <code>256</code> 的引用减少 1</li></ul></li><li><p>对象被一个容器对象中移除</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">123</span>, <span class="number">256</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">118</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.remove(<span class="number">256</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">117</span></span><br></pre></td></tr></table></figure><ul><li>容器对象本身被销毁</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">123</span>, <span class="number">256</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">118</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="number">256</span>)</span><br><span class="line"><span class="number">117</span></span><br></pre></td></tr></table></figure><ul><li>一个本地引用离开其作用域时，比如 <code>foo(n)</code> 函数执行完毕时</li></ul><p>当对象的最后一个引用被移除时，该对象的引用计数减少为 0，这会导致该对象<strong>无法被访问</strong>。该对象就会成为垃圾回收机制的回收对象，而任何对该对象的追踪或调试都将增加它的引用计数，这也将推迟该对象被回收的时间。</p><h2><span id="huan-cun-chi">缓存池</span><a href="#huan-cun-chi" class="header-anchor"></a></h2><p>刚才我抛出了一个问题，对象 <code>256</code> 刚被创建出来，引用计数就是 <code>114</code>，有点诡异。</p><p>其实 Python 内部存在一个缓存池，缓存池内的对象在内存中只存在一份。所有符合缓存规则的对象，如果该对象不存在，创建后会进入缓存池，以后再次调用只是增加引用计数，如果该对象已经存在，那么针对它的所有调用都只是增加它的引用计数，即不会增加新的内存地址。这有一个很明显的好处，缓存池中的对象都是程序中最常用到的，缓存池的机制将在一定程度上减少内存的消耗。</p><p>现在可以回答刚才的问题了，<code>256</code> 对象身处缓存池中，所以我们以为 <code>a = 256</code> 是对它的创建，但其实只是某一个引用而已。</p><p>Python 的缓存池会包含三部分<strong>布尔值</strong>、<strong>小整数</strong>和<strong>守规矩字符串</strong></p><h3><span id="bu-er-zhi">布尔值</span><a href="#bu-er-zhi" class="header-anchor"></a></h3><p>布尔值比较好说，就两个值，任何情况下它都会被缓存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3><span id="xiao-zheng-shu">小整数</span><a href="#xiao-zheng-shu" class="header-anchor"></a></h3><p>这个小整数的范围为 [-5, 256]，我们想办法对此做一些验证。Python 中判断两个对象的值是否相等时可以使用 <code>==</code>，而判断两个对象是否为同一内存地址时需要使用 <code>is</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p><code>257</code> 超出了整数缓存池的范围，所以每次赋值都会创建一个新对象，即内存地址不同，我们可以通过 <code>id()</code> 函数查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4597659056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4592739216</span></span><br></pre></td></tr></table></figure><p>所以一般情况下你看到的拥有两个相同值的变量，往往他们引向的是两个不同的对象。</p><h3><span id="shou-gui-ju-zi-fu-chuan">守规矩字符串</span><a href="#shou-gui-ju-zi-fu-chuan" class="header-anchor"></a></h3><p>字符串的缓存逻辑比较复杂，我将符合规则的字符串称为<strong>守规矩字符串</strong>，规则有下面几种情况</p><ul><li>长度为 1 时</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"@"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"@"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li>长度大于 1，并且只含有大小写字母、数字、下划线时</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"wo_ai_ni_zhongguo"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"wo_ai_ni_zhongguo"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li><p>某些乘法时</p></li><li><ul><li>乘数为 1</li></ul></li><li><ul><li><ul><li>字符串长度等于 1</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"@"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"@"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li><ul><li><ul><li>字符串长度大于 1，且只含有大小写字母、数字、下划线时</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"wo_ai_ni_zhongguo"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"wo_ai_ni_zhongguo"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li><ul><li>乘数大于 1，仅含大小写字母，数字，下划线，总长度&lt;=20</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"wxnacy"</span> * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"wxnacy"</span> * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>面对这么多的规则，完全靠记忆的话，在开发中难免有些畏手畏脚，并且通常我们涉及到的字符串都比较复杂，那么这时我们怎么优化内存的使用呢？</p><p><code>sys</code> 模块中有一个函数 <code>insern()</code>，可以将任何形式的字符驻留在缓存池中，同时也可以将该字符从缓存池中取出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sys <span class="keyword">import</span> intern</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = intern(<span class="string">"12345!@#$%^qwertZXCV"</span> * <span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = intern(<span class="string">"12345!@#$%^qwertZXCV"</span> * <span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="string">"12345!@#$%^qwertZXCV"</span> * <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> c</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>每次使用都要调用该函数，才能保持字符串的内存地址一致，刚才我们提到的那些守规矩字符串内部也是这样实现的。我有理由相信，在任何需要字符串复用的地方都可以使用该函数，这将大大的优化程序的内存消耗</p><h3><span id="xiang-tong-dai-ma-kuai">相同代码块</span><a href="#xiang-tong-dai-ma-kuai" class="header-anchor"></a></h3><p>你以为到这就完了吗，再等等，还差点。</p><p>刚才我们的实验都是在不同代码块中进行的，在 Python 交互模式下，每个独立命令都是一个单独的代码块。而在相同的代码块下，缓存池的规则将简单很多。</p><p>任何的整数和布尔类型在相同代码块中都满足缓存机制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="number">1234567</span></span><br><span class="line"><span class="meta">... </span>    b = <span class="number">1234567</span></span><br><span class="line"><span class="meta">... </span>    print(a <span class="keyword">is</span> b)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>字符串依然要单拎出来说下</p><ul><li>非乘法得到的字符串都满足缓存机制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="string">"1234567!@#$%^&amp;QWERTY"</span></span><br><span class="line"><span class="meta">... </span>    b = <span class="string">"1234567!@#$%^&amp;QWERTY"</span></span><br><span class="line"><span class="meta">... </span>    print(a <span class="keyword">is</span> b)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li>乘法时，乘数为 1 时都满足缓存机制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="string">"1234567!@#$%^&amp;QWERTY"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    b = <span class="string">"1234567!@#$%^&amp;QWERTY"</span> * <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    print(a <span class="keyword">is</span> b)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li>乘数大于 1 时，仅含大小写字母，数字，下划线，且总长度小于等于 20 满足缓存机制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="string">"wxnacy"</span> * <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    b = <span class="string">"wxnacy"</span> * <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    print(a <span class="keyword">is</span> b)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>除了上面说的类型，其它的类型如数组、字典等都不会进入缓存池</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2><span id="la-ji-hui-shou">垃圾回收</span><a href="#la-ji-hui-shou" class="header-anchor"></a></h2><p>我们给变量分配的内存，其实是在借用系统资源，有借就要有还。还资源的步骤就是垃圾回收时进行的，Python 解释器将会承担内存分配回收的复杂任务，我们只需要关心我们的业务流程，以及尽量的了解垃圾回收的过程，并写出更好的代码。</p><!-- 垃圾回收器在回收内存时会有遇到两种情况 --><h3><span id="yin-yong-ji-shu-wei-0-de">引用计数为 0 的</span><a href="#yin-yong-ji-shu-wei-0-de" class="header-anchor"></a></h3><p>前面我们提到，对象的引用会将它的引用计数加 1，而移除对它的引用会自动减 1。当对象的引用计数为 0 时，它将成为一个待回收的垃圾内存。</p><p>垃圾回收器会寻找这些引用计数为 0 的对象，垃圾回收时 Python 无法进行其它的任务，这个过程会将降低工作效率，所以当垃圾内存很少时没有必要频繁的执行垃圾回收。</p><p>当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</p><p><strong>查看阈值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> gc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.get_threshold()</span><br><span class="line">(<span class="number">700</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>返回值解释</p><ul><li><code>700</code> 垃圾回收启动的阈值</li><li><code>10</code> 每 10 次 0 代垃圾回收，会配合 1 次 1 代的垃圾回收</li><li><code>10</code> 每 10 次 1 代垃圾回收，会配合 1 次 2 代的垃圾回收</li></ul><p>我们也可以手动启动垃圾回收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.collect()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3><span id="fen-dai-hui-shou">分代回收</span><a href="#fen-dai-hui-shou" class="header-anchor"></a></h3><p>Python 将所有的对象分为 0、1、2 代，所有新建的对象为 0 代，每经历一次垃圾回收，依然存活的对象，会归入下一代对象。</p><p>分代（generation）回收策略基于这样的假设，在程序运行过程中，存活时间越久的对象，越不容易在后面的程序中变成垃圾。对于经历了几次垃圾回收依然存活的对象，出于信任和效率的考虑，垃圾回收器会减少对它的扫描频率。</p><h3><span id="xun-huan-yin-yong">循环引用</span><a href="#xun-huan-yin-yong" class="header-anchor"></a></h3><p>相信有过开发经验的同学都会碰见循环引用的情况，两个对象相互引用，会构成<strong>引用环（reference cycle）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [a]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> b</span><br></pre></td></tr></table></figure><p>在引用环中，即使删除了 <code>a</code> 和 <code>b</code> 对象，但是仍然有部分对象，从此以后无法使用，引用计数也不为 0，这将给垃圾回收造成很大的麻烦。</p><p>我们来模拟一下这个无法使用、引用计数也不为 0 的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="string">"wxnacy"</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">"wxnacy"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="string">"wxnacy"</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [a]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="string">"wxnacy"</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="string">"wxnacy"</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrefcount(<span class="string">"wxnacy"</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>相信看过前面章节后，很容易可以理解这个流程。我以短字符串 <code>wxnacy</code> 为参考对象，执行函数 <code>getrefcount(&quot;wxnacy&quot;)</code> 获取初始引用计数 2 （字符串本身被创建引用一次，getrefcount 函数本地引用一次），容器对象 <code>a</code> 引用加 1，直到 <code>del a</code> 前没有增加引用，而这一步删除容器对象的操作，本应该减少一次对 <code>wxnacy</code> 的引用次数，然后最后再次获取引用次数时，依然为 3，<code>wxnacy</code> 对象就将作为那个无法被使用，但是引用计数又不为 0 的对象遗漏在内存中。</p><p>为了回收这样的对象，Python 复制了每个对象的引用计数，记做 <code>gc_ref</code>，假设，每个对象 i，该计数为 <code>gc_ref_i</code>。Python 会遍历所有的对象 i。对于每个对象 i 引用的对象 j，将相应的 <code>gc_ref_j</code> 减 1。</p><p>在结束遍历后，<code>gc_ref</code> 不为 0 的对象，和这些对象引用的对象，以及更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.collect()</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>手动执行垃圾回收发现回收了两个对象，这说明这个简单的引用环就有两个无法被回收的对象，实际开发中这样的对象将是一个可怕的数字。</p><p>深入了解一门语言，理解内存管理机制是很有必要的。搞清楚内存分配和垃圾回收的过程，将会是提供程序性能的重要一步。现在再回过头来去看以前的代码，就会发现很多有风险的代码隐藏在其中，而现在能写出优秀的代码，也将是理所当然的。</p><h2><span id="can-kao-wen-xian">参考文献</span><a href="#can-kao-wen-xian" class="header-anchor"></a></h2><ul><li>Python 核心编程（第二版）49 页</li><li><a href="https://www.cnblogs.com/geaozhang/p/7111961.html" target="_blank" rel="noopener">Python内存管理机制</a></li><li><a href="https://www.cnblogs.com/jin-xin/articles/9439483.html" target="_blank" rel="noopener">python小数据池，代码块的最详细、深入剖析</a></li><li><a href="https://www.cnblogs.com/vamei/p/3232088.html" target="_blank" rel="noopener">Python深入06 Python的内存管理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;要不这样吧，如果编程语言里有个地方你弄不明白，而正好又有个人用了这个功能，那就开枪把他打死。这比学习新特性要容易些，然后过不了多久，那些活下来的程序员就会开始用 0.9.6 版的 Python，而且他们只需要使用这个版本中易于理解的那一小部分就好了（眨眼）。&lt;br&gt;  —— Tim Peters （传奇的核心开发者，“Python 之禅”作者）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来聊一聊 Python 的内存管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://wxnacy.com/tags/python/"/>
    
  </entry>
  
</feed>
